<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Fortran语言学习——文件</title>
    <link href="/2021/09/28/fortran-file/"/>
    <url>/2021/09/28/fortran-file/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>计算机有两项功能，一项是计算、处理数据；一项是保存数据。前面的内容都是在讨论如何处理数据，现在来讨论如何保存数据。</p><p>数据的保存主要是依赖于文件，程序将数据写入文件，就可以将这些数据长久的保存，直到文件被更改或者销毁。</p>          </div><h1 id="文件读取的概念🍉"><a href="#文件读取的概念🍉" class="headerlink" title="文件读取的概念🍉"></a>文件读取的概念🍉</h1><p>Fortran中文件读取有“顺序读取”和“直接读取”两种：</p><ol><li>顺序读取：指的是读取文件时按照文件中数据的顺序从头开始，依次往下读取，如同听录音带一样。这是最简单的方法，足以应付绝大多数情况；</li><li>直接读取：指读取文件时可以任意跳到文件的任何一个位置开始读写，类似于DVD，可以直接欣赏某一个部分。</li></ol><p>保存文件同样可以有两种方法：</p><ol><li>文本文件：所有的数据都是容易阅读的字符或者符号，可以使用文本编辑器打开；</li><li>二进制文件：数据被保存为二进制代码（全是数字0和1组成），需要专门的软件打开。</li></ol><p>相对来说，二进制的文件读取速度更快，它的保存格式与数据在内存中的格式是一致的，不像文本格式需要经过转换；其次，二进制的文件更加省空间，很简单，计算机底层的结构就是二进制，自然具有各方面的优势。</p><hr><h1 id="文件的操作🍈"><a href="#文件的操作🍈" class="headerlink" title="文件的操作🍈"></a>文件的操作🍈</h1><div class="note note-primary">            <p>该部分的内容很多，只需要记住常见命令即可，很多命令基本不会用到。</p>          </div><h2 id="OPEN的使用"><a href="#OPEN的使用" class="headerlink" title="OPEN的使用"></a><code>OPEN</code>的使用</h2><p><code>open</code>的使用与<code>write(*,*)</code>以及<code>read(*,*)</code>中的第一个*号（输入\输出的位置，默认是键盘\屏幕）有关：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran">open(<span class="hljs-keyword">unit</span>=<span class="hljs-number">10</span>,<span class="hljs-keyword">file</span>=<span class="hljs-string">&#x27;hello.txt&#x27;</span>)<br><span class="hljs-comment">! unit=N用来给后面的文件指定一个代码（N），file则表示打开的文件</span><br><span class="hljs-comment">! 文件不存在时则创建一个新文件</span><br><span class="hljs-built_in">write</span>(<span class="hljs-number">10</span>,*) <span class="hljs-string">&quot;hello,World!&quot;</span><br><span class="hljs-comment">! 如此一来，&quot;hello,World!&quot;这个字符串就被保存到文件hello.txt中了</span><br></code></pre></div></td></tr></table></figure><p><code>open</code>的详细参数非常之多，这里列出比较常见的：</p><ol><li>unit=number，number必须是一个正整数，可以是变量，尽量不要用1，2，5，6（<span style='background: yellow;'>1，5是默认输入的位置，即键盘；2，6是默认输出的位置，即屏幕</span>）；</li><li>file=’filename’，很简单，文件名，注意要符合操作系统的文件命名习惯；</li><li>form=’formatted’（ <strong>‘文本格式’</strong> 保存）\’unformatted’（ <strong>‘二进制格式’</strong> 保存）,默认’<strong>文本格式</strong>‘；</li><li>status=’new’（打开新文件）\’old’（打开旧文件）\’replace’（文件若已经存在，则替换原文件，不存在则新建）\’scratch’（暂时文件，此时不用指定文件名，程序结束文件会被自动删除）\’unkown’（由编译器自定义，一般相当于’replace’），默认’unkown’；</li><li>access=’sequential’（ <strong>‘顺序读取’</strong> 文件）\’direct’（ <strong>‘直接读取’</strong> 文件），默认 <strong>‘顺序读取’</strong> ；</li><li>err=label，文件打开错误时，程序会跳转到label所指的行代码继续执行；</li><li><p>iostat=var，将文件打开的状态赋值给var变量（这意味着要对其进行声明）：</p><ul><li>var &gt; 0 : 读取操作发生错误；</li><li>var &lt; 0 : 文件终了；</li><li>var = 0 : 文件读取正常。</li></ul></li><li><p>action=’read’（<strong>只读</strong>）\’write’（<strong>只写</strong>）\’readwrite’（<strong>读写皆可</strong>，默认）。</p></li></ol><h2 id="WRITE，READ的使用"><a href="#WRITE，READ的使用" class="headerlink" title="WRITE，READ的使用"></a><code>WRITE</code>，<code>READ</code>的使用</h2><p><code>read</code>和<code>write</code>的详细是类似的，所以放到一起介绍：</p><ol><li>unit=number，和<code>open</code>的<code>unit</code>联系起来，用来指定输出\输入的位置；</li><li>fmt=format，指定输入输出的格式；</li><li>nml=namelist，指定读写某个namelist的内容（namelist的含义需要到后面介绍）；</li><li>rec=record，在直接读取文件中，设置索要读写的文件模块的位置；</li><li>iostat\err\end，用法和<code>open</code>一样；</li><li>advance=yes（默认状态，每读写一次会向下移动一行）\no（暂停自动换行）。</li></ol><h2 id="查询文件的状态INQUIRE"><a href="#查询文件的状态INQUIRE" class="headerlink" title="查询文件的状态INQUIRE"></a>查询文件的状态<code>INQUIRE</code></h2><p><code>inquire</code>命令主要用来查询文件此时的状态，其同样支持很多参数：</p><ol><li>UNIT=number，文件代号；</li><li>FILE=filename，文件名；</li><li><p>IOSTAT=stat，查询文件读取情况，会设置一个整数给后面的变量：</p><ul><li>stat&gt;0   文件读取操作错误</li><li>stat=0   文件读取操作正常</li><li>stat&lt;0   文件终了</li></ul></li><li><p>ERR=errlabel，发生错误时会转移到复制的代码行继续执行程序；</p></li><li>EXIST=exist，检查文件是否存在，返回布尔变量，真表示存在，假值表示不存在；</li><li>OPEND=opened，检查文件是否用已经用open打开，返回布尔变量，真表示已经打开，假表示尚未打开；</li><li>NUMBER=number，用文件名来查询这个文件所给定的代码；</li><li>NAMED=named，查询文件是否取了名字，也就是检查文件是否为临时保存盘，返回值为逻辑数；</li><li>ACCESS=access，检查文件的读取格式，返回一个字符串；</li><li>SEQUENTIAL=sequential，查看文件是否使用顺序格式，会返回一个字符串；</li><li>DIRECT＝direct，查看文件是否使用直接格式，会返回一个字符串；</li><li>FORM=form，查看文件的保存方法，返回字符串；</li><li>FORMATTED=fmt，查看文件是否是文本文件，返回字符串；</li><li>UNFORMATTED=fmt，查看文件是否是二进制文件，返回字符串；</li><li>RECL=length，返回open文件时recl栏的设置值</li><li>NEXTREC=nr，返回下一次文件读写的位置；</li><li>BLANK=blank，返回值是字符串，用来查看open文件时的blank参数所给定的字符串值；</li></ol><p><strong>以下是fortran 90的添加功能：</strong></p><ol><li>POSITION=position，返回打开文件时position字段所给定的字符串, 可能是’REWIND’,’APPEND’,’ASIS’, ‘UNDEFINED’</li><li>ACTION=action，返回打开文件时action 字段所赋值的字符串，可能是’READ’, ‘WRITE’,’READWRITE’。</li><li>READ=read,返回字符串，检查文件是否为只读文件；</li><li>WRITE=write，返回一个字符串，检查文件是否可写入；</li><li>READWRITE=readwrite 返回一个字符串，检查文件是否可以同时读及写；</li><li>DELIM=delim，返回打开文件时，DELIM字段所设置的字符串，返回值可以是：’APOSTROPHE’, ‘QUOTE’, ‘NONE’, ‘UNDEFINED’；</li><li>PAD=pad，返回打开文件时PAD字段所设置的字符串，返回值可以是：’YES’, ‘NO’。</li></ol><p><strong>其他文件运行命令：</strong></p><ol><li>BACKSPACE(UNIT=number, ERR=errlabel, IOSTAT=iostat)，把文件读写位置退回一步；</li><li>ENDFILE(UNNIT=number, ERR=errlabel, IOSTAT=iostat)，使用这个命令会把目前文件的读写位置变成文件的结尾；</li><li>REWIND(UNIT=number, ERR=errlabel, IOSTAT=iostat)，把文件的读写位置倒回到文件开头；</li><li><p>CLOSE(UNIT=number, STATUS=string, ERR=errlabel, IOSTAT=)，把文件关闭，不要进行读写操作；</p><ul><li>STAT=’KEEP’      会在文件关闭后，保留这个文件。是默认状态。</li><li>STAT=’DELETE’    在文件关闭后，消除这个文件。</li></ul></li></ol><div class="note note-danger">            <ul><li>程序结束时候会自动关闭文件，不过最好要养成自己关闭文件的习惯。</li><li>在读文件的时候要懂得略掉一些没有必要的数据，如文件中的注释行。</li><li>自由格式的数据文件读取（可以先读入前面的判断字符，结合select case或其他方法判断读入的数据）在open,read,write时使用不同的unit值，就可以打开多个文件。最好不要同时打开很多个文件。</li></ul>          </div><hr><h1 id="读取文件方式的操作🍇"><a href="#读取文件方式的操作🍇" class="headerlink" title="读取文件方式的操作🍇"></a>读取文件方式的操作🍇</h1><p>顺序文件在读写时，只能从头开始一步一步向下进行。改变文件读写位置时，只能一步一步地进退，或者直接移回文件开头。</p><p>直接读取文件的意思是把文件的空间、内容事先分区成好几个同样大小的小模块，这些模块会自动按照顺序编号，读取文件时，要先赋值文件读写位置在第几个模块（<code>read</code>命令中的<code>rec</code>参数）</p><hr><h1 id="二进制文件的操作🍒"><a href="#二进制文件的操作🍒" class="headerlink" title="二进制文件的操作🍒"></a>二进制文件的操作🍒</h1><p>二进制文件由于是按照计算机内存保存数据的方式对数据进行保存的，所以会存在和文本文件字符数不一致的问题：也就是<code>open</code>命令中<code>recl</code>（表示输出长度）所设置的整数 n 的值所代表的大小会因为编辑器的不同而不同，不过都是可以经过设置而改变的。</p><p>另外，二进制文件通常是一串紧密的数字，也就没有必要为了增加可读性而在数据之间使用区分符号，因为二进制文件没有可读性可言。</p><div class="note note-success">            <p>二进制文件相对于文本文件来说不会存在数据损失的情况（主要是在保存数字时），所以当需要存放“<strong>精确</strong>”且“<strong>大量</strong>”的数据时建议使用二进制进行保存</p>          </div><hr><h1 id="Internal-File（内部文件）🥥"><a href="#Internal-File（内部文件）🥥" class="headerlink" title="Internal File（内部文件）🥥"></a>Internal File（内部文件）🥥</h1><p>所谓内部文件就是<span style='background: yellow;'>使用写入文件的方法，把数据写到一个字符串变量中</span>。举个栗子🌰：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">a=<span class="hljs-number">2</span><br>b=<span class="hljs-number">3</span><br><span class="hljs-keyword">character</span> (len=<span class="hljs-number">20</span>) :: string<br><span class="hljs-built_in">write</span> (<span class="hljs-keyword">unit</span>=string, <span class="hljs-keyword">fmt</span>=<span class="hljs-string">&quot;(I2,&#x27;+&#x27;,I2,&#x27;=&#x27;,I2)&quot;</span>) a, b, a+b <span class="hljs-comment">!把字符串变量当作输出的目的。</span><br><span class="hljs-built_in">write</span>(*, *) string<br></code></pre></div></td></tr></table></figure><p>结果是: </p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">2+ 3= 5<br></code></pre></div></td></tr></table></figure><p>还可以经过<code>read</code>命令从字符串读入数据：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> :: a<br><span class="hljs-keyword">character</span> (len=<span class="hljs-number">20</span>) :: string=<span class="hljs-string">&quot;123&quot;</span><br>read(string, *) a<br><span class="hljs-built_in">write</span>(*, *) a<br></code></pre></div></td></tr></table></figure><p>在某些情况下使用内部文件来设置数据有十分必要的好处：</p><p>使用<code>read</code>命令从键盘输入数据时，如果用户输入错误的数据，会导致死机。比如如需要输入整数时却输入英文字母，就可能会死机。比较好的处理办法是，程序先暂时把数据当作字符串读入，检查字符串中是否含有不合理的字符，如果字符串中都是0～9的数字字符，就把字符串转成整数，不然就请用户在输入一次。</p><p>另外，内部文件还可应用在动态改变输出格式，输出格式可以事先存放在字符串中，程序进行时，动态改变字符串内容就可以改变输出格式。</p><hr><h1 id="NAMELIST🍓"><a href="#NAMELIST🍓" class="headerlink" title="NAMELIST🍓"></a><code>NAMELIST</code>🍓</h1><p><code>NAMELIST</code>是一种特殊的输入输出方法，可以把一组相关变量封装到一起，输入/输出变量时是需要在<code>read</code>/<code>write</code>的<code>nml</code>字段中设置需要使用哪一个 namelist 即可。其使用方法类似于变量，需要做声明：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">namelist</span> /nl_name/ var1,var2,...<br><span class="hljs-comment">! 使用namelist必须要对其取一个名字</span><br><span class="hljs-built_in">write</span>(*,<span class="hljs-keyword">nml</span>=nl_name) <span class="hljs-comment">! 输出nl_name这个 namelist</span><br></code></pre></div></td></tr></table></figure><p>输出 namelist 时不能带有格式，因为其格式在编译器中已经设置好了，由编译器决定，一般来说是：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">&amp;nl_name （&amp;符号 + namelist的名字）<br>A       =           1,  （输出变量的名称、等号、内容）<br>B       =           2,  （变量之间用逗号或者空格进行分隔）<br>C       =           3<br>/  （最后用除号结束）<br></code></pre></div></td></tr></table></figure><p>输入时也要按照类似的格式进行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">&amp;nl_name a=1 b=2 c=3 /<br></code></pre></div></td></tr></table></figure><p>输入时可以不输入所有的变量，也可以不按照顺序输入变量，甚至可以重复输入变量的值（以最后一次输入的值为准）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编程</category>
      
      <category>Fortran</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran语言学习——函数</title>
    <link href="/2021/09/13/fortran-function/"/>
    <url>/2021/09/13/fortran-function/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>程序中在不同地方常常需要重复使用某一个功能或者某一段程序代码，这个需求可以利用“函数”来实现。函数是“自定义函数”和“子程序”的统称。</p>          </div><h1 id="子程序🎃"><a href="#子程序🎃" class="headerlink" title="子程序🎃"></a>子程序🎃</h1><h2 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h2><p>子程序可以用来独立出某一段需要重复使用的代码，供其他地方调用。通常使用关键字<code>CALL</code>来进行调用。通常采用以下的结构写子程序：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br>    ...<br>    ... <span class="hljs-comment">! 主程序代码</span><br>    <span class="hljs-keyword">call</span> sub1() <span class="hljs-comment">! 调用子程序1</span><br>    <span class="hljs-keyword">call</span> sub2() <span class="hljs-comment">! 调用子程序2</span><br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub1()<br>    ...<br>    ... <span class="hljs-comment">! 子程序1代码</span><br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">! return代表子程序的运行停止，类似于主程序的stop，可以省略</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub2()<br>    ...<br>    ... <span class="hljs-comment">! 子程序2代码</span><br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span><br></code></pre></div></td></tr></table></figure><p>子程序可以在任何地方被调用，甚至是自己调用自己，这就是所谓的<strong>递归</strong>。</p><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>变量对于一个程序来说尤为重要，在Fortran中，变量的使用相对于Python这样的新高级语言显得十分的麻烦，所以需要专门花时间讲清楚变量在子程序中的使用。</p><p>基本的结构可以按照以下的形式来进行操作：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br>    ...<br>    <span class="hljs-keyword">integer</span> :: a,b <span class="hljs-comment">! 主程序中作变量声明</span><br>    <span class="hljs-keyword">call</span> sub(a,b) <span class="hljs-comment">! 传递参数</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(first,second) <span class="hljs-comment">! 设置参数</span><br>    <span class="hljs-keyword">integer</span> :: first,second <span class="hljs-comment">! 子程序中作变量声明</span><br>    ... <span class="hljs-comment">! 子程序操作代码</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br></code></pre></div></td></tr></table></figure><p>可以看到这个用法和Python有着很大程度的不同，这是因为主程序与子程序之间传递参数的方式在不同的程序语言之间是不同的：Fortran中使用的是<em>传址调用</em>，C语言中使用<em>传值调用</em>，Python中使用的是混合方法，即对于可变对象使用传址调用，对不可变对象使用传值调用。</p><p>我们这里主要关注传址调用，意思是说经过传递的变量之间会使用同一处内存地址，所以我们可以利用传递在子程序中改变主程序的变量（<strong>这个改变在主程序中也会得到反应</strong>）。<span style='background: yellow;'>但是，值得注意的是，子程序和主程序中没有经过调用的变量之间一定是独立的，相互之间改变值是不会有影响的（除非是使用<em>全局变量</em>的形式）。</span></p><hr><h1 id="自定义函数🍉"><a href="#自定义函数🍉" class="headerlink" title="自定义函数🍉"></a>自定义函数🍉</h1><p>自定义函数和子程序大体上是相同的，除了以下两点：</p><ul><li>调用自定义函数前需要先声明</li><li>自定义函数执行后会返回一个值（这一点在子程序中是不一定的，<span calss="heimu">也许我们可以说，Python的函数结构是将这两者合二为一来使用了</span>）</li></ul><p>其主要的结构可以按照如下的形式来使用：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br>    <span class="hljs-keyword">real</span> :: a,b<br>    <span class="hljs-keyword">real</span>,<span class="hljs-keyword">external</span> func1 <span class="hljs-comment">! external是为了声明func1作为一个函数存在</span><br>    <span class="hljs-comment">! 意思是自定义函数要返回一个数值，我们将这个数值的类型声明为某种特殊的变量</span><br>    ... func1(a,b) ... <span class="hljs-comment">! 调用函数的代码部分</span><br>    ...<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> func1(first,second)<br>    <span class="hljs-keyword">real</span> :: first,second<br>    <span class="hljs-keyword">real</span> :: func1_result <span class="hljs-comment">! 这里是声明函数返回的数值的类型</span><br>    ... <span class="hljs-comment">! 函数的内部代码</span><br>    ...<br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span> <br></code></pre></div></td></tr></table></figure><div class="note note-success">            <p>上述过程中已经包括了如何在函数中使用变量。同时还有一个不成文的“规定”：“传递给函数的变量，我们只需要使用或者读取它的数值就好了，不要去改变它的数据。”根据数学上函数的定义，我们传入的是“自变量”，输出的是“应变量”，自变量自然不可以随便改写值的大小。</p>          </div><hr><h1 id="全局变量（COMMON）🍎"><a href="#全局变量（COMMON）🍎" class="headerlink" title="全局变量（COMMON）🍎"></a>全局变量（COMMON）🍎</h1><p><code>COMMON</code>是Fortran 77中使用“全局变量”的办法，用来定义一块共享的内存空间，其一般的结构如下：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">integer</span> a,b,c,d,e,f<br>    <span class="hljs-keyword">common</span> a,b,c,d,e,f <span class="hljs-comment">! 将变量放入common空间中，以下类似</span><br>    <span class="hljs-keyword">common</span> /group1/ first <span class="hljs-comment">! 对全局变量进行分组 分组1</span><br>    <span class="hljs-keyword">common</span> /group2/ second <span class="hljs-comment">! 对全局变量进行分组 分组2</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub()<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">integer</span> n1,n2,n3,n4,n5,n6<br>    <span class="hljs-keyword">common</span> n1,n2,n3,n4,n5,n6 <span class="hljs-comment">! 按照顺序分别共享a,b,c,d,e,f的内存地址</span><br>    <span class="hljs-comment">! 这样会有类似于只需要取用第六个变量f的地址，但仍然要在f前设置五个用不着的变量来占位</span><br>    <span class="hljs-comment">! 为了避免上述问题，可以对全局变量进行分组</span><br>    <span class="hljs-keyword">common</span> /group1/ num1 <span class="hljs-comment">! 取用group1中的first进行共享地址</span><br>    <span class="hljs-keyword">common</span> /group2/ num2 <span class="hljs-comment">! 取用group2中的second进行共享地址</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br><br><span class="hljs-keyword">block</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">name</span> <span class="hljs-comment">! name可以省略</span><br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span> <span class="hljs-comment">! 最好不要省略这一行</span><br>    <span class="hljs-keyword">integer</span> ... <span class="hljs-comment">! 声明变量</span><br>    <span class="hljs-keyword">real</span> ...<br><br>    <span class="hljs-keyword">common</span> ... <span class="hljs-comment">! 将变量放入common空间中，并进行赋值</span><br>    <span class="hljs-keyword">common</span> /group1/ ...<br><br>    <span class="hljs-keyword">data</span> var1,var2... <span class="hljs-comment">! 赋予初始值</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">block</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">name</span> <span class="hljs-comment">! 和此前一样，可以只写end或者end block data</span><br></code></pre></div></td></tr></table></figure><div class="note note-danger">            <p>需要注意的是：COMMON变量不能在主程序或者子程序中使用<code>DATA</code>来进行初始值的赋予，而是在<code>BLOCK DATA</code>中使用<code>DATA</code>命令来进行。另外全局变量不能声明常量，因此不能出现<code>PARAMETER</code>命令。</p><p>当然，任何时候都不要忘记变量的类型相互之间是否匹配！！！</p>          </div><hr><h1 id="函数中的变量🍑"><a href="#函数中的变量🍑" class="headerlink" title="函数中的变量🍑"></a>函数中的变量🍑</h1><p>这里的函数包括了自定义函数和子程序两种类似的结构，这一节主要是参数传递过程中的注意事项和部分特殊的参数传递过程。所谓注意事项，最重要的一点无非是要注意“<span style="background: yellow;">参数类型是否正确</span>”</p><h2 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h2><p><a href="https://www.tabirstrees.top/2021/09/03/fortran-array/">数组</a>中我们提到，数组类型的变量在内存中占用的是一整块连续空间，但在参数的传递时，实际传递时数组中某一个参数的内存地址，因此我们会有一些比较特殊的用法：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> ex0816<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">5</span>) = (/ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> /)<br>  <span class="hljs-keyword">call</span> ShowOne(a)   <span class="hljs-comment">! 传入a, 也就是传入数组a第1个元素的内存地址</span><br>  <span class="hljs-keyword">call</span> ShowArray5(a)  <br>  <span class="hljs-keyword">call</span> ShowArray3(a)  <br>  <span class="hljs-keyword">call</span> ShowArray3( a(<span class="hljs-number">2</span>) ) <span class="hljs-comment">! 传入a(2), 也就是传入数组a第2个元素的内存地址</span><br>  <span class="hljs-keyword">call</span> ShowArray2X2(a)  <br>  <span class="hljs-keyword">stop</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> ShowOne(num)<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: num(<span class="hljs-number">1</span>) <span class="hljs-comment">! 只取出参数地址中的第1个数字</span><br>  <span class="hljs-built_in">write</span>(*,*) num<br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> ShowArray5(num)<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: num(<span class="hljs-number">5</span>) <span class="hljs-comment">! 取出参数地址中的前5个数字,当成数组来使用</span><br>  <span class="hljs-built_in">write</span>(*,*) num<br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> ShowArray3(num)<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: num(<span class="hljs-number">3</span>) <span class="hljs-comment">! 取出参数地址中的前3个数字,当成数组来使用</span><br>  <span class="hljs-built_in">write</span>(*,*) num<br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> ShowArray2X2(num)<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: num(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">! 取出参数地址中的前4个数字,当成2X2数组来使用</span><br>  <span class="hljs-built_in">write</span>(*,*) num(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), num(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">1<br>1           2           3           4           5<br>1           2           3<br>2           3           4<br>2           4<br></code></pre></div></td></tr></table></figure><p>以上，自行体会。</p><p>另外，我们也有提到，数组变量在声明时需要指定其大小（使用一个常数），但是在函数中，如果数组是用来接收的参数时可以用变量来进行指定，甚至是不指定（用通配符<code>*</code>代替）。<span class="heimu">实际上，我们用来传递的变量早在数组进入子程序之前就已经分配好了内存空间了，因为使用<em>传址调用</em>时，在主程序中我们也需要定义一个使用同一个内存地址的变量。在函数中赋值数组的大小只是方便检查，不会去重新分配内存，所以可以省略。</span>同样的道理，对于任何需要指定大小或者长度的变量都有类似的情况存在。</p><h2 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h2><p>函数中的变量只能在函数中存在（与主程序是独立的，且不包含所输入的参数），因此，通常情况下他们所能够存在的时间只有在这个子程序被执行的这一段时间。子程序结束后，他们就“死亡”了，所保存的数据也会跟着被释放掉。</p><p>在声明中加入<code>save</code>命令可以拯救这些变量、增加变量的生存周期、保留数据：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span>,<span class="hljs-keyword">save</span> :: <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><p>函数的参数在传递时，除了可以出传送数字、字符等等数据外，还可以直接传递一个函数名称。这里涉及到前面提到的某个关键字<code>external</code>以及一个新的关键字<code>intrinsic</code>。只有在函数的声明中出现这两个关键字时才能将函数当作参数进行传递：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span>,<span class="hljs-keyword">external</span> :: func <span class="hljs-comment">! 声明一个外接（自定义）函数，一般情况下external可以省略</span><br>    <span class="hljs-keyword">real</span>,<span class="hljs-keyword">intrinsic</span> :: <span class="hljs-built_in">sin</span> <span class="hljs-comment">! 声明一个Fortran内置的函数，一般情况下这一行都可以省略</span><br>    <span class="hljs-keyword">external</span> :: sub <span class="hljs-comment">! 声明一个子程序，一般情况可省略</span><br><br>    <span class="hljs-keyword">call</span> Execfunc(func) <span class="hljs-comment">! 传递一个external函数作为参数</span><br>    <span class="hljs-keyword">call</span> Execfunc(<span class="hljs-built_in">sin</span>) <span class="hljs-comment">! 传递一个intrinsic函数作为参数</span><br>    <span class="hljs-keyword">call</span> Execfunc(sub) <span class="hljs-comment">! 传递一个子程序</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> Execfunc(f)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span>,<span class="hljs-keyword">external</span> :: f <span class="hljs-comment">! 声明f是一个函数(或子程序)</span><br>    ...<br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(var1)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> :: var1 <span class="hljs-comment">! 正常的参数</span><br>    ...<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> func(var2)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> :: var2 <span class="hljs-comment">! 正常的参数</span><br>    ...<br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><hr><h1 id="参数的特殊使用方法🍇"><a href="#参数的特殊使用方法🍇" class="headerlink" title="参数的特殊使用方法🍇"></a>参数的特殊使用方法🍇</h1><h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><p>某些时候，我们希望我们传递进来的参数可以只读，它的值不能在函数中改变；或者某个参数一定要在函数中被重新设置数值。这种时候我们可以设置参数的属性，如下：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(var1,var2)<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span>,<span class="hljs-keyword">intent</span>(<span class="hljs-keyword">in</span>) :: var1 <span class="hljs-comment">! 声明（指定）var1参数是只读的</span><br>    <span class="hljs-keyword">real</span>,<span class="hljs-keyword">intent</span>(<span class="hljs-keyword">out</span>) :: var2 <span class="hljs-comment">! 声明var2参数是需要被重写的</span><br>    ...<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><h2 id="函数的使用接口（INTERFACE）"><a href="#函数的使用接口（INTERFACE）" class="headerlink" title="函数的使用接口（INTERFACE）"></a>函数的使用接口（INTERFACE）</h2><p>INTERFACE是主程序中的一段程序模块，用来清除说明函数所要调用以及返回的参数类型的“使用接口”。一般情况是不需要使用的，但在以下几种情况中是必要的：</p><ul><li>函数返回值是数组时</li><li>指定参数位置来传递参数时</li><li>所调用的函数参数数目不固定时</li><li>输入指标参数时</li><li>函数返回值是指针时</li></ul><p>之后会陆续讲到这几种情况的具体内容，先来看看你<code>INTERFACE</code>模块的基本结构：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">Interface</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span></span> func_name<br>        <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>        <span class="hljs-keyword">real</span> :: ...<br>        <span class="hljs-keyword">integer</span> :: ... <span class="hljs-comment">! 该处只能说明参数和返回值的类型</span><br>    <span class="hljs-keyword">end</span> [<span class="hljs-function"><span class="hljs-keyword">function</span></span> [func_name]]<br><br>    <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub_name<br>        <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>        <span class="hljs-keyword">integer</span> :: ... <span class="hljs-comment">! 说明参数类型</span><br>    <span class="hljs-keyword">end</span> [<span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> [sub_name]]<br><span class="hljs-keyword">end</span> [<span class="hljs-keyword">interface</span>]<br></code></pre></div></td></tr></table></figure><p>使用函数的“使用接口”是一件很麻烦的事情，如果需要使用的函数很多，整个代码看起来非常烦杂。此外你需要在每一个你会使用到相关函数（涉及到以上五种情况）的子程序或者主程序中写清楚该函数的<code>interface</code>才可以。下一节将会介绍module的使用，其可以较少这个麻烦。</p><h2 id="不定个数的参数传递"><a href="#不定个数的参数传递" class="headerlink" title="不定个数的参数传递"></a>不定个数的参数传递</h2><p>一般来说，函数参数的个数都是由固定数目的，但在Fortran 90中可以使用<code>OPTIONAL</code>命令使某些参数变成可以“省略”的。</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span>,<span class="hljs-keyword">optional</span> :: var<br><span class="hljs-comment">! 在子程序（函数）以及主程序的interface模块中使用</span><br><span class="hljs-comment">! optional命令进行声明表示参数var可以省略不传入</span><br></code></pre></div></td></tr></table></figure><h2 id="改变参数传递位置的方法"><a href="#改变参数传递位置的方法" class="headerlink" title="改变参数传递位置的方法"></a>改变参数传递位置的方法</h2><p>这一点类似Python，当你按照变量的名称进行传递参数时，是可以不按照相应位置进行传入的：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub(var1,var2,var3)<br>    ...<br>    ...<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">! 在调用该子程序时,按照变量名称传递参数</span><br><span class="hljs-keyword">call</span> sub(var3=<span class="hljs-number">3</span>,var2=<span class="hljs-number">2</span>,var1=<span class="hljs-number">1</span>)<br><span class="hljs-comment">! 其等价于：</span><br><span class="hljs-keyword">call</span> sub(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><div class="note note-seccess">            <p>也许有时候我们需要设置函数参数的默认值，在Fortran中似乎没有什么好用的命令，但是通过在子程序中设置<code>if</code>结构依然可以做到相关的要求。即：做一个有无输入的逻辑判断，没有外界输入时就程序内部赋予一个默认值。</p>          </div><hr><h1 id="特殊的函数类型🍌"><a href="#特殊的函数类型🍌" class="headerlink" title="特殊的函数类型🍌"></a>特殊的函数类型🍌</h1><div class="note note-primary">            <p>Fortran 90中，除了一般使用的正常函数之外，还可以特别指定成<code>RECURSIVE</code>、<code>PURE</code>、<code>ELEMENTAL</code>三种类型之一。<code>RECURSIVE</code>是让函数自己调用自己，也就是“递归”；后两者是用来做并行处理以及设置数组时使用的。</p>          </div><h2 id="递归（RECURSIVE）"><a href="#递归（RECURSIVE）" class="headerlink" title="递归（RECURSIVE）"></a>递归（<code>RECURSIVE</code>）</h2><p>能够递归的函数需要有一个必要条件，<span style='background: yellow;'>递归函数每次被调用执行时，函数中所声明的局部变量（非传递进来的参数或者没有做<code>save</code>的变量）都会使用不同的内存地址</span>。简单的说就是每次调用函数时变量都是独立存在的。</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">recursive</span> <span class="hljs-keyword">integer</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> func(var) result(ans)<br><span class="hljs-comment">! 用recursive表示该函数可以递归</span><br><span class="hljs-comment">! result（ans）表示该函数的返回值用ans变量代替原来的fact</span><br><span class="hljs-comment">! result对于每一个自定义函数都可以使用，但是递归函数必须要有！</span><br></code></pre></div></td></tr></table></figure><p>在不设置<code>recursive</code>的时候，也可以用一种“间接递归”的方法来完成递归，也就是现在函数中调用另外一个函数，再在这另一个函数中调用自己，但是这种方法在某些编译器环境下会出现错误，因为它会把每次调用函数的局部变量放在同一个内存地址。</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>Fortran 90可以定义某些函数只能在特定的函数中被调用，其基本结构为：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main \ <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub \ <span class="hljs-function"><span class="hljs-keyword">function</span></span> func<br>    ...<br>    ...<br>    <span class="hljs-keyword">contains</span> <span class="hljs-comment">! contains后面开始写局部函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> localsub <span class="hljs-comment">! 这里的函数只能在包含它的函数中被调用</span><br>            ...<br>            ...<br>        <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span><br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span></span> localfunc <span class="hljs-comment">! 同样只能在包含它的函数中被调用</span><br>            ...<br>            ...<br>        <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><h2 id="PURE函数"><a href="#PURE函数" class="headerlink" title="PURE函数"></a><code>PURE</code>函数</h2><p>在函数声明前加上<code>pure</code>代码即可，但是使用pure函数有诸多限制：</p><ul><li>pure函数的参数必须都是只读<code>intent(in)</code>属性；</li><li>pure子程序的每一个参数都要赋予属性；</li><li>pure函数不能使用<code>save</code>；</li><li>pure函数中所包含的内部函数也必须全都是pure函数</li><li>pure函数中不能使用<code>stop</code> \ <code>print</code>及跟输入输出相关的命令（<code>read</code> \ <code>write</code> \ <code>open</code> \ <code>close</code> \ <code>backspace</code> \ <code>endfile</code> \ <code>rewind</code> \ <code>inquire</code>等等）</li><li>pure函数只能读取不能改变全部变量的值</li></ul><p>上面的这些限制，全部都是为防止在并行计算时出现一些奇怪的结果。比如说，同时执行A、B函数，两者都有在屏幕上输出信息的功能，这个时候就可能出现两个函数的结果混合在一起的错误结果。</p><h2 id="ELEMENTAL函数"><a href="#ELEMENTAL函数" class="headerlink" title="ELEMENTAL函数"></a><code>ELEMENTAL</code>函数</h2><p>使用方法和pure函数相同，也可以用来做并行计算，限制也与pure函数相同，除此之外它还多了一个功能，对数组进行设置（同时也多了一个限制：<span style='background: yellow;'>参数不能是数组</span>。），下面举个栗子🌰：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> a(<span class="hljs-number">10</span>)<br>a=func(a)<br><span class="hljs-comment">! 如果func是一个elemental函数，这段程序与下面的循环等价：</span><br><span class="hljs-keyword">do</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span><br>    a(i) = func(a(i))<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br></code></pre></div></td></tr></table></figure><hr><h1 id="MODULE🍒"><a href="#MODULE🍒" class="headerlink" title="MODULE🍒"></a>MODULE🍒</h1><h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p><code>module</code>可以用来封装程序模块，通常用来把程序中具备相关功能的函数和变量封装到一起。其语法如下：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">module</span> module_name <span class="hljs-comment">! 对模块的定义必须放到最前面</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span> [<span class="hljs-keyword">module</span> [module_name]]<br><br><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br>    <span class="hljs-keyword">use</span> module_name <span class="hljs-comment">! 使用前面定义的模块</span><br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub<br>    <span class="hljs-keyword">use</span> module_name<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>上面的结构是在同一个文件中使用module模块，一般来说我们都是在一个代码文件中定义好所需要使用的函数和子程序，再在另一个文件中使用，这就类似于Python中的<code>import</code>模块的使用，这会在后面讲到。</p><h2 id="MODULE中的函数"><a href="#MODULE中的函数" class="headerlink" title="MODULE中的函数"></a>MODULE中的函数</h2><p>在MODULE中编写函数，其结构如下：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">module</span> module_name<br>    ... <span class="hljs-comment">! 先写声明相关程序代码</span><br>    ...<br><span class="hljs-keyword">contains</span> <span class="hljs-comment">! contains 后开始写函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub_name<br>        ...<br>        ...<br>    <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> [sub_name] <span class="hljs-comment">! subroutine 不能省</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span></span> func_name<br>        ...<br>        ...<br>    <span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> [func_name] <span class="hljs-comment">! function 不能省</span><br><span class="hljs-keyword">end</span> [<span class="hljs-keyword">module</span>]<br></code></pre></div></td></tr></table></figure><p>还有一个比较方便的一点是：在同一个MODULE中，函数可以直接使用其他地方所声明的变量：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">module</span> tool<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">integer</span> :: a <span class="hljs-comment">! 此处声明了a变量</span><br>    ...<br>    ...<br><span class="hljs-keyword">contains</span><br>    <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> add()<br>        <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>        a = a+<span class="hljs-number">1</span><br>    ...<br>    ......<br></code></pre></div></td></tr></table></figure><h2 id="一些不太常见的功能"><a href="#一些不太常见的功能" class="headerlink" title="一些不太常见的功能"></a>一些不太常见的功能</h2><h3 id="ENTRY"><a href="#ENTRY" class="headerlink" title="ENTRY"></a><code>ENTRY</code></h3><p><code>ENTRY</code>：为函数提供一个新的入口，举个栗子🌰:</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>    <span class="hljs-keyword">call</span> sub<br>    <span class="hljs-keyword">call</span> mid<br><br>    <span class="hljs-keyword">stop</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub()<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><br>    <span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;hello.&quot;</span><br>    <span class="hljs-built_in">entry</span> mid() <span class="hljs-comment">! 提供另一个入口</span><br>    <span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;Good morning!&quot;</span><br><br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>其输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">hello.<br>Good morning!<br>Good morning!<br></code></pre></div></td></tr></table></figure><h3 id="RETURN"><a href="#RETURN" class="headerlink" title="RETURN"></a><code>RETURN</code></h3><p>特殊的<code>RETURN</code>：提供额外的折返点，举个栗子🌰：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> main<br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> num<br><br>    <span class="hljs-built_in">write</span>(*,*)<span class="hljs-string">&quot;please input a number：&quot;</span><br>    read(*,*)num<br>    <span class="hljs-keyword">call</span> sub_return(num,*<span class="hljs-number">1</span>,*<span class="hljs-number">2</span>) <span class="hljs-comment">! 具体的折返点输入形式：‘*’ + 行代码</span><br>    <span class="hljs-built_in">write</span>(*,*)<span class="hljs-string">&quot;Default return&quot;</span><br>    <span class="hljs-keyword">stop</span><br>    <span class="hljs-number">1</span> <span class="hljs-built_in">write</span>(*,*)<span class="hljs-string">&quot;Return 1&quot;</span><br>    <span class="hljs-keyword">stop</span><br>    <span class="hljs-number">2</span> <span class="hljs-built_in">write</span>(*,*)<span class="hljs-string">&quot;Return 2&quot;</span><br>    <span class="hljs-keyword">stop</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> sub_return(num,*,*) <span class="hljs-comment">! 后面的‘*’号表示输入的折返点参数，几个‘*’表示几个折返点</span><br>    <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">real</span> num<br><br>    <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">write</span>(*,*)<span class="hljs-string">&quot;&gt;=0&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">! 返回到默认的折返点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; -<span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;&lt;-1&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-comment">! 返回到特定的第一个折返点（行代码为1的位置）</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;-1&lt;=num&lt;0&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-comment">! 返回到特定的第二个折返点（行代码为2的位置）</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span><br></code></pre></div></td></tr></table></figure><p>分别运行三次，输入不同的值，其运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">&gt;&gt;&gt;<br> please input a number：<br>2<br> &gt;=0<br> Default return<br>&gt;&gt;&gt;<br> please input a number：<br>-3<br> &lt;-1<br> Return 1<br>&gt;&gt;&gt;<br> please input a number：<br>-0.5<br> -1&lt;=num&lt;0<br> Return 2<br></code></pre></div></td></tr></table></figure><hr><h1 id="使用多个文件🥝"><a href="#使用多个文件🥝" class="headerlink" title="使用多个文件🥝"></a>使用多个文件🥝</h1><div class="note note-primary">            <p>通常情况下，我们会把具有相关功能的函数编写到不同的文件中，这样做有以下几个好处：</p><ul><li>独立文件中的函数，可以拿给其他的程序使用；</li><li>减少单个程序中的代码（此时与<code>MODULE</code>类似）；</li><li>可以加快编译速度，修改其中一个文件时，编译器只需要重新编译这一个文件就好了（这一点要和编译器的使用结合起来）。</li></ul>          </div><h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a><code>INCLUDE</code></h2><p><code>INCLUDE</code>命令可以在程序代码中插入另一个文件中的内容。现在假如我有两个文件：“mian.f90”以及“sub.f90”，后者中含有前者所需要使用的子程序代码，我们只需要在前者的代码中（<strong>任何位置</strong>）加入：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;sub.f90&#x27;</span><br></code></pre></div></td></tr></table></figure><p>这样结果就相当于两个文件中的代码是写在同一个文件中的。</p><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><p>具有特殊功能的一组函数，可以编译成”<em>.LIB”来给其他人使用。这样的文件经过编译，没有办法读出里面的初始程序代码，但可以通过`use </em>.LIB`的方法来使用其中的各种函数（与Python的函数库类似）。</p><hr><h1 id="写在最后🍈"><a href="#写在最后🍈" class="headerlink" title="写在最后🍈"></a>写在最后🍈</h1><div class="note note-seccess">            <p>五百多行，四天时间，这大概是我写的最多的一次了</p><p><img src="https://file.tabirstrees.top/blogfile/EMO-wodingdezhu.jpg" alt="我顶得住"></p>          </div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编程</category>
      
      <category>Fortran</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Fortran</tag>
      
      <tag>函数语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地磁场形成原因文献阅读报告</title>
    <link href="/2021/09/11/geomagnetic-field-fromation/"/>
    <url>/2021/09/11/geomagnetic-field-fromation/</url>
    
    <content type="html"><![CDATA[<p>地球磁场的成因曾经被科学大师爱因斯坦列为理论物理学的三大未解决的难题之一也是迄今未得到合理解释的地球科学的理论难题<sup><a href="#fn_1" id="reffn_1">1</a></sup>。磁性是地球的基本属性之一，人类早就认识了地球的磁性。自从人类认识了地球的磁性以后就希望能探秘地球磁性的形成原因。为解释地磁的成因人们提出了多种假说至今仍在继续探索和研究。一般通过应用经典电磁理论定性地分析地轴参考系中地球上电荷间洛仑兹力的特点和电荷的运动规律并据此阐述地球磁场的形成机理同时说明地球不仅具有自身的磁场而且具有自身的电场，地球电场和地球磁场是不可分割的统一体<sup><a href="#fn_2" id="reffn_2">2</a></sup>。目前普遍接受的是地磁场的发电机理论，即地球电场和地球磁场源自于地球的自转和地球上正负电荷的非对等分布。地球自转带动地球上的静电荷(相对于在不停地自转的地球静止的电荷)相对于地轴做匀速圆周运动就产生磁场。在地轴参考系中（即选地轴作为参考系）视地球为真空中的理想均质固体导体球分析地球电场和地球磁场的形成机理。地球磁场按场源电荷的运动形式分类可分为主磁场和偏磁场按场源电荷的汇集点在地球上所处的位置分类可分为中心磁场和极地磁场<sup><a href="#fn_3" id="reffn_3">3</a></sup>。地球上任意一点的磁场都是由该点的主磁场和偏磁场叠加而成主磁场又是由中心磁场和极地磁场叠加而成<sup><a href="#fn_3" id="reffn_3">3</a></sup>。该理论在观测、实验、理论和研究上得到较多证实也能较好的解释地磁反转现象地球发电机理论认为地球内核有流动的熔融态铁形成导电的“汪洋”，导电流体依据电流的磁效应必然会产生磁场，因此这便是地磁场的由来。包括地球在内的大部分太阳系行星以及包括太阳在内的所有恒星都会因导电流体的运动而产生磁场<sup><a href="#fn_4" id="reffn_4">4</a></sup>。</p><p><img src="https://file.tabirstrees.top/blogfile/dicixingcheng/%E7%A3%81%E5%9C%BA%E5%9B%BE.gif" alt="磁场作图"></p><p>地球的磁场源于半径为3400公里（地球半径为6370公里）、由铁合金组成的地核。地核分为半径为1220公里的固态内核和液态外核。内核（温度约为6000K，573°C，10340F））的热量向核幔边界（温度约为3800K，353°C，6380F））传导时会推动液态外核的流动。内核的高温来自于行星分异期间较重物质下沉时释放的引力势能以及核内放射性元素衰变时释放的热能。外核流动的形状与地球的自转及固态的内核有关。地球产生磁场的原理称为发电机理论。电流及其所产生的磁场之间存在一种反馈作用：电流回路产生磁场（安培定律）磁场的变化产生电场（法拉第定律）磁场和电场又反过来对电流中的电荷施力（洛伦兹力）。综合起来可用一条称为“磁感应方程”的偏微分方程来描述如此形成的磁场：</p><script type="math/tex; mode=display">\frac{\partial \mathbf{B}}{\partial t}=\eta \nabla^{2} \mathbf{B}+\nabla \times(\mathbf{u} \times \mathbf{B})</script><p>其中u为流体的速度B为磁场η=1/σμ为磁扩散率（与电导率σ和磁导率μ之积成反比）。∂B/∂t是磁场的时间导数，∇2是拉普拉斯算子，∇×是旋度算子<sup><a href="#fn_5,6" id="reffn_5,6">5,6</a></sup>。</p><p><img src="https://file.tabirstrees.top/blogfile/dicixingcheng/%E5%9C%B0%E7%90%83%E7%BB%93%E6%9E%84.jpg" alt="地球圈层"></p><p>磁感应方程右边的第一项描述的是扩散。在静止不动的流体当中磁场会减弱聚集的磁场也会扩散开来。一旦地球发电机在某天停止运动地磁场的偶极分量就会在几万年内慢慢消失。在一个完美电导体（σ=∞）里不可能发生扩散。根据楞次定律磁场的任何变动会产生抵抗这一改变的电流因此进出一个给定体积流体的磁通量不会改变。流体在移动时磁场会与其一同移动。这一现象称为“磁冻结定理”。就算流体不是完美电导体其流动时也会拉长磁场线并产生新的磁场。若不是因为磁场在加强时会抵抗流体的运动这一过程会无止境地产生新磁场。浮力所致的对流使得外核流体可以持续运动。在地球内部越往深处温度越高。越高温温度越高。越高温的流体浮力越大。另外，所谓的“成分对流”现象有加强浮力的作用：当地核冷却时，其中一些熔融铁会凝固并沉积在内核表面，流体中留下较轻的元素，因此密度降低。地球自转所产生的科里奥利效应会使流体的运动形成南北轴向的卷状物。发电机可以加强磁场，但整个过程最开始的时候需有初始磁场。地球的初始磁场可能来自地球以外：地球的初始磁场可能来自地球以外：太阳在其形成初期曾经经历过一个金牛T星阶段，此时的太阳风所致磁场可能比今天强几个数量级。但是，一大部分来自太阳的磁场可能会被地幔阻挡。初始磁场也有可能来自核幔边界上的化学反应界上的化学反应，或来自导热性和导电性的变化。根据计算，地球外核的平均磁场强度为25高斯，是地表强度的50倍<sup><a href="#fn_7" id="reffn_7">7</a></sup>。</p><p><img src="https://file.tabirstrees.top/blogfile/dicixingcheng/%E5%9C%B0%E7%90%83%E7%A3%81%E5%B1%82%E7%9A%84%E5%BD%A2%E6%88%90.gif" alt="太阳风作用下地磁层的形成"></p><p>但是，有研究指出：地球的外核不能产生稳定的偶极磁场，发电机理论对偶极磁场是无效的<sup><a href="#fn_7" id="reffn_7">7</a></sup>。首先从磁源深度的研究结果来看偶极磁场的磁源已位于固态内核中。若这一结论能确认是正确的，偶极磁场肯定不是发电机效应产生的。由于我们对地球内部的了解太少这一结论需留有余地。为此我们又从外核流体运动的可能形态探讨发电机效应产生偶极磁场的可能发现在外核流体中找不到能激发稳定偶极磁场的流场。此外又对外核流体运动的状态进行了推测发现外核中不存在引起较大区域流速变化的动力源外核流体的运动应相对平稳的绕地轴旋转这一点不利于发电机效应的产生。这几面都说明地球的偶极磁场不是或很难是发电机效应产生的。由于地球偶极磁场占地球磁场的是地球磁场最主要、最基本的部分，地磁发电机理论的主导地位应受到质疑。将地磁研究的希望完全寄托于地磁发电机理论是需要斟酌的。</p><p>另外俞光明还探究了初始弱外场的成因<sup><a href="#fn_4" id="reffn_4">4</a></sup>。初始磁场的产生与地球的起源有着密切的关系它是地球起源时期形成的物理特性的痕迹标志。在原始的行星星云中由于没有足够的能量湍流和涡流无法得以长久地维持由于引力的不稳定。原始的行星星云瓦解着一系列大的气休球(原行星)。从原行星到地球的形成大致经历四个阶段即原行星阶段、自引力收缩阶段、地球固化和地核‘液化’阶段、及大规模对流运动的出现、地球内部圈层的分化和差速自转的稳定阶段。上述各阶段的磁场特征都有较大差异，第一阶段，维系地球磁场的机制是在原始星云磁场作用下的湍流运动和行星尺度的“气体”发电机机制，它们使原始磁场逐渐增强并达到相对稳定。第二阶段，原始磁场可用“固核”发电机机制予以维系，由于固核的存在气体的运动受到一定的限制，因而磁场强度相对于前一阶段逐渐减小。第三阶段，地球固化使湍流磁场效应和涡流运动行星尺度气休发电机机制均消失地球磁场依靠物质的磁化作用得以保存。由于地球内部温度升高地球内部出现了消磁效应，从内到外磁性逐渐开始消失，原始磁场强度迅速减小，磁性仅保留在地球的壳层与此同时。地球内部温度的增加使地核“液化”，微弱的差异自转和内部对流的萌发驱动了最初的地磁发电机。第四阶段,地球内部强烈的对流运动和差速自转启动了地磁发电机从而维系和增强了地球的基本磁场。</p><div class="note note-info">            <p>参考文献<br><sup><a href="#fn_1" id="reffn_1">1</a></sup>张世红,李海燕.地磁学、古地磁学和环境磁学的研究新进展——第32届国际地质大会学科总结和评述[J].现代地质,2004(04):415-422.<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>黄金钟.论地球磁场的成因和自反转机制:中国科协2000年学术年会,2000[C].<br><sup><a href="#fn_3" id="reffn_3">3</a></sup>邹润莉.地球电场与地球磁场的形成机理[J].地球物理学进展,2008,23(4):1071-1084.<br><sup><a href="#fn_4" id="reffn_4">4</a></sup>喻光明.地磁场起源机理的探讨:中国地球物理学会1990年度综合学术讨论会,武汉,1990[C].<br><sup><a href="#fn_5" id="reffn_5">5</a></sup>WeissN.Dynamosinplanets,starsandgalaxies[J].Astronomy&amp;Geophysics:TheJournaloftheRoyalAstronomicalSociety,2002,43(3):3-9.<br><sup><a href="#fn_6" id="reffn_6">6</a></sup>董超,张怀,石耀霖.地磁场发电机数值模拟综述[J].中国科学院大学学报,<br>2019,36(02):145-154.<br><sup><a href="#fn_7" id="reffn_7">7</a></sup>李安生,李国栋.对地磁发电机理论的反思与天体磁场研究展望[J].地球物理学进展,2010,25(3):809-816.</p>          </div>]]></content>
    
    
    <categories>
      
      <category>文献阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献阅读</tag>
      
      <tag>地磁场</tag>
      
      <tag>行星形成与演化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran语言学习——数组</title>
    <link href="/2021/09/03/fortran-array/"/>
    <url>/2021/09/03/fortran-array/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本使用🎃"><a href="#1-基本使用🎃" class="headerlink" title="1 基本使用🎃"></a>1 基本使用🎃</h1><h2 id="1-1-一维数组"><a href="#1-1-一维数组" class="headerlink" title="1.1 一维数组"></a>1.1 一维数组</h2><p>所谓数组，实际上是一种使用数据类型的方法，通常用于配合循环使用用以处理大量的数据。简单来说，数组可以一次性申明出一长串的相同数据类型的变量。</p><p>数组的声明方式如下：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran">Datatype    <span class="hljs-keyword">name</span> (<span class="hljs-built_in">size</span>) <br><br><span class="hljs-comment">! Datatype表示数组的类型,除了4种常用的类型(integer,real,complex,logical)以外,也可以用type自定义出新的类型</span><br><span class="hljs-comment">! name表示数组变量的名字</span><br><span class="hljs-comment">! size表示数组变量的大小</span><br></code></pre></div></td></tr></table></figure><p><em>注意: 在声明数组时,数组的大小只能使用常数来赋值, 包括直接填入数字或者使用声明为parameter的常数变量</em></p><p>数组所能够保存的数据大小由<code>size</code>决定, 对于<code>integer :: student(5)</code>这个数组来说, 可以保存5个整数, 取用这5个整数只需要用数组名加上括号内的索引值即可, 如:<code>student(1) = 89</code>的意思是将89赋予<code>student</code>这个数组变量的第一个元素. 数组的索引值不一定要使用常数, 也可以使用一般的变量. </p><div class="note note-danger">            <p>使用数组时超出范围是很危险的事情, 在程序编译过程中不会检查数组的使用是否超出了范围, 所以要充分的杜绝这种情况的发生. </p>          </div><p>下面演示如何使用type函数自定义数组类型:</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">Type</span> :: person<br>    <span class="hljs-keyword">real</span> :: height,weight<br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Type</span><br><br><span class="hljs-keyword">Type</span>(person) :: a(<span class="hljs-number">10</span>) <span class="hljs-comment">! 使用新定义的person变量做数组声明</span><br>......<br>......<br><br><span class="hljs-comment">! 同样在变量后加上&quot;%&quot;来使用person类型的相关属性</span><br>a(<span class="hljs-number">2</span>)%height = <span class="hljs-number">180.0</span><br>a(<span class="hljs-number">2</span>)%weight = <span class="hljs-number">70.0</span><br></code></pre></div></td></tr></table></figure><h2 id="1-2-二维数组与多维数组"><a href="#1-2-二维数组与多维数组" class="headerlink" title="1.2 二维数组与多维数组"></a>1.2 二维数组与多维数组</h2><p>很多时候涉及到数据的维度会多于一维, 在Fortran中声明数组大小的时候使用多个数字进行声明即可得到一个多维数组变量, 使用该变量则需要给出相应数量的索引值. 以二维数组举例:</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> a(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">! 创建一个3×3的数组(类似于矩阵)</span><br>a(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) = <span class="hljs-number">3</span> <span class="hljs-comment">! 将3赋值到数组a的某一个元素</span><br></code></pre></div></td></tr></table></figure><div class="note note-danger">            <p>同样注意不能超出数值所声明的范围!另外, Fortran中最多可以声明7维的数组,使用维度越高的数组, 程序执行时读取数据的速度也就越慢, 这并不意味着不要在程序中使用多维数组, 而是说使用多维数组时需要格外小心. </p>          </div><h2 id="1-3-数组声明的奇怪用法"><a href="#1-3-数组声明的奇怪用法" class="headerlink" title="1.3 数组声明的奇怪用法"></a>1.3 数组声明的奇怪用法</h2><p>在Fortran的数组中, 没有特别声明时, 数组的索引总是从1开始的:<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>)<br><span class="hljs-comment">! 这个数组能使用的元素包括a(1),a(2),a(3),a(4),a(5)</span><br></code></pre></div></td></tr></table></figure></p><p>也可以使用一种奇怪的方法改变数组起始的索引值, 即在声明数组变量的大小时指定索引的范围:<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>:<span class="hljs-number">5</span>) <span class="hljs-comment">! a(1~5,0~5)是可以使用的元素</span><br><span class="hljs-keyword">integer</span> b(<span class="hljs-number">2</span>:<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>:<span class="hljs-number">3</span>) <span class="hljs-comment">! b(2~3,-1~3)是可以使用的元素</span><br></code></pre></div></td></tr></table></figure></p><hr><h1 id="2-数组内容的设置🎯"><a href="#2-数组内容的设置🎯" class="headerlink" title="2 数组内容的设置🎯"></a>2 数组内容的设置🎯</h1><h2 id="2-1-赋予初始值"><a href="#2-1-赋予初始值" class="headerlink" title="2.1 赋予初始值"></a>2.1 赋予初始值</h2><p>数组可以类似于一般变量利用<code>DATA</code>来设置数组的初始值:<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> a(<span class="hljs-number">5</span>),b(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">data</span>    a   /<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>/<br><span class="hljs-comment">! 这样做数组的初始值设置为:a(1)=1,a(2)=2,a(3)=3,a(4)=4,a(5)=5</span><br><span class="hljs-keyword">data</span>    b   /<span class="hljs-number">3</span>*<span class="hljs-number">5</span>/<br><span class="hljs-comment">! &quot;*&quot;表示重复, 以上就是3重复五遍, 将数组的初始值全部设置为3</span><br></code></pre></div></td></tr></table></figure></p><p>另外有一种带有”隐含式”循环的初始值赋予方式:<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> A(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">integer</span> I<br><span class="hljs-keyword">DATA</span>(A(I), I=<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)/<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>/<br><span class="hljs-comment">! 上面这行代码隐含着一个循环, I会从2增加到4, 并依照顺序取后面&quot;//&quot;中的数字, 也就是A(2)=2, A(3)=3, A(4)=4, A(5)和A(1)没有设置.</span><br></code></pre></div></td></tr></table></figure></p><div class="note note-primary">            <p>上述的隐含式循环实际上是Fortran语言的一个特色，你可以在程序中正常的使用：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-built_in">write</span>(*,*) (a(i),i=<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment">! 显示a(2),a(3),a(4)的值</span><br></code></pre></div></td></tr></table></figure><br>后面再多加一个数字，可以改变计数器的累加数值，默认情况下为1：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran">(A(I), I=<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<br><span class="hljs-comment">! 循环执行5次，分别执行到I=2，4，6，8，10</span><br></code></pre></div></td></tr></table></figure><br>当然，隐含式的循环同样支持嵌套使用：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">INTEGER</span> A(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">INTEGER</span> I,J<br><span class="hljs-keyword">DATA</span>((A(I,J), I=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>), J=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) /<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<br><span class="hljs-comment">! 其结果为A(1,1)=1, A(2,1)=2, A(1,2)=3, A(2,2)=4，括号内的循环会先执行</span><br></code></pre></div></td></tr></table></figure><br>Fortran 90中，DATA可以被省略：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">5</span>) = (/ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> /)<br><span class="hljs-comment">! 注意“/”与括号间不能留有空格</span><br><span class="hljs-comment">! 省略DATA时必须要给每一个元素都设置初始值，不能像有DATA时那样用隐含式循环只设置部分元素的初始值。</span><br></code></pre></div></td></tr></table></figure><p>Fortran 90的隐含式循环十分强大，它可以做到其他语言做不到的东西：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> ::Ｉ<br><span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">5</span>)=(/(I,I=<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)/)<br><span class="hljs-comment">! 其运行结果为a(n) = n, n=1,2,3,4,5</span><br></code></pre></div></td></tr></table></figure>          </div><h2 id="2-2-对整个数组的操作"><a href="#2-2-对整个数组的操作" class="headerlink" title="2.2 对整个数组的操作"></a>2.2 对整个数组的操作</h2><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">a=5</td><td style="text-align:center">a中所有元素全部赋值为5</td></tr><tr><td style="text-align:center">a=(/1, 2, 3/)</td><td style="text-align:center">a(1)=1, a(2)=2, a(3)=3</td></tr><tr><td style="text-align:center">a=b</td><td style="text-align:center">将a变成和b一样的数组，前提是a,b是维数、大小一样的数组</td></tr><tr><td style="text-align:center">a=b+c</td><td style="text-align:center">a, b, c是三个维数、大小一样的数组，a中某个位置的元素是b，c中相应位置的元素的和</td></tr><tr><td style="text-align:center">a=b-c</td><td style="text-align:center">类似上一条，只不过变成了b，c对应元素的差</td></tr><tr><td style="text-align:center">a=b*c</td><td style="text-align:center">类似，b，c的乘积</td></tr><tr><td style="text-align:center">a=b/c</td><td style="text-align:center">类似，b，c的商</td></tr><tr><td style="text-align:center">a=sin(b)</td><td style="text-align:center">a(i)=sin(b(i))，只要是内部的函数都可以这么用</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><p>上述方法都是对整个数组进行操作的，并且涉及到两个元素之间的操作都是对应元素之间进行的，可以结合相应的矩阵运算进行理解。</p><h2 id="2-3-对部分数组的操作"><a href="#2-3-对部分数组的操作" class="headerlink" title="2.3 对部分数组的操作"></a>2.3 对部分数组的操作</h2><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">a(3:5)=(/3,4,5/)</td><td style="text-align:center">a(3)=3, a(4)=4, a(5)=5</td></tr><tr><td style="text-align:center">a(1:5:2)=3</td><td style="text-align:center">a(1)=3, a(3)=3, a(5)=3</td></tr><tr><td style="text-align:center">a(3:)=5</td><td style="text-align:center">a(3)以及之后的所有元素赋值为5</td></tr><tr><td style="text-align:center">a(1:3)=b(4:6)</td><td style="text-align:center">类似于这种的要求左右数组元素个数相同</td></tr><tr><td style="text-align:center">a(:)=b(:,2)</td><td style="text-align:center">a(1)=b(1,2), a(2)=b(2,2)，以此类推</td></tr></tbody></table></div><p>以上相当于利用索引值对数组进行切片，然后赋值，都是比较基础的用法。</p><h2 id="2-4-WHERE"><a href="#2-4-WHERE" class="headerlink" title="2.4 WHERE"></a>2.4 WHERE</h2><p><code>WHERE</code>也是对部分数组的操作，但将上节中的由坐标索引变成了逻辑判断来去除我们需要使用的元素<span class='heimu'>有点像<code>if</code>结构</span>：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">where</span>(a&lt;<span class="hljs-number">3</span>)<br>    b = a<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">where</span><br><span class="hljs-comment">! 这里的where描述会把数组中数值小于3的元素找出来，并把这些元素的值设置给数组b同样位置的元素。</span><br><br><span class="hljs-comment">! 也可以省略‘end where&#x27;，写成：</span><br><span class="hljs-keyword">where</span> (a&lt;<span class="hljs-number">3</span>) b=a<br></code></pre></div></td></tr></table></figure></p><div class="note note-danger">            <p>注意：<code>where</code>是用来设置数组的值的，所以它的程序模块中必须出现与设置数组相关的命令，并且在他的整个程序模块中出现的数组的大小和维度必须是一样的。同时类似于<code>if...else if...</code>，你也可以使用<code>ELSEWHERE</code>来处理逻辑处理中的其他情况，同时where语句也是可以支持嵌套使用的，基本上和if语句大同小异。</p>          </div><h2 id="2-5-FORALL"><a href="#2-5-FORALL" class="headerlink" title="2.5 FORALL"></a>2.5 FORALL</h2><p>FORALL也可以看成是一种隐含式循环来使用数组的方法：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">integer</span> i<br><span class="hljs-keyword">forall</span> (i=<span class="hljs-number">1</span>:<span class="hljs-number">5</span>)<br>    a(i)=i<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">forall</span><br><span class="hljs-comment">! a(1)=1, a(2)=2, a(3)=3, a(4)=4, a(5)=5</span><br><span class="hljs-comment">! 其详细语法为：</span><br><span class="hljs-keyword">forall</span> (triplet1[, triplet2[, triplet3[, ...]]], mask)<br>    ......<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">forall</span><br><span class="hljs-comment">! tripletn指代数组的坐标索引范围，FORALL中可以赋值好几个triplet，这主要取决于数组的维度。</span><br><span class="hljs-comment">! mask指代条件判断语句，类似于if语句</span><br><span class="hljs-comment">! 下面举个例子：</span><br><span class="hljs-keyword">integer</span> :: a(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)<br><span class="hljs-keyword">forall</span> (I=<span class="hljs-number">2</span>:<span class="hljs-number">10</span>:<span class="hljs-number">2</span>,J=<span class="hljs-number">1</span>:<span class="hljs-number">5</span>，a(I,J)&lt;<span class="hljs-number">10</span>) <span class="hljs-comment">! 二维数组，只处理数组中范围内值小于10的元素</span><br>    a(I,J)=I+J<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">forall</span><br><span class="hljs-comment">! 和if语句与where语句的情况一样，&#x27;end forall&#x27;也是可以省略的：</span><br><span class="hljs-keyword">forall</span>(I=<span class="hljs-number">1</span>:<span class="hljs-number">5</span>,J=<span class="hljs-number">1</span>:<span class="hljs-number">5</span>,a(I,J)/=<span class="hljs-number">0</span>) a(I,J)=<span class="hljs-number">1</span>/a(I,J)<br></code></pre></div></td></tr></table></figure></p><h1 id="3-数组的保存规则💾"><a href="#3-数组的保存规则💾" class="headerlink" title="3 数组的保存规则💾"></a>3 数组的保存规则💾</h1><p>在Fortran中，数组数据的保存是按照一定规则的，我们可以根据这个规则优化代码，编写出效率较高的程序。</p><p>拿一个二维数组举例：</p><blockquote><p>A(1,1)=&gt;A(2,1)=&gt;A(3,1)=&gt;A(1,2)=&gt;A(2,2)=&gt;A(3,2)=&gt;A(1,3)=&gt;A(2,3)=&gt;A(3,3)</p></blockquote><p>简单来说，最左边的元素会被最先填进内存。在写代码时可以充分利用这一点来提升代码的运行速度，尽量连续的读取数据，避免CPU跳跃式地在内存中读取数据。</p><h1 id="4-可变大小的数组🦐"><a href="#4-可变大小的数组🦐" class="headerlink" title="4 可变大小的数组🦐"></a>4 可变大小的数组🦐</h1><p>在Fortran 90中，提供了一种可以在程序执行后根据实际需求改变数组大小的功能：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">integer</span> :: students<br><span class="hljs-keyword">integer</span> <span class="hljs-keyword">allocatable</span> :: a(:) <span class="hljs-comment">! 声明一个可变大小的数组</span><br><span class="hljs-keyword">integer</span> :: i<br><span class="hljs-keyword">integer</span> :: error<br><br><span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;How many students?&quot;</span><br>read(*,*)students<br><span class="hljs-built_in">allocate</span>(a(students)，stat = error) <span class="hljs-comment">! 配置内存空间，stat用来查看配置内存是否成功：0-&gt;成功，其他-&gt;失败。</span><br>deallocatable(a) <span class="hljs-comment">! 释放a的内存，结合上述代码可以重新定义数组的大小</span><br><span class="hljs-keyword">if</span> (.not. <span class="hljs-built_in">allocated</span>(a)) <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">allocate</span>(a(<span class="hljs-number">5</span>))<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><span class="hljs-comment">! 检查数组a是否有配置内存，没有就请求5个元素的内存</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编程</category>
      
      <category>Fortran</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Short Introduction to Plasma Physics</title>
    <link href="/2021/08/19/plasma-introduction-translate/"/>
    <url>/2021/08/19/plasma-introduction-translate/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文包括了对等离子体现象的某些物理基础的讨论。在第二部分我们介绍了等离子体的关键特性，例如准中性、屏蔽（拜德屏蔽？）、粒子输运过程以及等离子体鞘的形成。在第三部分中我们描述了最简单的等离子体模型：从单粒子轨迹和等离子体流体动力学的基本原理推导出的集体现象（漂移）。最后讨论了均匀无界的冷等离子体的波动现象。</p>          </div><hr><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​        等离子体在自然界中以很多种形式存在，并在科技生产中有着广泛的应用。它是有以下几种物质组成的特殊电离气体：</p><ul><li>带正电荷的离子（正离子）</li><li>电子</li><li>中性粒子（原子，分子以及自由基）</li></ul><p>（在特殊条件下，等离子体也可能包含负离子，但我们之后不会讨论这种情况，因此之后的离子普遍代表“正离子”。）我们将呈现<em>准中性</em>，并且其特性由电磁力控制的电离气体称为“等离子体”。</p><p>​        由于自由离子的存在，使用等离子体作为离子源是很自然的事情，对于这种特殊情况，等离子体是通过适当形式的低压气体放电产生的，由此产生的等离子体通常被称作“低温等离子体”。尽管电子可能达到数万卡尔文的高温（比太阳表面的温度更高），而离子和中性气体的或多或少只能算是温暖，但是由于电子的质量很低，无法将它们的热能传递给更重的等离子体部分（离子或者中性气体部分）或者enclosing walls（<span class="heimu"> 这个不知道是什么意思，翻译不出来… </span>）。因此，这种类型的冷等离子体不会向其周围的环境传递太多热量，因此可以更准确地将其描述为“低熵-等离子体”。</p><h1 id="2-关键的等离子体性质"><a href="#2-关键的等离子体性质" class="headerlink" title="2. 关键的等离子体性质"></a>2. 关键的等离子体性质</h1><h2 id="2-1-粒子密度"><a href="#2-1-粒子密度" class="headerlink" title="2.1 粒子密度"></a>2.1 粒子密度</h2><p>​        由于自由运动电荷的存在，等离子体会对电磁场响应，传导电流，并具有明确定义的空间势。</p><p>​        正离子可能带有单个电荷或者多个电荷。对于包含单个电荷的离子，离子群可以被离子密度$n_i$充分描述，</p><script type="math/tex; mode=display">n_{\mathrm{i}}=\frac{\text { number of particles(粒子数量) }}{\text { volume(体积) }}, \quad\left[n_{\mathrm{i}}\right]=\mathrm{cm}^{-3} \text { or }\left[n_{\mathrm{i}}\right]=\mathrm{m}^{-3} \text { . }</script><p>除了离子密度，我们还可以通过电子密度$n_e$以及中性气体部分的密度$n_a$描述等离子体。</p><h2 id="2-2-电离度，准中性"><a href="#2-2-电离度，准中性" class="headerlink" title="2.2 电离度，准中性"></a>2.2 电离度，准中性</h2><p>​        等离子体的准中性意味着正负电荷的密度（几乎）相等。在单电荷离子的例子中，表示为：</p><script type="math/tex; mode=display">n_{\mathrm{i}} \approx n_{\mathrm{e}}</script><p>在多电荷离子的情况下，我们需要修改这个关系式。如果$z$表示正电荷离子的电荷数，$n_z$表示具有z个电荷的离子的密度，电中性的条件表示为：</p><script type="math/tex; mode=display">n_{\mathrm{e}} \approx \sum_{z} z \cdot n_{z}</script><p>电离度用粒子密度而不是电荷密度来定义。然而，这里有两种不同的定义来使用：</p><script type="math/tex; mode=display">\eta_{\mathrm{i}}=\frac{\sum_{z} n_{z}}{n_{\mathrm{a}}+\sum_{z} n_{2}} \quad \text { and } \quad \eta_{\mathrm{i}}^{\prime}=\frac{\sum_{z} n_{z}}{n_{\mathrm{a}}}</script><p>严格来说，通常情况下$\eta_{\mathrm{i}}^{\prime}$是对$\eta_i &lt;&lt;1$时的$\eta_i$的估计。离子源等离子体$\eta_i$的典型值在$10^{-5}$到$10^{-3}$之间，完全电离的等离子体$\eta_i = 1$（在这种情况下$\eta_i^{\prime} \rightarrow \infty$）。</p><p><img src="https://file.tabirstrees.top/blogfile/ITP/Charge%20separation%2C%20schematic.jpg" alt="电离过程示意"></p><center>图一 电荷分离过程示意</center><p>为了进一步研究电中性，我们假设等离子体中的电子云移动到了一个确定的区域内，形成了一个负电荷区域。类似的离子云在$L = \delta x$的距离内不存在电子，形成一个正电荷区域（见图一）。因此，我们可以在这些电荷空间的共同边界处得到一个最大值的电场$\overline{E_{max}}$。并且可以通过泊松方程得到这个最大电场的估计值：</p><script type="math/tex; mode=display">E_{\max }=\frac{e \cdot n_{\mathrm{i}} \cdot \delta x}{\varepsilon_{0}}</script><p>$E$的的方向取决于电场力使得两团粒子云趋向于相互重叠。这里$e$是基本正电荷，$\varepsilon_0$是真空中的介电常数。</p><p>为了进一步讨论，我们计算了带电粒子通过空间电荷层移动$\delta x$后的势能增量（电场力做功）$W_{pot}$：</p><script type="math/tex; mode=display">W_{\mathrm{pot}}=\int_{0}^{\delta x} e E \mathrm{~d} x=\frac{e^{2} n_{\mathrm{e}}(\delta x)^{2}}{2 \varepsilon_{0}}</script><p>唯一可以用来为上述电势能提供能量的是电子的热能（当然也有离子，但是因为离子的温度相较于电子较低，离子的热能在低温等离子体（比如离子源等离子体）中可以被忽略），对于一个自由度的运动，其能量平均为 $\frac{1}{2}k<em>{B}T</em>{e}$。因此，我们可以认为偏离电中性的尺度由下式定义出来的一个长度指标来表示：</p><script type="math/tex; mode=display">W_{\mathrm{pot}}=\frac{1}{2} k_{\mathrm{B}} T_{\mathrm{e}}</script><p>也就是对应我们所谓的<strong>德拜-休克尔（Debye-Hückel）长度</strong>$\lambda_D$：</p><script type="math/tex; mode=display">\lambda_{\mathrm{D}}=\left(\frac{\varepsilon_{0} k_{\mathrm{B}} T_{\mathrm{e}}}{e^{2} n_{\mathrm{e}}}\right)^{1 / 2}</script><p>该长度的数值可以由下式给出：$\lambda<em>{\mathrm{D}} / \mathrm{m}=7.434 \times 10^{3}\left(k</em>{\mathrm{B}} T<em>{\mathrm{e}} / \mathrm{eV}\right)^{1 / 2} /\left(n</em>{\mathrm{e}} / \mathrm{m}^{-3}\right)^{1 / 2}$（见图二）</p><p><img src="https://file.tabirstrees.top/blogfile/ITP/Debye%20length%20versus%20plasma%20density%20and%20electron%20temperature.jpg" alt="不同温度下德拜长度与电子数之间的关系"></p><center>图二 不同温度下德拜长度与电子数之间的关系</center><p>另一方面，我们可能会问在给定长度$L$上等离子体可能偏离电中性的总量是多少$\Delta n = |n_e-n_i|$。再次强调，我们只有热能是可用的，（热能转化为电势能）因此有：</p><script type="math/tex; mode=display">\frac{1}{2} k_{\mathrm{B}} T_{\mathrm{e}} \approx \frac{1}{2} \frac{e^{2}}{\varepsilon_{0}} \cdot \Delta n \cdot L</script><p>利用$k<em>{\mathrm{B}} T</em>{\mathrm{e}}$与$\lambda_D$的关系我们可以得到：</p><script type="math/tex; mode=display">\frac{\Delta n}{n} \approx\left(\frac{\lambda_{\mathrm{D}}}{L}\right)^{2}</script><p>以此来估计$\Delta n$的大小。</p><p>我们可以假设电中性的条件为$\Delta n \ll n<em>{\mathrm{e}} ,n</em>\mathrm{i}$，根据方程（10）这就等价于$L \gg \lambda_{\mathrm{D}}$。这意味着为了满足形成等离子体的条件，电离气体的延伸必须要远大于德拜-休克尔长度，等离子体的电中性被定义在一个宏观尺度上，如果我们从宏观尺度来看等离子体，会发现随着尺度的减小，其偏离电中性的程度逐渐增加。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>等离子体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>等离子体物理</tag>
      
      <tag>Plasma</tag>
      
      <tag>物理</tag>
      
      <tag>文献翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>comment-mail-style</title>
    <link href="/2021/08/13/comment-mail-style/"/>
    <url>/2021/08/13/comment-mail-style/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>最近更换了评论系统为<a href="https://twikoo.js.org/">Twikoo</a>（很好用，推荐大家使用）。完了之后感觉它的评论邮件通知样式有点不太好看，于是自己折腾了一个<span class='heimu'>也不是很好看的</span>自己弄的样式，分享出来<span class='heimu'>接受批斗</span>！</p>          </div><hr><p>首先上代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nui-fClear sR0&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: auto; width: 340px; height: 500px;&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: #f5f7f6;padding: 10px;border-radius: 5px;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">    display: -webkit-box;</span></span><br><span class="hljs-string"><span class="hljs-tag">    -webkit-box-pack: center;</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://file.tabirstrees.top/blogfile/piano%20xun.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;haokan&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:rgb(255, 233, 233);background-position: center;border-left: 3px solid #414040;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;width:500px;color:#030303;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;,微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;font-size:12px;margin: auto;&quot;</span>&gt;</span> <br>       <br>       <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom:1px solid rgb(0, 0, 0);font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: #f59200;font-weight: bold;&quot;</span>&gt;</span><span class="hljs-symbol">&amp;gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>您在 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-decoration:none;color: #f59200;&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;SITE_URL&#125;&quot;</span>&gt;</span>$&#123;SITE_NAME&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 博客上的留言有回复啦！<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(208, 212, 247); padding:5px 12px 5px 12px;margin-top:18px;border-radius: 3px;&quot;</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;PARENT_NICK&#125; 同学，您曾在<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>$&#123;SITE_NAME&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>上发表评论:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment&quot;</span>&gt;</span>$&#123;PARENT_COMMENT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;NICK&#125; 给您的回复如下:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment&quot;</span>&gt;</span>$&#123;COMMENT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您可以点击 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-decoration:none; color:#f59200&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;POST_URL&#125;&quot;</span>&gt;</span>查看回复的完整內容 <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>，欢迎再次光临 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-decoration:none; color:#f59200&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;SITE_URL&#125;&quot;</span>&gt;</span>$&#123;SITE_NAME&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">   <span class="hljs-selector-class">.comment</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span> solid <span class="hljs-number">#DDD</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span>;</span><br><span class="css">    <span class="hljs-attribute">margin</span>:<span class="hljs-number">18px</span> <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">   &#125;</span><br><span class="css"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><hr><p>然后是效果图:</p><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/comment-mail-style评论邮件通知.jpg" alt="comment-mail-style评论邮件通知"></p><hr><div class="note note-success">            <p>感觉还是太丑了,还是html和css的基础不太好,有时间得再好好学一学。大家有好看的模板也可以推荐给我啊😂！</p>          </div>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran语言学习——循环</title>
    <link href="/2021/08/12/fortran-cycle/"/>
    <url>/2021/08/12/fortran-cycle/</url>
    
    <content type="html"><![CDATA[<p><img src="https://file.tabirstrees.top/blogfile/logo-fortran.png" alt="logo-fortran"></p><h1 id="🎉DO结构"><a href="#🎉DO结构" class="headerlink" title="🎉DO结构"></a>🎉DO结构</h1><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210710211357.png" alt="DO结构"></p><p>在我们的程序编写过程中，经常会遇到需要将一部分代码重复很多遍的情况，为了使得代码简单提高可读性，可以用循环结构来进行处理，在Fortran中最常见的循环结构就是如上图所示的DO循环.</p><p>DO循环由计数器（用来决定执行循环次数的变量）的初值，终值以及增量三个部分组成（Fortran 90之后），每进行一次循环，计数器就会累加上前面设置的增量，当计数器超过终值时循环就会结束.</p><p>计数器的各项设定既可以用常量也可以用变量指定.下面是使用DO循环的一个例子（计算2+4+6+8+10）</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> ex0602<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>    <span class="hljs-keyword">integer</span>, <span class="hljs-keyword">parameter</span> : : limit=<span class="hljs-number">10</span> <span class="hljs-comment">!计数器的上限</span><br>    <span class="hljs-keyword">integer</span> counter <span class="hljs-comment">!计数器</span><br>    <span class="hljs-keyword">integer</span> :: ans = <span class="hljs-number">0</span> <span class="hljs-comment">!拿来累加使用</span><br>    <span class="hljs-keyword">do</span> counter=<span class="hljs-number">2</span>, limit ,<span class="hljs-number">2</span><br>        ans = ans + counter<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">write</span>(*,*) ans<br>    <span class="hljs-keyword">stop</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>对于Fortran 77及以前版本的代码来说，没有直接使用<code>end do</code>来结束循环的说法（但是仍然有人在使用），而必须要在DO后面写清楚循环到哪一行结束.即<code>do 结束的行代码, 计数器变量初值, 终值, 增量</code>，同时在循环结束的那一行设置好行代码（通常来说这一行的代码不需要可执行的意义，正好可以用我们前一节学习的<code>continue</code>命令.）.</p><p>当结构中的<strong>增量</strong>使用<strong>负数</strong>时，终值需要比初值小，并且终止条件会变成计数器的值比终值小时就会结束循环.</p><p>同时，结构中初值，终值，增量等如果使用变量指定时，只会在循环开始时进行一次读取，在循环过程中改变变量的值对循环是不会产生影响的，例如：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran">s=<span class="hljs-number">1</span><br>e=<span class="hljs-number">10</span><br>inc=<span class="hljs-number">1</span><br><span class="hljs-keyword">do</span> i=s, e, inc<br>    s=<span class="hljs-number">5</span><br>    e=<span class="hljs-number">1</span><br>    inc=-<span class="hljs-number">1</span><br>    <span class="hljs-built_in">write</span>(*,*) i<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br></code></pre></div></td></tr></table></figure><h1 id="🎉DO-WHILE-结构"><a href="#🎉DO-WHILE-结构" class="headerlink" title="🎉DO WHILE 结构"></a>🎉DO WHILE 结构</h1><p>某些时候我们会遇到更加复杂的情况，循环变量的增加可能不是线性的，或者需要在循环过程中根据情况特别指定增加方式，这个时候我们可以使用一个逻辑判断来进行循环的指定（当该判断的逻辑值为1时则循环，逻辑值为0时停止循环，即直到不满足条件为止一直循环下去）：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">do</span> whilw (逻辑运算) <span class="hljs-comment">! 逻辑运算成立时,会一直重复执行该循环</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <span class="hljs-comment">! 结束循环的命令</span><br></code></pre></div></td></tr></table></figure><p>相对于<code>DO</code>结构的循环而言,该结构最大的优势就是可以在循环过程中改变循环变量的值,这样就适应了更加复杂的情况.</p><h1 id="🎊循环的流程控制"><a href="#🎊循环的流程控制" class="headerlink" title="🎊循环的流程控制"></a>🎊循环的流程控制</h1><p>主要是介绍两个与循环有关的命令:<code>CYCLE</code>,<code>EXIT</code>,类似于Python中的<code>continue</code>以及<code>break</code>.</p><h2 id="🎨CYCLE"><a href="#🎨CYCLE" class="headerlink" title="🎨CYCLE"></a>🎨CYCLE</h2><p><code>CYCLE</code>命令可以直接跳过循环的某一个部分,也就是说<code>CYCLE</code>后面的代码将会不被执行而直接跳入到下一个循环中.比如:</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">do</span> <span class="hljs-built_in">floor</span>=<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">floor</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">cycle</span><br>    <span class="hljs-built_in">write</span>(*,*) <span class="hljs-built_in">floor</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br></code></pre></div></td></tr></table></figure><p>执行结构将会列出从1到9的数字(除了4以外),因为当<strong>floor=4</strong>时被<code>cycle</code>语句跳过执行<code>write(*,*) floor</code>.</p><h2 id="🎨EXIT"><a href="#🎨EXIT" class="headerlink" title="🎨EXIT"></a>🎨EXIT</h2><p>使用<code>EXIT</code>命令将跳出整个循环,也就是说当出现<code>EXIT</code>后循环将不再执行,通常出现在你并不知道需要执行多少次循环,于是设置为永久循环的情况:</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>( .true. ) <span class="hljs-comment">! 如果没有exit命令程序将永远执行下去</span><br>    <span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&#x27;weight:&#x27;</span><br>    read(*,*) guess<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(guess-weight) &lt; error ) <span class="hljs-keyword">exit</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> <span class="hljs-comment">!前面已经预先声明好了以上出现的三个变量.</span><br></code></pre></div></td></tr></table></figure><p>以上,当<code>guess</code>与<code>weight</code>的值相差在误差范围内时,循环结束.</p><hr><div class="note note-success">            <p>在Fortran中还可以为循环署名,这样可以明确最后的<code>end do</code>命令是对哪一个循环执行的:<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran">outter: <span class="hljs-keyword">do</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-comment">! 该循环署名为outter</span><br>    inner: <span class="hljs-keyword">do</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-comment">! 该循环署名为inner</span><br>        <span class="hljs-built_in">write</span>(*,<span class="hljs-string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> inner <span class="hljs-comment">! 结束内循环inner</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> outter <span class="hljs-comment">! 结束外循环outter</span><br></code></pre></div></td></tr></table></figure></p>          </div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编程</category>
      
      <category>Fortran</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Fortran</tag>
      
      <tag>循环语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fortran语言学习——流程控制与逻辑运算</title>
    <link href="/2021/07/07/fortran-logic-compute/"/>
    <url>/2021/07/07/fortran-logic-compute/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210707235432.png" alt="Fortran"></p><div class="note note-primary">            <p>我们假设大家都有一定的编程基础，至少知道编程过程中流程控制是什么意思（<span class="heimu">其实也没啥意思，就是条件语句之类的</span>）。另外把实际的例子的代码省去，这样更加精简的作为字典或者文档查询更加方便。</p>          </div><h1 id="1-IF语句"><a href="#1-IF语句" class="headerlink" title="1.IF语句"></a>1.IF语句</h1><p>首先第一个我们需要接触的就是if条件语句，在Fortran语言中一般这样写：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">if</span> (逻辑判断式) <span class="hljs-keyword">then</span><br>    ...<br>    ...<br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><br></code></pre></div></td></tr></table></figure><br>举个书上的例子，我们写一个速度超过一百就会发出警报的简单程序：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">if</span>(speed&gt;<span class="hljs-number">100</span>)<span class="hljs-keyword">then</span><br>    <span class="hljs-comment">! speed &gt; 100时才会执行下面的语句</span><br>    <span class="hljs-built_in">write</span>(*,*)<span class="hljs-string">&quot;Slow down.&quot;</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><span class="hljs-keyword">stop</span><br></code></pre></div></td></tr></table></figure><br>注意该程序知识一部分而已，前面变量的申明还是要照样做的。另外除此之外还可以简写成如下的形式：<br><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">if</span> (speed&gt;<span class="hljs-number">100</span>) <span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;Slow down.&quot;</span><br></code></pre></div></td></tr></table></figure></p><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><p>除此之外呢，我们可能还需要设置不满足条件时应该执行的语句，或者是有其他很多种情况的分支，这个时候就需要这么写：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 情况1</span><br>    ...<br>    ...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件<span class="hljs-number">2</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 情况2</span><br>    ...<br>    ...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件<span class="hljs-number">3</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 情况3</span><br>    ...<br>    ...<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-comment">! 以上情况都不满足的情况</span><br>    ...<br>    ...<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br></code></pre></div></td></tr></table></figure><h2 id="逻辑判断符号以及集合判断符号"><a href="#逻辑判断符号以及集合判断符号" class="headerlink" title="逻辑判断符号以及集合判断符号"></a>逻辑判断符号以及集合判断符号</h2><p>另外补充以下在Fortran中表示逻辑判断以及集合判断的方式:</p><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">表示含义 </th></tr></thead><tbody><tr><td style="text-align:center"> <code>==</code></td><td style="text-align:center">相等 </td></tr><tr><td style="text-align:center"> <code>/=</code></td><td style="text-align:center">不等于 </td></tr><tr><td style="text-align:center"> <code>&gt;</code></td><td style="text-align:center">大于 </td></tr><tr><td style="text-align:center"> <code>&gt;=</code></td><td style="text-align:center">大于等于 </td></tr><tr><td style="text-align:center"> <code>&lt;</code></td><td style="text-align:center">小于 </td></tr><tr><td style="text-align:center"> <code>&lt;=</code></td><td style="text-align:center">小于等于 </td></tr><tr><td style="text-align:center"> <code>.and.</code></td><td style="text-align:center">交集 </td></tr><tr><td style="text-align:center"> <code>.or.</code></td><td style="text-align:center">并集 </td></tr><tr><td style="text-align:center"> <code>.not.</code></td><td style="text-align:center">不成立 </td></tr><tr><td style="text-align:center"> <code>.eqv.</code></td><td style="text-align:center">逻辑运算相等 </td></tr><tr><td style="text-align:center"> <code>.neqv.</code></td><td style="text-align:center">逻辑运算不相等 </td></tr></tbody></table></div><p>以上，逻辑判断的运算等级高于集合运算的等级，同时出现时先执行逻辑判断（大于小于等于之类的）的语句。</p><h2 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h2><p>当存在if语句的嵌套使用时，可以这样：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">if</span> (...) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 第一层</span><br><span class="hljs-keyword">if</span> (...) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 第二层</span><br><span class="hljs-keyword">if</span> (...) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 第三层主条件</span><br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (...) <span class="hljs-keyword">then</span> <span class="hljs-comment">! 第三层次条件</span><br>...<br><span class="hljs-keyword">else</span> <span class="hljs-comment">! 第三层其余情况</span><br>...<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">! 第三层结束</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">! 第二层结束</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">! 第一层结束</span><br></code></pre></div></td></tr></table></figure><h1 id="2-浮点数以及字符的逻辑运算"><a href="#2-浮点数以及字符的逻辑运算" class="headerlink" title="2.浮点数以及字符的逻辑运算"></a>2.浮点数以及字符的逻辑运算</h1><h2 id="浮点数的逻辑判断"><a href="#浮点数的逻辑判断" class="headerlink" title="浮点数的逻辑判断"></a>浮点数的逻辑判断</h2><p>我们知道，由于计算机运行方式以及内存情况的限制，当我们进行浮点数之间的计算时通常是带有误差的，比如：$a=\sqrt{b}^2-b = 0$在实际的运算过程中可能会出现$a$不等于0的情况，这是因为计算机在计算浮点数时的有效位数的问题造成的。举个例子，$\sqrt{3}$在计算时只能采用有限的位数来保存，这个时候就会出现误差，再将这个存在误差的数字作幂次运算，等到的结果必然不会是3，而是一个接近3的数字。</p><p>如果我们需要对类似这样的情况作出判断，（判断$\sqrt{b}^2-b$是否等于0），就需要对我们的结果预留出一些误差的空间。这样，我们可以把上面的过程写成如下的形式：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">program</span></span> example<br><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br><span class="hljs-keyword">real</span> :: b = <span class="hljs-number">4.0</span><br><span class="hljs-keyword">real</span> :: a<br><span class="hljs-keyword">real</span>, <span class="hljs-keyword">parameter</span> :: e = <span class="hljs-number">0.0001</span> <span class="hljs-comment">! 表示误差的范围</span><br>a = <span class="hljs-built_in">sqrt</span>(b)**<span class="hljs-number">2</span>-b<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(a-<span class="hljs-number">0.0</span>) &lt;= e) <span class="hljs-keyword">then</span><br><span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;a等于0！&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">write</span>(*,*) <span class="hljs-string">&quot;a不等于0！&quot;</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><br><span class="hljs-keyword">stop</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><h2 id="字符的逻辑判断"><a href="#字符的逻辑判断" class="headerlink" title="字符的逻辑判断"></a>字符的逻辑判断</h2><p>和Python一样，字符甚至字符串之间也是可以用来做逻辑判断的，这实际上使用的字符转换成ASCII码之后的数值进行的逻辑判断。比如说判断<code>&#39;A&#39; &lt; &#39;a&#39;</code>为<code>true</code>是因为a的ASCII码为97，A的ASCII码为65。</p><p>需要注意的是，当字符串作比较时，实际上比较的是第一个字符的ASCII码，如果第一个字符相同就比较第二个字符，依此类推。</p><h1 id="SELECT-CASE语句"><a href="#SELECT-CASE语句" class="headerlink" title="SELECT CASE语句"></a>SELECT CASE语句</h1><p>实际上，在我们需要使用多重判断时，有一种可以代替<code>IF ... ELSE IF ...</code>的语句，那就是SELECT　CASE语句，下面是该语句的用法：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran"><span class="hljs-keyword">select</span> <span class="hljs-keyword">case</span>(变量) <span class="hljs-comment">!　这里的变量是指需要进行判断的变量</span><br><span class="hljs-keyword">case</span> (数值<span class="hljs-number">1</span>)<br>...... <span class="hljs-comment">! 当变量的数值等于数值1时，就执行该语句</span><br><span class="hljs-keyword">case</span> (数值<span class="hljs-number">2</span>)<br>...... <span class="hljs-comment">! 变量等于数值2时，执行该语句</span><br>...<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">default</span><br>...... <span class="hljs-comment">! 默认情况下，即变量不等于任何数值时，执行该语句</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">select</span><br></code></pre></div></td></tr></table></figure><p><code>slecet default</code>模块不是必要的，在<code>case</code>里面的数值设置可以设置成范围，即类似<code>2：5</code>表示2~5的数值范围，同时也支持类似<code>1，3，5</code>表示变量值等于三者中的任何一个时都会执行其所属的语句。</p><p>值得注意的是，使用<code>select case</code>语句会有一些限制：</p><ol><li>只能使用整数、字符、以及逻辑变量类型的变量，对于浮点数和复数就只能用<code>if ... else if</code>的结构；</li><li>每一个case中所使用的数值必须是固定的常量，而不能是变量。</li></ol><h1 id="其他控制流程"><a href="#其他控制流程" class="headerlink" title="其他控制流程"></a>其他控制流程</h1><h2 id="GOTO命令"><a href="#GOTO命令" class="headerlink" title="GOTO命令"></a>GOTO命令</h2><p>实际上，GOTO语法是Fortran 77时代；留下来的“旧时代”的语法，一般不建议使用，因为它会破坏代码的结构，导致代码的阅读变得比较困难，但是某些上世纪写的程序中还会留有这样的结构，所以仍然需要了解。</p><p>在Fortran语言中，可以给每一行代码赋予一个特定的编号，利用GOTO命令就可以提供给程序员一个可以使程序任意跳跃到所赋值编号的那一行程序所在位置来执行的能力。</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Fortran">  <span class="hljs-function"><span class="hljs-keyword">PROGRAM</span></span> ex0514<br>  <span class="hljs-keyword">IMPLICIT</span> <span class="hljs-keyword">NONE</span><br>  <span class="hljs-keyword">REAL</span> height <span class="hljs-comment">! 记录身高</span><br>  <span class="hljs-keyword">REAL</span> weight <span class="hljs-comment">! 记录体重</span><br><br>  <span class="hljs-built_in">WRITE</span>(*,*) <span class="hljs-string">&quot;height:&quot;</span><br>  READ (*,*)height <span class="hljs-comment">! 读入身高</span><br>  <span class="hljs-built_in">WRITE</span>(*,*) <span class="hljs-string">&quot;weight:&quot;</span><br>  READ (*,*)weight <span class="hljs-comment">! 读入体重</span><br><br>  <span class="hljs-keyword">IF</span> ( weight &gt; height-<span class="hljs-number">100</span> ) <span class="hljs-keyword">GOTO</span> <span class="hljs-number">200</span><br>  <span class="hljs-comment">! 上面不成立，没有跳到200才会执行这里</span><br><span class="hljs-number">100</span>   <span class="hljs-built_in">WRITE</span>(*,*) <span class="hljs-string">&quot;Under control.&quot;</span><br>  <span class="hljs-keyword">GOTO</span> <span class="hljs-number">300</span> <span class="hljs-comment">! 下一行不能执行所以要跳到300 .</span><br><span class="hljs-number">200</span>  <span class="hljs-built_in">WRITE</span>(*,*) <span class="hljs-string">&quot;Too fat!&quot;</span><br><br><span class="hljs-number">300</span>   <span class="hljs-keyword">STOP</span><br><span class="hljs-keyword">END</span><br></code></pre></div></td></tr></table></figure><p>如果GOTO结构可以用得比较巧妙，这样的话可以利用<code>IF</code>+<code>GOTO</code>结构来写一个类似循环的过程，或者利用类似<code>GOTO(10,20,30) a</code>（其中a表示变量，用以指代前面括号中的列表的序列切片，即1表示10，2表示20，3表示30）的结构进行有选择的跳转。<span class = "heimu">看不懂也没关系，反正就是不建议使用就对了</span></p><div class="note note-danger">            <p>最后再强调一遍，虽然GOTO结构看起来很强大，但是并不建议使用，因为这会使得代码的结构混乱，不便于阅读和维护。</p>          </div><h2 id="PAUSE-CONTINUE-STOP"><a href="#PAUSE-CONTINUE-STOP" class="headerlink" title="PAUSE, CONTINUE, STOP"></a>PAUSE, CONTINUE, STOP</h2><p>PAUSE 暂停，表示程序执行到该代码之后会暂停，知道用户按下Enter键之后程序才会继续执行。可以应用到程序需要做很多页的输出时，在每一页设置暂停，直到用户看完每一页的内容之后再按Enter键进行翻页。</p><p>CONTINUE 继续，没什么用，Fortran 90之后就不怎么使用了，基本上可以不管，因为它没有什么实际意义，只是为了方便阅读而已。</p><p>STOP 停止，很明显，执行完该代码程序就停止了，可以用来作为程序得到不合理的输入时将程序终止。</p><hr><p>研究生通知书到了，趁这里没人，独自高兴一波hahaha！<br><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/1625667151163.jpg" alt="1625667151163"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编程</category>
      
      <category>Fortran</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Fortran</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对高等数学最精简的整理(自己考研最后期间用的)</title>
    <link href="/2021/06/26/last-remenber/"/>
    <url>/2021/06/26/last-remenber/</url>
    
    <content type="html"><![CDATA[<p>博客网站建了快两年了,干货少得可怜(主要还是因为自己太菜了),想着把自己考研时候准备的复习总结的pdf放上来吧(<span class=heimu>自我感觉里面关于三重积分-体积分-线积分-面积分等的整理还是蛮不错的!</span>).同时也算是对网站新加的PDF预览功能做一个测试吧,看看能不能用.</p><div class="row">    <embed src="https://file.tabirstrees.top/blogfile/last-remenber.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高等数学</tag>
      
      <tag>笔记</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Description of Approaches in T-PROGS</title>
    <link href="/2021/05/19/fangfamiaoshu-of-T-PROGS/"/>
    <url>/2021/05/19/fangfamiaoshu-of-T-PROGS/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>在T-PROGS中提供了五种方法方便我们构建马尔科夫链的转移概率矩阵，这五种方法各自适用于不同的情况，并且在操作上有着比较大的区别，现在通过对T-PROGS操作手册的翻译来大致介绍一下每一种方法的情况。测试</p>          </div><h1 id="T-PROGS中各种方法的具体描述"><a href="#T-PROGS中各种方法的具体描述" class="headerlink" title="T-PROGS中各种方法的具体描述"></a>T-PROGS中各种方法的具体描述</h1><hr><h2 id="转移率方法"><a href="#转移率方法" class="headerlink" title="转移率方法"></a>转移率方法</h2><p>所谓转移率就是计算连续转移概率矩阵的方程所提到的转移率矩阵$R<em>\phi$的输入元素。转移率可以被解释为转移概率在滞后距离为零时的斜率。因此，一个建立转移率矩阵的方法需要估计转移概率数据的斜率：$\frac{\partial t</em>{jk}(h \rightarrow 0)}{\partial h_\phi}$ ，对于一个四分类的例子来说（debris flow, floodplain, levee, channel）转移率矩阵可以被建立为:</p><script type="math/tex; mode=display">\mathbf{R}_{z}=\left[\begin{array}{cccc}-0.87 & * & 0.10 & 0.066 \\* & * & * & * \\0.030 & * & -1.23 & 0.12 \\0.039 & * & 0.79 & -0.82\end{array}\right] \mathrm{m}^{-1}</script><p>其中非背景分类的部分是可以改变的，但是需要遵守一定的概率原则；含有背景分类的部分不能改变，程序会自动调整以满足前述概率原则。值得注意的是，对角线元素是负数，非对角线元素是非负的（这是和自转移以及协转移相关的，自己转移到自己的概率随着滞后距离的增加必定是减小的，而两个不同分类之间的转移随着滞后距离的增加自然是增加的，而转移率实际上就是转移概率的斜率，自然会满足上面的条件）。</p><hr><h2 id="使用某一特定滞后距离转移概率数据的离散滞后距离方法"><a href="#使用某一特定滞后距离转移概率数据的离散滞后距离方法" class="headerlink" title="使用某一特定滞后距离转移概率数据的离散滞后距离方法"></a>使用某一特定滞后距离转移概率数据的离散滞后距离方法</h2><p>MCMOD使用特征分析的方法来从特殊滞后距离的转移概率数据中建立转移率矩阵，其中$\Delta h_\phi$将在两者(两种岩性)相关的距离内选取，例如下面这个垂向的转移概率矩阵：</p><script type="math/tex; mode=display">\mathbf{T}\left(\Delta h_{z}=0.6 \mathrm{~m}\right)=\left[\begin{array}{llll}0.6182 & 0.2892 & 0.0529 & 0.0397 \\0.0325 & 0.8061 & 0.0787 & 0.0826 \\0.0192 & 0.3817 & 0.5258 & 0.0727 \\0.0168 & 0.0995 & 0.2359 & 0.6478\end{array}\right]</script><p>通过这个特定距离的转移概率（离散）计算出转移率，再通过转移率计算出连续的转移概率。</p><hr><h2 id="内嵌马尔科夫链分析的转移概率方法"><a href="#内嵌马尔科夫链分析的转移概率方法" class="headerlink" title="内嵌马尔科夫链分析的转移概率方法"></a>内嵌马尔科夫链分析的转移概率方法</h2><p>内嵌马尔可夫链分析是估计分离的地质单元事件发生在临近的另一个地质单元特定方向上的条件概率（通俗一点说就是某一个方向上，A分类出现在B分类之后的条件概率）。举个例子，对于上述的四分类系统中，内嵌转移概率$\pi_{jk,\phi}$在垂直方向$(z)$上被定义为：</p><script type="math/tex; mode=display">\pi_{43,\phi} = Pr\{levee \ occurs \ above \ | \ channel\  occurs\ below \}</script><p>因此内嵌转移概率矩阵$\boldsymbol{\Pi}_{z}$可以被构建为：</p><script type="math/tex; mode=display">\boldsymbol{\Pi}_{z}=\left[\begin{array}{cccc}- & 0.803 & 0.124 & 0.073 \\0.176 & - & 0.390 & 0.434 \\0.026 & 0.846 & - & 0.128 \\0.045 & 0.058 & 0.896 & -\end{array}\right]</script><p>注意，对角线上的自转移被视为无法观测到的，因此，对角线上的输入元素是空着的。从解释的观点来说，(4)式中$\pi<em>{43,z} &gt;&gt; \pi</em>{41,z}$以及$\pi<em>{43,z} &gt;&gt; \pi</em>{42,z}$意味着levee相对来说趋向于出现在channel的上面。</p><p>如果有岩层更进一步的平均长度$\overline{L}_{j,z}$的信息，那么内嵌转移概率（通过频率来估计的）可以通过下式转化为转移率矩阵：</p><script type="math/tex; mode=display">r_{jk,z} = \frac{\pi_{jk,z}}{\overline{L}_{j,z}}\\r_{jj,z} = - \frac{1}{\overline{L}_{j,z}}</script><p>因此，开发转移率矩阵的方法步骤是：</p><ol><li>根据并置趋势的地质解释或者数据建立内嵌转移概率矩阵；</li><li>建立平均长度；</li><li>根据(5)式将内嵌转移概率转化为转移率。</li></ol><p>注意非对角线元素需要满足:</p><script type="math/tex; mode=display">\sum^K_{k = 1}\pi_{jk,z} = 1</script><p>如果设定了背景类别，矩阵中包含了背景类别的行列元素就不需要精确规定（可以将它们设置为零），这样根据内嵌转移概率以及平均长度改进后的转移率矩阵$R_z$为：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}\bar{L}_{1, z}=1.15 & * & 0.12 & 0.075 \\* & * & * & * \\0.025 & * & \bar{L}_{3, z}=0.82 & 0.10 \\0.04 & * & 0.96 & \bar{L}_{4, z}=1.24\end{array}\right]</script><p>其中第2各分类被设置为背景类别，这就是为什么含有该类别的元素被设定成了任意值，由此建立的马尔科夫链如下图所示：</p><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210518114127.png" alt="image-20210518114127505"></p><p>可以看到，由内嵌转移概率方法对测量转移概率的拟合相对初试模型（最大熵因子法）来说稍稍更好一点。</p><hr><h2 id="内嵌马尔科夫链分析的转移频率方法"><a href="#内嵌马尔科夫链分析的转移频率方法" class="headerlink" title="内嵌马尔科夫链分析的转移频率方法"></a>内嵌马尔科夫链分析的转移频率方法</h2><p>所谓内嵌转移频率（垂直方向上）被定义为：</p><script type="math/tex; mode=display">f_{43,z} = Pr\{ levee\ occurs\ above\ {\bf and} \ channel\ occurs\ below\}</script><p>于是内嵌转移频率矩阵$F_z$可以被表示为：</p><script type="math/tex; mode=display">\mathbf{F}_{z}=\left[\begin{array}{llll}(0.0841) & 0.0677 & 0.0101 & 0.0063 \\0.0672 & (0.3468) & 0.1264 & 0.1713 \\0.0085 & 0.2971 & (0.3395) & 0.0340 \\0.0085 & 0.0000 & 0.2031 & (0.2115)\end{array}\right]</script><p>其中对角线元素（插入的部分）是对应$j$类别嵌入事件的边缘频率$f_{j,z}$的行列之和：</p><script type="math/tex; mode=display">f_{j,z} = \sum^K_{k \not= j}f_{jk,z} = \sum^K_{j \not= k}f_{kj,z}</script><p>再加上平均长度$\overline{L}_{j,z}$的信息，转移频率可以转化为转移率通过：</p><script type="math/tex; mode=display">r_{jk,z} = \frac{f_{jk,z}}{f_{j,z} \overline{L}_{j,z}} \quad \forall k \neq j</script><p>类似内嵌转移概率，MCMOD同样可以由转移频率构建出转移率矩阵的非对角线部分的元素：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}\bar{L}_{1, z}=1.15 & * & 0.0101 & 0.0063 \\* & \bar{L}_{1, z}=2.27 . & * & * \\0.0085 & * & \bar{L}_{3, z}=0.82 & 0.0340 \\0.0085 & * & 0.2031 & \bar{L}_{4, z}=1.24\end{array}\right]</script><p>尽管非对角线元素并不需要额外的设定，但是这个方法需要背景类别的平均长度，因为边缘频率依赖于各个类别的比例以及平均长度。</p><hr><h2 id="“独立性”或者“最大熵因子（无序）”转移频率方法"><a href="#“独立性”或者“最大熵因子（无序）”转移频率方法" class="headerlink" title="“独立性”或者“最大熵因子（无序）”转移频率方法"></a>“独立性”或者“最大熵因子（无序）”转移频率方法</h2><p>地质系统的并置趋势反映了地层序列的有序或者无序的程度，地层之间转移频率$f<em>{jk,\phi}$（某一种地层紧挨着其他地层的概率）的熵因子$S</em>{\phi}$可以量化某一特殊方向$\phi$上的并置趋势的无序性，其中熵因子定义（参考“熵分析方法”）为：</p><script type="math/tex; mode=display">S_{\phi} = - \sum_j \sum_k f_{jk,\phi} \ln{f_{jk,\phi}}</script><p>考虑一个问题，“最大程度无序的系统来说，地层应该是什么样的呢？”。从我们所参考的状态来说，其中一个答案可能是能够判断出观察到的地层序列显示非随机的并置趋势或者说是一定程度上的有序。</p><p>在应用内嵌马尔科夫链分析时，地质学家将兴趣放在量化他们对用地质相连续性的解释上，尤其是在垂直方向上。四种类别岩性连续性的“随机”或者独立的转移频率为：</p><script type="math/tex; mode=display">\left[\begin{array}{llll}f_{1} f_{1} & f_{1} f_{2} & f_{1} f_{3} & f_{1} f_{4} \\f_{2} f_{1} & f_{2} f_{2} & f_{2} f_{3} & f_{1} f_{4} \\f_{3} f_{1} & f_{3} f_{2} & f_{3} f_{3} & f_{3} f_{4} \\f_{4} f_{1} & f_{4} f_{2} & f_{4} f_{3} & f_{4} f_{4}\end{array}\right]</script><p>其中$f<em>i$代表连续出现$i$类别的“边缘”频率，但在实际操作中这个问题并不简单。通常来说，自转移的情况是无法观察到的（尤其是对于钻孔数据来说），所以不仅仅是对角线上的转移频率，就连边缘频率也是没有办法直接估计的。而非对角线上的转移</em>计数_是可以被精确估计的，因为协转移（不同类别之间的转移）是可以观察到的。</p><p>假设自转移观察不到，一个更加实际的问题就被暴露出来了。于是，取而代之的是，非对角转移频率$\eta_{jk}$的观测值，被定义为转移计数除以所有非对角转移计数的总和：</p><script type="math/tex; mode=display">\left[\begin{array}{llll}- & \eta_{12} & \eta_{13} & \eta_{14} \\\eta_{21} & - & \eta_{23} & \eta_{24} \\\eta_{31} & \eta_{32} & - & \eta_{34} \\\eta_{41} & \eta_{42} & \eta_{43} & -\end{array}\right]</script><p>其中，自转移无法观察到，所以留为空白。</p><p>独立转移频率的目标是找到满足以下条件的$f_i$：</p><script type="math/tex; mode=display">\frac{1}{T} \sum^K_{j \neq i} f_i f_j = \sum_{j \neq i}^K \eta_{ij} \quad \forall i = 1,...,K\\T = \sum^K_{i = 1}\sum^K_{i \neq j} f_i f_j</script><p>上式的非线性系统可以通过IPF（iterative proportion fitting)方法解决。生成的独立模型将显示嵌入事件$\eta_i$的相同边缘频率：</p><script type="math/tex; mode=display">\eta_{i}=\sum_{j \neq i}^{K} \eta_{i j} \quad \forall i=1, \ldots, K</script><p>以上，与$f_i$对应的非对角线转移频率将会是独立的。通过将$\eta_i$与比例$p_i$除以平均长度$\bar{L}_i$成比例，可以将连续滞后马尔可夫链模型与该独立性模型联系起来：</p><script type="math/tex; mode=display">\frac{p_{i}}{L_{i}} \propto \eta_{i} \quad \forall i=1, \ldots, K</script><p>因此，给定比例和平均长度的设定，就可以得到一个包含独立转移频率的连续滞后马尔科夫链。</p><p>因此一个特殊的问题出现了，“对于给定的比例和平均长度，什么是使得熵最大的转移频率矩阵呢？”巧合的是统计独立性的概念正好与最大熵的结果是一致的。在先前的例子中，比例和平均长度对应的独立或者最大熵转移频率矩阵$F_z^{(S\ max)}$为</p><script type="math/tex; mode=display">\mathbf{F}_{z}^{(S \max )}=\left[\begin{array}{cccc}(0.0841) & 0.0377 & 0.0311 & 0.0152 \\0.0377 & (0.3671) & 0.2196 & 0.1075 \\0.0311 & 0.2196 & (0.3396) & 0.0888 \\0.0152 & 0.1075 & 0.0888 & (0.2115)\end{array}\right]</script><p>其中对角线元素代表某一行或者某一列的边缘频率的总和。这个矩阵可以用来作为解释在相同比例和平均长度的情况下与最大无序程度的地层连续性相关的并置趋势的基础。例如，如果观测到的转移频率$f<em>{43,z}$比$f</em>{z}^{(S\ max)}$更大，一个可能的推断是此处<em>levee</em>出现在<em>channel</em>的上方是具有统计趋势的.</p><p>综上所述，开发转移率矩阵有以下的步骤：</p><ol><li>建立各类别的比例和平均长度；</li><li>计算最大熵因子转移频率矩阵$F_{z}^{(S\ max)}$以及相应的转移率；</li><li>解释相对于最大熵因子转移率的非对角转移率。</li></ol><p>举个例子里说，根据（11），最大熵因子转化率$r_{jk,z}^{(S\ max)}$可以通过下式计算：</p><script type="math/tex; mode=display">r_{j k, z}^{(S \max )}=\frac{f_{j k, z}^{(S \max )}}{\bar{L}_{j, z} \sum_{k \neq j} f_{j k, z}^{(S \max )}}</script><p>最大熵转移率对应的垂向转移率矩阵表示为：</p><script type="math/tex; mode=display">\mathbf{R}_{z}^{(S \max )}=\left[\begin{array}{llll}\frac{-1}{\bar{L}_{1, z}=1.15 \mathrm{~m}} & 1.80 r_{12, z}^{(S \max )} & 0.32 r_{13, z}^{(S \max )} & 0.41 r_{14, z}^{(S \max )} \\1.78 r_{21, z}^{(S \text { max })} & \frac{-1}{\bar{L}_{2, z}=2.27 \mathrm{~m}} & 0.58 r_{23, z}^{(S \max )} & 1.59 r_{24, z}^{(S \max )} \\0.27 r_{31, z}^{(S \max )} & 1.35 r_{32, z}^{(S \max )} & \frac{-1}{\bar{L}_{3, z}=0.82 \mathrm{~m}} & 0.45 r_{34, z}^{(S \max )} \\0.56 r_{41, z}^{(S \max )} & 0.00 r_{42, z}^{(S \max )} & 2.29 r_{43, z}^{(S \max )} & \frac{-1}{\bar{L}_{4, z}=1.24 \mathrm{~m}}\end{array}\right]</script><p>这样计算出来的非对角线上的元素通过系数乘以$r_{jk,z}^{(S\ max)}$得到，如果比1小则表示两个类别具有并置趋势（在某个方向上某一分类通常紧挨着另一分类出现）小于1时则不具有并置趋势。</p><p>最大熵的概念在解释已存在的马尔科夫链模型的并置趋势时是非常有用的。举个例子，你可以通过比例和平均长度建立一个已存在的模型，比如说（11），然后生成一个马尔科夫链，它有着最大程度的无序的并置趋势。再与转移概率方法进行比较，从而解释地层是否展现出了一定程度的有序并置趋势。在这过程中必须要给定全部类别的平均长度，包括背景类别。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>地下水数值模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GMS</tag>
      
      <tag>地统计</tag>
      
      <tag>转移概率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地下水数值模拟软件获取以及相关教程</title>
    <link href="/2021/02/06/gmssoftware/"/>
    <url>/2021/02/06/gmssoftware/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/16213678437069085683738921793155.jpg" alt="GMS"></p><p>由于毕业论文做T-PROGS与MODFLOW的结合来模拟地下水水流运动的研究，需要学习地下水模拟相关方面的的软件。在这个过程中也走不少的弯路，经过一番折腾，终于在网上找到了一些非常好的入门资料。为了方便之后的有需要的人<del>(估计只有我这样的菜鸡才会需要了┭┮﹏┭┮)</del> ，我把我能找的所有资料罗列出来，以便查阅！</p><span id="more"></span><h1 id="GMS"><a href="#GMS" class="headerlink" title="GMS"></a>GMS</h1><p>关于GMS（Groundwater Modeling System）其实就是一些常见的地下水数值模拟软件的集合体，包括下面会出现的MODFLOW以及一些<del>我没有用到的</del>其他软件包。该软件由Aquaveo, LLC.发行，国内好像是北水国际公司代理的<div class="heimu"> 啊，这个我不清楚！我乱说的</div>。可以从<a href="https://www.aquaveo.com/software/gms-groundwater-modeling-system-introduction">Aquaveo</a>的官网上下载到的最新版本（目前是10.5.6），除了免费的Community版本以外好像都还挺贵的。</p><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210110170550.png" alt="GMS"></p><p>为此，几番周折之后我找到了含有破解版的10.4.5版本，将其放到了我的onedrive网盘之中<del>可以通过API权限的方式直接通过网页访问</del>。</p><div class="note note-success">            <p><a href="https://zfile.tabirstrees.top/directlink/3/%E8%BD%AF%E4%BB%B6/%E5%9C%B0%E4%B8%8B%E6%B0%B4%E6%95%B0%E5%80%BC%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6/GMS/10.4.5/AquaveoGMS.zip">点击下载10.4.5版本</a><br>该版本教程网址为：<a href="https://www.aquaveo.com/software/gms-learning-tutorialswww.aquaveo.com">https://www.aquaveo.com/software/gms-learning-tutorialswww.aquaveo.com</a> 基本上包括了所有的基础软件操作和可以实现的功能教程，也可以在这里找到所有对应的项目资源数据文件。</p><p><a href="https://zfile.tabirstrees.top/directlink/3/%E8%BD%AF%E4%BB%B6/%E5%9C%B0%E4%B8%8B%E6%B0%B4%E6%95%B0%E5%80%BC%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6/GMS/GMS.rar">点击下载7.1版本（由学长提供）</a><br>该版本的教程在安装时可以选择（默认）下载，安装完之后可以在安装目录下的tutorial文件夹中找到，包括了各种项目的数据资源文件。除此之外，学长提供的软件包里面还包括了一份中文翻译之后的软件教程，具体对应的版本还不是很清楚，不过基本都差不多能用，可以作为参考，推荐还是尽量阅读原始的英文教程。</p>          </div><p>有了这些东西之后可以相对快速的入门GMS，不用到处寻找软件教程以及相关书籍。but，这些tutorials都是全英文文档，对于不习惯看英文材料的同学可能不是很友好╮(╯▽╰)╭ 。</p><h1 id="MODFLOW"><a href="#MODFLOW" class="headerlink" title="MODFLOW"></a>MODFLOW</h1><p>这一次毕业论文其实主要是使用GMS中的T-PROGS和MODFLOW模块，事实上MODFLOW和T-PROGS都是开源的。T-PROGS由于年代久远似乎已经失传了，关于这部分内容是我毕业论文的主体，之后会单独出一篇学习笔记来详细阐述。</p><p>对于MODFLOW来说，商业软件GMS以及Visual MODFLOW等都是可以使用的，但是实际生产问题是千差万别的，没有所谓“通用的软件”可以解决实际上遇到的所有问题，对于科学研究的创新来说更是如此！我们需要学会在原有的代码的基础上添加自己对地下水运移这个过程的深入理解，一定的编程和数学物理能力必不可少，此外我们也不必要自己完全重新写写个软件出来。这可能也是USGS（美国地质调查局 United States Geological Survey）将MODFLOW开源并持续维护更新的原因所在吧。</p><p>而MODFLOW目前已经更新到<a href="https://www.usgs.gov/software/modflow-6-usgs-modular-hydrologic-model">MODFLOW 6</a><br>了，该项目也可以在GitHub（<a href="https://github.com/MODFLOW-USGS/modflow6">MODFLOW-USGS/modflow6</a>）上找到，甚至包括了一些大佬自己修复的一些bug和添加功能。</p><p>由于是开源软件，提供的都是Fortran语言的源代码，而USGS也相当<del>“贴心”</del>地提供了一系列关于如何使用的教程，我全部打包放在了我的云盘里一并提供在此：</p><div class="note note-success">            <p><a href="https://zfile.tabirstrees.top/directlink/3/%E8%BD%AF%E4%BB%B6/%E5%9C%B0%E4%B8%8B%E6%B0%B4%E6%95%B0%E5%80%BC%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6/MODFLOW%E5%BC%80%E6%BA%90%E6%96%87%E4%BB%B6.zip">https://zfile.tabirstrees.top/directlink/3/%E8%BD%AF%E4%BB%B6/%E5%9C%B0%E4%B8%8B%E6%B0%B4%E6%95%B0%E5%80%BC%E6%A8%A1%E6%8B%9F%E8%BD%AF%E4%BB%B6/MODFLOW%E5%BC%80%E6%BA%90%E6%96%87%E4%BB%B6.zip</a></p>          </div><h1 id="总结一下嘛"><a href="#总结一下嘛" class="headerlink" title="总结一下嘛"></a>总结一下嘛</h1><p>感觉写了一千多字<div class="heimu">可能还没有😂</div>的废话……下次一定整点有用的！<br><img src="http://image.tabirstrees.top/images/2021/02/06/E77C06B943FAD6398EAA3097BE3B80C1.jpg" alt="一张图而已，没什么好看的"></p>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GMS</tag>
      
      <tag>地下水</tag>
      
      <tag>数值模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>T-PROGS</title>
    <link href="/2021/01/10/T-PROGS/"/>
    <url>/2021/01/10/T-PROGS/</url>
    
    <content type="html"><![CDATA[<h1 id="关于T-PROGS的简单介绍"><a href="#关于T-PROGS的简单介绍" class="headerlink" title="关于T-PROGS的简单介绍"></a>关于T-PROGS的简单介绍</h1><p>T-PROGS是一个可以模拟地质岩性在三维空间中的随机分布的成熟软件，它原本是基于Fortran语言的开源软件包，现在的地下水模拟软件GMS软件系统中已经包含了该模块，可以直接在GMS中直接使用。本文的目的在于记录该软件模块的使用学习和过程记录。</p><h1 id="为什么要使用T-PROGS"><a href="#为什么要使用T-PROGS" class="headerlink" title="为什么要使用T-PROGS"></a>为什么要使用T-PROGS</h1><p>在地下水数值模拟的过程中，由于地下水系统属于巨复杂系统，将其复杂的运移过程简单的用一个微分方程的计算结果代替必然会产生大量的不确定性；另外模拟所需要的参数在获取过程中同样会带来各种各样的不确定性。目前的地下水数值模拟逐渐将目光集中到地下水模拟的不确定性分析上，在各种非确定分析方法中使用广泛的随机模拟方法最为常见。</p><h2 id="随机模拟方法"><a href="#随机模拟方法" class="headerlink" title="随机模拟方法"></a>随机模拟方法</h2><p>地下水随机模拟主要有矩方程法和Monte Carlo法。矩方程法通过求解随机微分方程直接求取模拟结果的各阶统计矩；Monte-Carlo方法则是通过随机场生成器实现大量的确定模型，对这些实现的模拟结果进行统计分析得到模拟的统计特征。</p><p>在Monte-Carlo方法过程中涉及到随机参数场的生成。对<strong>渗透性</strong>这一参数而言，为了分析其在模拟过程中的不确定性大小，对其进行参数随机模拟，于是需要生成大量的渗透系数随机场。一般来说，渗透系数的自然分布满足<strong>对数正态分布</strong>的关系，在已知水文地质参数信息的帮助下通过各种条件模拟方法便可以模拟出未知点处的渗透系数概率分布情况，并基于此概率生成大量的确定参数场进行地下水数值模拟。</p><h2 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h2><p>此处涉及到水文地质概念模型建模过程的问题：1. 直接建模，在建立水文地质概念模型时直接输入所需要的各种边界条件，源汇项以及水文地质参数；2. 间接建模，在水文地质参数的建立过程中，并不是直接划分参数分区并给定相应的参数，而是先通过三维地质建模建立研究区的三维地质模型，再根据地质介质与水文地质参数之间的相互联系间接地建立水文地质参数场。间接建模的好处是考虑了自然情况下的物理因素（一般来说，误差范围内的水文地质参数就是由地质结构以及地层介质来决定的），减少了由于人为的参数分区而带来不确定性。</p><p>在此基础上，我们可以说实际上T-PROGS是一种基于马尔科夫链的“转移概率地统计（<em>Transition Probability Geostatistical</em>）”模型，用于生成地层岩性的三维随机分布。他主要处理的是类似钻孔信息的<strong>分类</strong>地质参数（指示地统计方法）。通过间接建模的方法利用T-PROGS便可以直接由钻孔数据得到渗透系数等水文地质参数的随机分布场，相对于其他方法更加占据优势，在国内外也得到了大量的应用。<del>举例就不要举例了，又不是写论文……</del></p><hr><h1 id="理论与方法"><a href="#理论与方法" class="headerlink" title="理论与方法"></a>理论与方法</h1><h2 id="地统计方法简单介绍"><a href="#地统计方法简单介绍" class="headerlink" title="地统计方法简单介绍"></a>地统计方法简单介绍</h2><p>地质统计学的核心以及基础是”变差(变异)函数”:</p><blockquote><p>空间中一点$x$与其相邻一点$x+h$的某一相关变量$Z(x)$方差的差值,称为$Z(x)$在$x$方向上的变异函数,记为$\gamma(x,h)$:  </p><script type="math/tex; mode=display">\gamma(x, h)=\frac{1}{2} \operatorname{Var}[Z(x)-Z(x+h)]</script></blockquote><p>上式是在以为情况下成立的,高维情况都是以一维情况为基础,在二阶平稳场(简单来说就是$\gamma(x,h)$只与$h$有关,任何一点相同距离内的变差函数的均值都是一样的)中有:</p><blockquote><script type="math/tex; mode=display">\gamma(h)=\frac{1}{2} E\left[(Z(x)-Z(x+h))^{2}\right]-\frac{1}{2}(E[Z(x)-Z(x+h)])^{2}</script></blockquote><p>如此一来,变异函数就被简化为一个单变量函数,并且在$x$方向上任取两点$x_i,x_i+h$对应的变异函数都是以$h$为自变量的随即变量的一个统计样本,其所有取值构成了一次统计。</p><p>对于<strong>克里金方法(Kriging Method)</strong>来说,空间中一点处某一参数$z$的估计值为:</p><script type="math/tex; mode=display">\hat z_o = \sum_{i=1}^n\lambda_iz_i</script><p>其中$\hat{z_o}$是点处的估计值，即$z_o=z(x_o,y_o)$,$λ_i$是权重系数。克里金方法是用空间上所有已知点的数据加权求和来估计未知点的值。此处的权重是能够满足点 $(x_o,y_o)$处的估计值$\hat{z_o}$与真实值$z_o$的差最小的一套最优系数，即</p><script type="math/tex; mode=display">\min_{\lambda_i} Var(\hat{z_o}-z_o)</script><p>同时满足无偏估计的条件:</p><script type="math/tex; mode=display">E(\hat{z_o}-z_o)=0</script><p>求解简化（拉格朗日乘数法）之后可以得到下面的一组控制方程:</p><script type="math/tex; mode=display">\left\{    \begin{aligned}        \sum_{i=1}^n\lambda_i\gamma((x_i,y_i),(x_j,y_j))+\mu &=\overline\gamma((x_o,y_o),V) \\        \sum_{i=1}^n\lambda_i &= 1    \end{aligned}\right.</script><p>在上式中唯一未知的便是我们先前所提到的变差函数（或称变异函数,半方差函数；此处的$\overline\gamma(x_o,V)$表示以$(x_o,y_o)$为中心的一个空间范围$V$内所有的变差函数的均值）。事实上，根据地理学第一定律：距离越近空间相关性越强，我们可以简单地做出假设：</p><blockquote><p>两点的变差函数与其距离之间存在某种函数关系，这种函数关系可以是线性、二次函数、指数、对数关系。</p></blockquote><p>通过对数据集进行分析，从而寻找到一个最优的拟合曲线拟合距离$d$与变差函数$\gamma$的关系，得到函数关系式$\gamma = \gamma(d)$那么对于任意两点$(x<em>i,y_i)$，$(x_j,y_j)$，先计算他们之间的距离$d</em>{ij}$然后根据得到的函数关系就可以得到这两点的变差函数，进一步的解决空间中一点的参数估计问题。</p><hr><h2 id="马尔科夫链与转移概率地统计"><a href="#马尔科夫链与转移概率地统计" class="headerlink" title="马尔科夫链与转移概率地统计"></a>马尔科夫链与转移概率地统计</h2><p>转移概率是马尔科夫链的一个重要概念，马尔科夫过程假设事物后一时刻的状态至于前一时刻的状态相关。换句话说：今天的事情由昨天完全决定，明天的事情由今天完全决定，并且与此前的每一天都没有直接关系。在此基础上所谓转移概率就是从一种状态转变为另一种状态的概率，在地统计学中有如下的表达：</p><script type="math/tex; mode=display">t_{jk}(h) = Pr(k\ occurs\ at\ (x+h)\ |\ j\ occurs\ at\ x)</script><p>它表示已知$x$处的岩性为$j$，$(x+h)$处岩性为$k$的概率。</p><p>利用指示地统计中指示变量的形式（$I_j(x)$）我们可以将变差函数转为下面的形式（协变差函数）：</p><script type="math/tex; mode=display">\begin{aligned}    \gamma_{jk}(h) &= \frac{1}{2}E{[I_j(x)-I_j(x+h)][I_k(x)-I_k(x+h)]} \\    I_j(x) &=\left\{        \begin{aligned}            1\ &,if\ occurs\ at\ x\\            0\ &,otherwise        \end{aligned}    \right.\end{aligned}</script><p>同时，将转移概率用指示变量表示：</p><script type="math/tex; mode=display">t_{jk}(h) = \frac{E[(I_j(x)I_k(x+h))]}{E[I_j(x)]}</script><blockquote><p>PS:这里使用均值是一个统计过程，实际过程过我们不可能知道概率的实际大小，所以利用统计得到的两个事件各自在多个统计点发生的平均数之比来代替概率之比。事实上，在指示地统计中均值和概率是等价的。</p></blockquote><p>紧接着,我们可以将转移概率和所谓协变差函数结合起来,找出它们的关系式:</p><p>作如下的假设:</p><script type="math/tex; mode=display">\begin{aligned}    P_j(x) &= E[E[I_j(x)]]\\    P_{jk}(h) &= E[E[I_j(x)I_k(x+h)]]\end{aligned}</script><p>特别的,我们有:$P_{jk}(0) = P_j(x)P_k(x)$，如此一来，协变差函数以及转移概率就变成了如下的形式：</p><script type="math/tex; mode=display">\begin{aligned}    \gamma_{jk}(h) &= P_{jk}(0)-\frac{1}{2}(P_{jk}(h)+P_{jk}(-h))\\    t_{jk}(h) &= \frac{P_{jk}(h)}{P_j(x)}\\    \Rightarrow\ \ \ \gamma_{jk}(h) &= P_j(x){t_{jk}(0)-\frac{1}{2}[t_{jk}(h)+t_{jk}(-h)]}\end{aligned}</script><p>最后，结合克里金方法与转移概率，用转移概率矩阵表达上述普通克里金方程：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}t_{i j}\left(x_{1}-x_{1}\right) & \cdots & t_{i j}\left(x_{N}-x_{1}\right) & 1 \\\vdots & \ddots & \vdots & \vdots \\t_{i j}\left(x_{1}-x_{N}\right) & \cdots & t_{i j}\left(x_{N}-x_{N}\right) & 1 \\1 & \cdots & 1 & 0\end{array}\right]\left[\begin{array}{c}\lambda_{j, 1} \\\vdots \\\lambda_{j, n} \\\mu\end{array}\right]=\left[\begin{array}{c}t_{i j}\left(x-x_{1}\right) \\\vdots \\t_{i j}\left(x-x_{N}\right) \\1\end{array}\right]</script><p>这样，通过转移概率利用克里金进行空间插值就得到了实现。</p><hr><div class="note note-primary">            <p>参考文献:<br>克里金(Kriging)插值的原理与公式推导:<a href="https://xg1990.com/blog/archives/222">https://xg1990.com/blog/archives/222</a></p><p>董英, 基于随机水文地质结构的华北平原地下水流模拟研究, 2006, 中国地质大学（北京）. </p>          </div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>地下水数值模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GMS</tag>
      
      <tag>地下水溶质运移模型</tag>
      
      <tag>地统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex 论文排版相关学习</title>
    <link href="/2020/08/28/texstudy/"/>
    <url>/2020/08/28/texstudy/</url>
    
    <content type="html"><![CDATA[<h1 id="1-一点点关于Latex的介绍"><a href="#1-一点点关于Latex的介绍" class="headerlink" title="1. 一点点关于Latex的介绍"></a>1. 一点点关于Latex的介绍</h1><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828160435.png" alt="20200828160435"></p><p>Latex是一款排版软件，诸如教材、报纸、书信等纸质印刷相关的排版都是可以做的。一般人使用Latex最多的地方是论文的写作，特别是涉及到大量公式的数学物理方面的科技论文，这方面目前有很多网上流行的模板，我们只需要在了解简单的Latex基础操作的基础上带入模板就好，所以还是非常方便的。</p><blockquote><p>有很多 Geeks 或者 LaTeX’s Fanatical Fans 过分地强调了 LaTeX 的一些并非重点的特性，以至于很多初学者会觉得 LaTeX 很神秘很复杂，从而引发了初学者的畏难情绪甚至是负面情绪。尽管这些 Fans 说得并没有错，我是说在事实上，但是他们的表达方式和内心态度却间接阻碍了 LaTeX 的发展，我想这也是和他们的初衷相悖的。————Liam Huang<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://liam.page/2014/09/08/latex-introduction/">[1]</span></a></sup></p></blockquote><h1 id="2-Latex写作的进行"><a href="#2-Latex写作的进行" class="headerlink" title="2. Latex写作的进行"></a>2. Latex写作的进行</h1><h2 id="2-1-准备知识"><a href="#2-1-准备知识" class="headerlink" title="2.1 准备知识"></a>2.1 准备知识</h2><p>Latex中以<code>%</code>作为注释开头，也就是不会输出<code>%</code>后直到行末的所有内容，同时不会影响最终的排版效果，仅供人们在阅读源代码是的注释。至于数学意义上的“%”字符，需要在<code>%</code>之前加上<code>\</code>进行转义（escape）。即：<code>\%</code>。除此之外还有很多特殊字符的使用需要各位注意:</p><blockquote><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828115548.png" alt="20200828115548"></p></blockquote><p>当我们需要对我们的内容做出明确控制时，我们需要调用控制序列来解决问题，类似于其他编程语言中的函数。比如我们需要在第一行指明文档类型，需要使用:<code>\documentclass[]&#123;article&#125;</code>，这就是一个控制序列（命令、标记），以<code>\</code>开头，以第一个<strong>空格或者非字母的字符</strong>结束的一串文字。<code>&#123;&#125;</code>中是这个控制序列的必要参数(此处为‘article’，其作用是调用名为“article”的文档类），部分控制序列还会有方括号<code>[]</code>，表示可选参数。</p><blockquote><p>所谓的文档类，是TeX系统预设或者用户自己给定的一些格式的集合，不同的文档类对应了不同的输出效果。</p></blockquote><p>TeX中的控制序列包括了两种，一种是一个控制序列单独使用，例如<code>\documentclass[]&#123;&#125;</code>等；另一种是需要两个配套的控制序列成对出现，通常是<code>\begin</code>和<code>\end</code>，这两个控制序列以及其中间的内容被称为<em>环境</em>。他们之后的第一个必要参数总是一致的，被称为环境名。<br>只有在<code>document</code><strong>环境</strong>中的内容才能够被输出到文档中去或是作为控制序列对文档产生影响。也就是说，在<code>\end&#123;document&#125;</code>之后插入的内容都是无效的。</p><p>在从<code>\documentclass&#123;article&#125;</code>到<code>\begin&#123;document&#125;</code>之间的部分被称为“导言区(preamble)”，你可以将导言区理解为使用某些特殊的控制序列对整篇文章的格式进行设置的区域，比如我们可以在导言区引用一些额外的宏包以及设置页面大小、页眉页脚、章节标题样式等等<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://liuchengxu.org/blog-cn/posts/quick-latex/">[2]</span></a></sup>。</p><p>另外，类似于markdown文件，TeX中换行是需要两次换行才能起效（需要一个空行），否则会被处理成一个简单的空格，且命令后面的空格会被忽略，需要使用<code>\</code>进行转义。为了将命令（控制序列）的范围进行限制，需要使用<code>&#123;&#125;</code>将命令内容包括起来<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf">[3]</span></a></sup>，如：<code>\frac&#123;a&#125;&#123;b&#125;</code>表示：</p><script type="math/tex; mode=display">\frac{a}{b}</script><h2 id="2-2-导言区控制序列"><a href="#2-2-导言区控制序列" class="headerlink" title="2.2 导言区控制序列"></a>2.2 导言区控制序列</h2><ul><li><code>\documentclass[]&#123;&#125;</code>规定了使用的文档模板，是文件必须的命令，可供选择的必要参数有：article、book、report、beamer等TeX自带模板或使用者自己准备的一系列模板；可选参数主要定义打印输出时的编码、纸张等条件。如：<code>\documentclass[UTF8,a4paper]&#123;article&#125;</code></li><li><code>\usepackage&#123;&#125;</code>可以用来引用宏包，常用的有：<code>graphicx</code>——插图；<code>amsmath</code>——一些方便的公式、符号命令等”</li><li>除此之外还涉及到标题、作者以及日期等等分别用以下的控制序列进行控制：<code>\title&#123;&#125;</code>、<code>\author&#123;&#125;</code>、<code>\date&#123;&#125;</code>，这些内容在导言区设置好后可以利用<code>\maketitle</code>控制序列在环境区域内按照特定格式输出</li></ul><p>以下是演示：<br><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\d</span>ocumentclass[UTF8]&#123;ctexart&#125;<br><span class="hljs-symbol">\t</span>itle&#123;你好，world!&#125;<br><span class="hljs-symbol">\a</span>uthor&#123;Liam&#125;<br><span class="hljs-symbol">\d</span>ate&#123;<span class="hljs-symbol">\t</span>oday&#125;<br><span class="hljs-symbol">\b</span>egin&#123;document&#125;<br><span class="hljs-symbol">\m</span>aketitle<br>你好，world!<br><span class="hljs-symbol">\e</span>nd&#123;document&#125;<br></code></pre></div></td></tr></table></figure><br><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828144122.png" alt="20200828144122"></p><h2 id="2-3-章节和段落"><a href="#2-3-章节和段落" class="headerlink" title="2.3 章节和段落"></a>2.3 章节和段落</h2><p>在文档类 “article/ctexart” 中，定义了五个控制序列来调整行文组织结构。他们分别是</p><ul><li><code>section&#123;&#125;</code></li><li><code>subsection&#123;&#125;</code></li><li><code>subsubsection&#123;&#125;</code></li><li><code>paragraph&#123;&#125;</code></li><li><code>subparagraph&#123;&#125;</code></li></ul><p>在”report/ctexrep”文档类中，还有<code>\chapter&#123;·&#125;</code>；”book/ctexbook”文档类中，还定义了<code>\part&#123;·&#125;</code>。取决于各种文档类（模板）中所定义的章节控制序列。</p><p>以下是演示：<br><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="hljs-string">\title&#123;你好，world!&#125;</span><br><span class="hljs-string">\author&#123;Liam&#125;</span><br><span class="hljs-string">\date&#123;\today&#125;</span><br><span class="hljs-string">\begin&#123;document&#125;</span><br><span class="hljs-string">\maketitle</span><br><span class="hljs-string">\section&#123;你好中国&#125;</span><br>中国在East Asia.<br><span class="hljs-string">\subsection&#123;Hello</span> Beijing&#125;<br>北京是capital <span class="hljs-keyword">of</span> China.<br><span class="hljs-string">\subsubsection&#123;Hello</span> Dongcheng District&#125;<br><span class="hljs-string">\paragraph&#123;Tian&#x27;anmen</span> Square&#125;<br><span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the center <span class="hljs-keyword">of</span> Beijing<br><span class="hljs-string">\subparagraph&#123;Chairman</span> Mao&#125;<br><span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the center <span class="hljs-keyword">of</span> 天安门广场。<br><span class="hljs-string">\subsection&#123;Hello</span> 山东&#125;<br><span class="hljs-string">\paragraph&#123;山东大学&#125;</span> <span class="hljs-keyword">is</span> one <span class="hljs-keyword">of</span> the best university <span class="hljs-keyword">in</span> 山东。<br><span class="hljs-string">\end&#123;document&#125;</span><br></code></pre></div></td></tr></table></figure><br><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828145319.png" alt="20200828145319"></p><h2 id="2-4-插入数学公式、图片或表格"><a href="#2-4-插入数学公式、图片或表格" class="headerlink" title="2.4 插入数学公式、图片或表格"></a>2.4 插入数学公式、图片或表格</h2><h3 id="2-4-1-数学公式插入"><a href="#2-4-1-数学公式插入" class="headerlink" title="2.4.1 数学公式插入"></a>2.4.1 数学公式插入</h3><p>LaTex相对于Word最优秀的地方莫过于他对于数学公式的渲染非常出色，不用我们刻意去调整数学公式的排版，只需要我们输入类似于编程语言的伪代码，系统便可以自己将伪代码转化为我们需要的数学表达。同时大部分的数值计算软件或者编程软件都自带了可以将计算结果转化为TeX语言的函数，甚至可以在Latex系统中嵌入Mathematica进行科学计算，不过这都是进阶内容了。目前姑且还用不到。以上这些足以说明Tex在论文排版中的优越地位！</p><p>数学公式或者图片的插入需要在导言区引用之前提到过的宏包，即：<br><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">\uespackage</span><span class="hljs-template-variable">&#123;amsmath&#125;</span><br></code></pre></div></td></tr></table></figure></p><p>文本中数学公式的引用主要有两种方式：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。</p><ul><li>行内公式：<ul><li><script type="math/tex; mode=display">...</script></li><li><code>\(...\)</code></li><li><code>\begin&#123;math&#125; ... \end&#123;math&#125;</code></li></ul></li><li>行间公式：<ul><li><code>\[ ... \]</code>     （无编号）</li><li>$$$ … $$$     （无编号，会改变行文的默认行间距，不推荐）</li><li><code>\begin&#123;displaymath&#125; ... \end&#123;displaymath&#125;</code>     （无编号）</li><li><code>\begin&#123;equation*&#125; ... \end&#123;equation*&#125;</code>     （无编号）</li><li><code>\begin&#123;equation&#125;...\end&#123;equation&#125;</code>     （有编号）</li></ul></li></ul><p>至于各种数学符号的表达以及特殊字符的控制序列由于太多，不好整理，可以参看<a href="https://blog.csdn.net/GarfieldEr007/article/details/51646604">此处</a>或者<a href="https://blog.csdn.net/lanxuezaipiao/article/details/44341645">这里</a>。</p><h3 id="2-4-2-图片插入"><a href="#2-4-2-图片插入" class="headerlink" title="2.4.2 图片插入"></a>2.4.2 图片插入</h3><p>插入图片的方式比较多，这里推荐上述graphicx宏包中的<code>\includegraphics</code>命令进行操作：</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">\documentclass</span><span class="hljs-template-variable">&#123;article&#125;</span><span class="xml"></span><br><span class="xml">\usepackage</span><span class="hljs-template-variable">&#123;graphicx&#125;</span><span class="xml"></span><br><span class="xml">\begin</span><span class="hljs-template-variable">&#123;document&#125;</span><span class="xml"></span><br><span class="xml">\includegraphics</span><span class="hljs-template-variable">&#123;a.jpg&#125;</span><span class="xml"> % 名为“a.jpg”的文件与TeX源文件同目录</span><br><span class="xml">\end</span><span class="hljs-template-variable">&#123;document&#125;</span><br></code></pre></div></td></tr></table></figure><p>如果图片超过了输出文件的纸张大小，或者效果不太好的时候可以用 <code>\includegraphics</code> 控制序列的可选参数来控制。比如：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">\includegraphics<span class="hljs-selector-attr">[width = .8\textwidth]</span>&#123;<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.jpg</span>&#125;<br></code></pre></div></td></tr></table></figure><p>在<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf">此处</a>可以获取到关于上述宏包的文档。</p><h3 id="2-4-3-表格插入"><a href="#2-4-3-表格插入" class="headerlink" title="2.4.3 表格插入"></a>2.4.3 表格插入</h3><p>tabular 环境提供了最简单的表格功能。它用 \hline 命令表示横线，在列格式中用 | 表示竖线；用 &amp; 来分列，用 \ 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 l、c、r 来表示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://liam.page/2014/09/08/latex-introduction/">[1]</span></a></sup>。</p><p>以下是演示：<br><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;tabular&#125;&#123;|l|c|r|&#125;</span><br> <span class="hljs-string">\hline</span><br>操作系统&amp; 发行版&amp; 编辑器<span class="hljs-string">\\</span><br> <span class="hljs-string">\hline</span><br>Windows &amp; MikTeX &amp; TexMakerX <span class="hljs-string">\\</span><br> <span class="hljs-string">\hline</span><br>Unix/Linux &amp; teTeX &amp; Kile <span class="hljs-string">\\</span><br> <span class="hljs-string">\hline</span><br>Mac OS &amp; MacTeX &amp; TeXShop <span class="hljs-string">\\</span><br> <span class="hljs-string">\hline</span><br>通用&amp; TeX Live &amp; TeXworks <span class="hljs-string">\\</span><br> <span class="hljs-string">\hline</span><br><span class="hljs-string">\end&#123;tabular&#125;</span><br></code></pre></div></td></tr></table></figure><br><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828153609.png" alt="20200828153609"></p><p>有时候我们会遇到表格或者图片的位置不好确定，这个时候我们可以把它们设置为“浮动体”，具体可以参见<a href="https://liam.page/2014/09/08/latex-introduction/#%E6%B5%AE%E5%8A%A8%E4%BD%93">此处</a></p><h1 id="3-版面调整"><a href="#3-版面调整" class="headerlink" title="3. 版面调整"></a>3. 版面调整</h1><p>版面设置一般采用各种宏包进行设置，使用较多的包有：<code>geometry</code>（页边距）、<code>fancyhdr</code>（页眉页脚）、<code>indentfirst</code>（首行缩进）以及<code>setspace</code>（行间距）。一些自带的控制序列也可以用来进行版面设置，比如段间距的设置可以用<code>\parskip</code>调整。</p><p>诸如此类的版面调整的命令由于各位大佬做的宏包太多，加上每个人使用系统或者习惯上的区别，整理起来有很大的困难，最好的办法是边用边学，并且逐渐形成自己的习惯。正所谓熟能生巧，在不断运用的过程中就能够找到最适合自己的哪一种办法，这里提供一些可以达到目的的简单方法。另外提供一下相关方面的博客以供参考。</p><ul><li><a href="https://liam.page/2014/09/08/latex-introduction/#%E7%89%88%E9%9D%A2%E8%AE%BE%E7%BD%AE">一份其实很短的Latex文档——Liam Huang </a></li><li><a href="https://zhuanlan.zhihu.com/p/56405574">LaTeX入门(七)——页面设置——勥巭炛</a></li><li><a href="https://www.jianshu.com/p/da10bc1c497a">17LaTeX学习系列之—-LaTeX的版面设计——张一根</a></li></ul><h1 id="4-参考文献（文档）"><a href="#4-参考文献（文档）" class="headerlink" title="4. 参考文献（文档）"></a>4. 参考文献（文档）</h1><div class="note note-success">            <ol><li><a href="https://liam.page/2014/09/08/latex-introduction/">https://liam.page/2014/09/08/latex-introduction/</a></li><li><a href="http://liuchengxu.org/blog-cn/posts/quick-latex/">http://liuchengxu.org/blog-cn/posts/quick-latex/</a></li><li><a href="http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf">http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf</a></li><li><a href="https://www.jianshu.com/p/da10bc1c497a">https://www.jianshu.com/p/da10bc1c497a</a></li><li><a href="https://zhuanlan.zhihu.com/p/56405574">https://zhuanlan.zhihu.com/p/56405574</a></li></ol>          </div><h1 id="5-补张图"><a href="#5-补张图" class="headerlink" title="5. 补张图"></a>5. 补张图</h1><p>哈哈哈哈哈O(∩_∩)O😎😎😎</p><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/1598496066545.jpeg" alt="1598496066545"><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://liam.page/2014/09/08/latex-introduction/">https://liam.page/2014/09/08/latex-introduction/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://liuchengxu.org/blog-cn/posts/quick-latex/">http://liuchengxu.org/blog-cn/posts/quick-latex/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf">http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.jianshu.com/p/da10bc1c497a">https://www.jianshu.com/p/da10bc1c497a</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjQueDxs73rAhVOqZ4KHSD_BMgQFjACegQIBRAB&amp;url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F56405574&amp;usg=AOvVaw1j3bECgHAB5XTcdABhOEDL">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjQueDxs73rAhVOqZ4KHSD_BMgQFjACegQIBRAB&amp;url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F56405574&amp;usg=AOvVaw1j3bECgHAB5XTcdABhOEDL</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编程</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Latex</tag>
      
      <tag>论文排版</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宫崎骏电影合集(持续更新中......)</title>
    <link href="/2020/07/14/gqj/"/>
    <url>/2020/07/14/gqj/</url>
    
    <content type="html"><![CDATA[<h1 id="充满幻想的作品中热爱的幸福"><a href="#充满幻想的作品中热爱的幸福" class="headerlink" title="充满幻想的作品中热爱的幸福"></a>充满幻想的作品中热爱的幸福</h1><blockquote><div class="note note-info">            <blockquote><p> “创作一部动画也就是创造一个虚拟的世界，这个世界慰藉着那些失去勇气的、与残忍现实搏斗的灵魂。”    ——宫崎骏</p></blockquote>          </div><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/吉卜力动画背景.jpg" alt="吉卜力动画背景"></p></blockquote><p>在日本动漫界无数动画创作者中，有很多优秀的，带有自己强烈的个人色彩的导演，比如庵野秀明、汤浅政明、久米田康治以及新房昭之等等。他们有的作品画风诡异，内涵深刻，有的人作品明嘲暗讽，针砭时政，有的人被称为“爱的战士”，家里的刀片为今后退出动漫界开五金店铺平了道路。然而，在动漫发展到今天，这些风格我们已经见怪不怪了，甚至感到了一些审美疲劳。</p><p>但是有一个人的作品，无论你在什么时候看，都会给人一种强烈的感动，浓浓的温馨，出动人们心底最原始的悸动。童年开始便伴随我们成长（<span class="heimu" >还记得当初上高一的时候找同学借的手机回家，半夜爬起来偷偷蹲在角落蹭楼下的WiFi看电影的那种激动感 </span>），长大之后更教会我们热爱生活，这个世界上除他之外再也找不出第二个人能创作出如此美好的动画。每个人都不得不承认宫崎骏是这个世界上最能抓住我们内心最柔软地方的人，看他的作品的时候是平静的，但是这种平静中还蕴含着对生命，对生活的热爱，让人感到这世界上的一切都是那么的自然，相较起来那些黑暗绝望的角落在这份自然面前倒显得无所谓了。</p><p>为了重温那些可能已经淡忘的感动，在女朋友的提醒下，我决定在浩如烟海的网络中找到宫崎骏老爷子所有的电影，并放到自己的网盘上。希望自己还有满怀希望的所有人都可以保持看完电影的之后感受到的老爷子传达给我们的，<strong>对于我们所生活的世界的希望和幸福感</strong>！</p><h1 id="1-借东西的小人阿埃丽缇"><a href="#1-借东西的小人阿埃丽缇" class="headerlink" title="1.借东西的小人阿埃丽缇"></a>1.借东西的小人阿埃丽缇</h1><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/艾莉缇.jpg" alt="艾莉缇"></p><div class="note note-light">            <p>这是宫崎骏作品里面我女朋友最喜欢的一部（<span class="heimu">应该是这样的吧hahaha，不知道是千与千寻多一点还是这个多一点。</span>）。对我来讲当初看完之后感慨万千，片尾艾莉缇他们离开那么漂亮温馨的家（那个房子真的爱了爱了！❤😍）准备去其他的新的地方生存，站在茶壶中回望曾经生活的地方和男主告别时，让我有种长大离开家乡去很远很远的地方，以往那些快乐美好的日子全部成为了有可能被淡忘记忆的伤感。也让我联想到《猫武士》（英国儿童文学作品，非常推荐！）中那个猫离开故土去新月山谷经过山坡时候的场景，那是我第一次对世界之外产生强烈憧憬，又对故土产生无限眷恋的时刻。另外男主和艾莉缇不能在一起（虽然知道不可能，但还是好难受）我真的意难平！—— <em>“Tabris Trees Severus”</em></p>          </div><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/艾莉缇的房子.jpg" alt="艾莉缇的房子"></p><h1 id="2-天空之城"><a href="#2-天空之城" class="headerlink" title="2.天空之城"></a>2.天空之城</h1><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/希达.gif" alt="希达"></p><div class="note note-light">            <p>异世界的故事总是让我兴趣盎然，宫崎骏的很多动漫都有这种设定，这也是我喜欢他的一部分原因。天空之城就好像一个童话故事，希达是天空之城遗落的公主，巴斯就是是勇敢的骑士，他们一起寻找天空之城并打败了坏人，最后幸福的生活在一起（童话故事标准结局(≧ω≦)/）。</p><p>希达扎着两根长长的辫子，蓝色的长裙子，看起来好温柔好舒服，里面惊险的战斗场景也是宫崎骏动漫里面难得的场面，天空之城安静的像世外桃源，自然美丽的环境，还有许多远古生物，和激烈的战斗形成鲜明对比。最后为了阻止了更惨烈战争的爆发，希达毁灭了天空之城，这样一个美好的世界就这样消失了……但是，这警示我们要珍惜现在美丽的地球，千万不要让它被战争毁灭了！宫崎骏真的很热爱和平呢！哈哈（∩△∩）❤永远喜欢❤！  —— <em>“艾莉缇”</em></p>          </div><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/QQ图片20200715092901.jpg" alt="QQ图片20200715092901"></p><h1 id="3-悬崖上的金鱼姬"><a href="#3-悬崖上的金鱼姬" class="headerlink" title="3.悬崖上的金鱼姬"></a>3.悬崖上的金鱼姬</h1><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/89B14785A06910E5ECB8A46B32E5DD91.png" alt="89B14785A06910E5ECB8A46B32E5DD91"></p><div class="note note-light">            <p>之前我听过很多宫崎骏的电影，我却只看过《哈尔的移动城堡》，实际上我这个人不太喜欢看动漫，很需要机缘，所以看《悬崖上的金鱼姬》的机缘是因为高三的音乐课，宫崎骏和久石让的合作有很多，金鱼姬的电影里就有很多好听的音乐【原谅我比较俗，只能用简单的“好听”来形容音乐】，所以老师就上课的时候放给我们看了。一节课45分钟，看了三个礼拜吧，高中除了学习之外的事情还真不多，反而这音乐课放的电影让我印象颇深。</p><p>《悬崖上的金鱼姬》画面真的很美，宫崎骏的每一个动漫画面都美，最令我印象深刻的就是里面的食物了，看着就太香啦~【原谅我是个吃货，太生动形象了】</p><p> “波妞，喜欢宗介。”这句话虽然被抖音玩烂了，但是里面包含了小孩子之间很纯粹的喜欢，每次听到都会莞尔，毕竟这种喜欢对于不再是孩提的我，还是很珍贵的。剧里的每一位角色都很善良，那位看起来是反派的老爸也很善良，初心是为了保护波妞呀【妥妥女儿奴了】。这真是一部很美好的电影。电影结局很美好，但这部动漫更深层的含义就是呼吁人们保护海洋了，确实应该人人有责，很多循环后遭殃的还是人类。那就写到这里吧，宫崎骏的电影很值得看。——<em>“微封”</em></p>          </div><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/CE6198FAB518A44FFC426E88C7F3A38E.png" alt="CE6198FAB518A44FFC426E88C7F3A38E"></p><h1 id="4-侧耳倾听"><a href="#4-侧耳倾听" class="headerlink" title="4.侧耳倾听"></a>4.侧耳倾听</h1><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/3b9b918e7d601606cea47dec3059a495.gif" alt="3b9b918e7d601606cea47dec3059a495"></p><div class="note note-light">            <p>相比保卫蓝天 守护家园 拯救世界 有时候生活中的小美好反而让我更为感动<br>侧耳倾听 在看完整部电影之后 我觉得这个名字好美啊 它的内容其实更加的贴近生活话 描述的是男女主角互相勉励互相学习 为各自的理想而奋斗 然后男女主相爱的故事 听起来很像偶像剧 但是它却没有那种俗气</p><p>“我早就想好了，要这样载着你，翻山越岭”</p><p>“我不要成为你的包袱，我也早就想好了，要在背后支持你”</p><p>这部电影里我最爱的两句话<br>之前和朋友聊起这部电影，记得自己说过：哈这么小就谈恋爱啊 不太好吧<br>有时候看一部电影最怕的就是真的将自己代入进去  高三好像自己喜欢上一个女孩子 自己也没想到会在那么不合宜的时间有不合适的想法 脑子里一直在打消那些念头 可是上课偶尔还是想回头望望 就好像自己一直在等她一样 她是班上新来的复读生 自己一有什么东西就想和她分享 一个解题思路 或者自己认识的一个有趣的单词<br>自己总会有无限的热情去找她 站在那里等她<br>可是其实好像她并不喜欢这样子 忘记发生了什么事 在我转头回去找她的时候 她突然凶着对我说了一句：我没有这么多时间可以浪费 也许你轻而易举就能碰的东西 我要努力好久<br>好像其实那一刻自己有一点明白侧耳倾听描述的是什么 又好像突然一切也不符合我自己<br>现在看侧耳倾听其实多的是带了自己心中的那份遗憾去欣赏一个特别特别美妙的故事<br>也许一直不会发生<br>虽然有时候觉得这个电影和这件事没多大关系 但是自己一提到这部电影就会想起这件事<br>也许自己那份遗憾在这部电影中得以满足</p><p>可是这么美好的一部电影也会因为一句台词毁掉<br>所以请不要看最后一点 也不要听那句<br>你将来愿意嫁给我吗？<br>可能我提会不到这句话的浪漫。——<em>“初见”</em></p>          </div><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/5409b8cd83d8222544dd29a63c96f734.png" alt="5409b8cd83d8222544dd29a63c96f734"></p><h1 id="电影下载地址"><a href="#电影下载地址" class="headerlink" title="电影下载地址"></a>电影下载地址</h1><p>可在线播放,但是由于网速限制等问题,建议下载之后播放,用云盘中软件文件夹下的potplayer播放器就不存在字幕的问题。(云盘服务器到期没续费，文件全部丢到了，没办法，估计是看不到了。)</p><div class="note note-success">            <p><a class="btn" href="https://zfile.tabirstrees.top/#/3/main/%E7%94%B5%E5%BD%B1/%E5%AE%AB%E5%B4%8E%E9%AA%8F%E5%90%88%E9%9B%86/%E5%80%9F%E4%B8%9C%E8%A5%BF%E7%9A%84%E5%B0%8F%E4%BA%BA%E8%89%BE%E8%8E%89%E7%BC%87"  title="点击我去往放电影的地方！" target="_blank">借东西的小人阿埃丽缇</a> <a class="btn" href="https://zfile.tabirstrees.top/#/3/main/%E7%94%B5%E5%BD%B1/%E5%AE%AB%E5%B4%8E%E9%AA%8F%E5%90%88%E9%9B%86/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E"  title="点击我去往放电影的地方" target="_blank">天空之城</a> <a class="btn" href="https://zfile.tabirstrees.top/#/3/main/%E7%94%B5%E5%BD%B1/%E5%AE%AB%E5%B4%8E%E9%AA%8F%E5%90%88%E9%9B%86/%E6%82%AC%E5%B4%96%E4%B8%8A%E7%9A%84%E9%87%91%E9%B1%BC%E5%A7%AC"  title="点击我去往放电影的地方" target="_blank">悬崖上的金鱼姬</a> <a class="btn" href="https://zfile.tabirstrees.top/#/3/main/%E7%94%B5%E5%BD%B1/%E5%AE%AB%E5%B4%8E%E9%AA%8F%E5%90%88%E9%9B%86/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC"  title="点击我去往放电影的地方" target="_blank">侧耳倾听</a></p>          </div>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
      <category>动漫</category>
      
      <category>宫崎骏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动漫</tag>
      
      <tag>童话</tag>
      
      <tag>宫崎骏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+fluid主题添加二级导航</title>
    <link href="/2020/05/14/hexo-fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%BA%8C%E7%BA%A7%E5%AF%BC%E8%88%AA/"/>
    <url>/2020/05/14/hexo-fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%BA%8C%E7%BA%A7%E5%AF%BC%E8%88%AA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/6418A1E7501871AF561B89A22AB13D3F.png" alt="6418A1E7501871AF561B89A22AB13D3F"></p><hr><div class="note note-info">            <p>使用hexo博客的fluid主题已经有一段时间了，因为打算写的内容很杂，所从很早开始就想要做一个二级导航出来，这段时间一直在折腾这个东西！前几天给网站加上了豆瓣的📕书评和🎦电影栏目，发现这样要是以后再加点什么东西导航栏就放不下了。所以痛定思痛决定开始弄二级导航（<del>鬼知道我为了做这个东西连即将要到来的考试和难到爆炸的课程设计都不管了</del>）</p>          </div><h1 id="开始搞事情😄O-∩-∩-O"><a href="#开始搞事情😄O-∩-∩-O" class="headerlink" title="开始搞事情😄O(∩_∩)O"></a>开始搞事情😄O(∩_∩)O</h1><p>emmmmm，首先<del>其实差不多只有这一步啦</del>我们要做的就是更改文章生成的模板，fluid主题的话就打开主题目录下的<code>layout</code>文件夹中的<code>nav.ejs</code>文件，修改为如下的样式（其中注释的位置就是修改的主要位置，也是导航栏内容所在，你也可以按照自己的想法修改这个地方的内容）：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;navbar&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-brand&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%- url_for() %&gt;&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>&lt;%- theme.navbar.blog_title || config.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;navbar-toggler-btn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-toggler&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">&quot;collapse&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">data-target</span>=<span class="hljs-string">&quot;#navbarSupportedContent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">aria-controls</span>=<span class="hljs-string">&quot;navbarSupportedContent&quot;</span> <span class="hljs-attr">aria-expanded</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;Toggle navigation&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;animated-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Collapsible content --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;collapse navbar-collapse&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;navbarSupportedContent&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar-nav ml-auto text-center&quot;</span>&gt;</span><br>        &lt;% for(const each of theme.navbar.menu) &#123; %&gt;<br>          &lt;% if (!each.link) continue %&gt;<br>          &lt;% var text = each.name || __(each.key + &#x27;.title&#x27;) %&gt;<br>          &lt;% if (text.indexOf(&#x27;.title&#x27;) !== -1) &#123;<br>            text = each.key<br>          &#125; %&gt;<br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= url_for(each.link) %&gt;&quot;</span>&gt;</span><br>              &lt;%- each.icon ? &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#x27; + each.icon + &#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#x27; : &#x27;&#x27; %&gt;<br>              &lt;%- text %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!--以上的部分是一级导航的部分--&gt;</span><br>              <span class="hljs-comment">&lt;!--这里判断有没有二级菜单，有的话遍历出二级菜单（就是竖着的那部分）--&gt;</span><br>              &lt;% if (each.submenu) &#123; %&gt;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sub-menu&quot;</span>&gt;</span><br>                  <span class="hljs-comment">&lt;!--//遍历出二级菜单（就是竖着的那部分）--&gt;</span><br>                  &lt;% for (const submenu of each.submenu)&#123; %&gt;<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                      <span class="hljs-comment">&lt;!--//a标签里当然是输出二级菜单的路径咯--&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%- url_for(submenu.link) %&gt;&quot;</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--//i标签里输出二级菜单的icon的class咯--&gt;</span><br>                        &lt;%- each.icon ? &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&#x27; + submenu.icon + &#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#x27; : &#x27;&#x27; %&gt;<br>                        <span class="hljs-comment">&lt;!--//这里输出二级菜单名咯--&gt;</span><br>                        &lt;%= submenu.key %&gt;<br>                      <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                  &lt;% &#125; %&gt;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>              &lt;% &#125; %&gt;<br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &lt;% &#125; %&gt;<br>        &lt;% if(theme.search.enable) &#123; %&gt;<br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search-btn&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">&quot;modal&quot;</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">&quot;#modalSearch&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-search&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &lt;% &#125; %&gt;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="修改css配置，让它好看点"><a href="#修改css配置，让它好看点" class="headerlink" title="修改css配置，让它好看点"></a>修改css配置，让它好看点</h1><p>如果不修改css配置其实也是可以的，只不过很丑就对了。</p><p>所以我们打开主题目录下<code>source/css/mian.styl</code>，本来应该在子项对应的部分添加，但是考虑到（<del>好吧，╮(╯-╰)╭，其实是我懒</del>）慢慢找实在是太麻烦了，所以我们直接在main文件里添加（这部分你可以先<code>hexo s</code>打开浏览器进行调试到你喜欢的样式，然后再复制相应的样式表到文件中）如下代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.sub-menu</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">8px</span> <span class="hljs-number">16px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);<br>    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">width</span>: auto;<br>    <span class="hljs-attribute">height</span>: auto;<br>    <span class="hljs-attribute">box-shadow</span>: -<span class="hljs-number">6px</span> <span class="hljs-number">6px</span> <span class="hljs-number">8px</span> black;<br>&#125;<br>// 以上是控制二级菜单呼出的形式<br><br><span class="hljs-selector-class">.sub-menu</span> <span class="hljs-selector-class">.li</span> &#123;<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.nav-item</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.sub-menu</span> &#123;<br>    <span class="hljs-attribute">display</span>: block;<br>&#125;<br>// 控制鼠标停留在一级菜单上时呼出二级菜单<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.nav-item</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">15px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样我们的基本的配置就算是完成了，接下来就是二级菜单的写法！</p><h1 id="配置文件中二级菜单的写法"><a href="#配置文件中二级菜单的写法" class="headerlink" title="配置文件中二级菜单的写法"></a>配置文件中二级菜单的写法</h1><p>打开主题配置文件<code>fluid_config.yml</code>，在菜单部分以“<em>分类</em>”菜单为例我们做如下的改动<br>submenu指定二级菜单，和一级菜单类似，<strong>最后用[]括起来！！！</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span>  <span class="hljs-comment"># 导航栏左侧的标题，为空则按 hexo config.title 显示</span><br>  <span class="hljs-attr">menu:</span>  <span class="hljs-comment"># 可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称；submenu指定二级菜单，和一级菜单类似，最后用[]括起来！！！</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-home-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;archive&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/archives/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-archive-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;category&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-category-fill&#x27;</span>, <span class="hljs-attr">submenu:</span> [<br>      &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;全部&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/categories/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;icofont-abc&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;生活&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/categories/生活/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;icofont-love&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;🖊笔记&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/categories/笔记/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;icofont-notebook&#x27;</span> &#125;<br>    ]&#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;tag&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/tags/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-tags-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/about/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-user-fill&#x27;</span> &#125;<br>    <span class="hljs-comment">#- &#123; key: &#x27;links&#x27;, link: &#x27;/links/&#x27;, icon: &#x27;iconfont icon-link-fill&#x27; &#125; # 友链页，把前面#去掉即可展示</span><br></code></pre></div></td></tr></table></figure><p>这样我们就完成了一个主题的二级导航自定义，当然这样其实还是不太好看，可以自己用css进行调整。此外，针对不同的主题配置<code>config.yml</code>的不同写法情况，其实都是大同小异的，<a href="https://www.hojun.cn/2019/01/08/ck8irvkwx009qdwtu8ejla2mg/">可以点我去往某个大佬的空间看看，以作参考！！！&lt;(￣︶￣)↗[GO!]</a>。</p><p>以我的网站为例最终实现就是这样的效果：<br><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200514170113.png" alt="20200514170113"><br><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200514170146.png" alt="20200514170146"></p><p>哈哈哈哈，我觉得还是可以的！！！😁😁😁<br><div class="note note-success">            <p>参考：</p><p>yaml基本语法及实现Hexo二级导航栏功能<a href="https://www.hojun.cn/2019/01/08/ck8irvkwx009qdwtu8ejla2mg/">https://www.hojun.cn/2019/01/08/ck8irvkwx009qdwtu8ejla2mg/</a></p><p>为博客网站增加一个二级目录菜单<a href="https://sunhwee.com/posts/65d7181d.html">https://sunhwee.com/posts/65d7181d.html</a></p><p>如何通过html和css完成下拉菜单的制作？<a href="https://www.zhihu.com/question/36356940">https://www.zhihu.com/question/36356940</a></p><p>and so on ……</p>          </div></p>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>something I won&#39;t talk at almost time</title>
    <link href="/2020/04/28/me/"/>
    <url>/2020/04/28/me/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200428233849.png" alt="img_0183"></p><p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200428233946.jpg" alt="img_0156"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>想法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>放逐者</title>
    <link href="/2020/04/14/%E6%94%BE%E9%80%90%E8%80%85/"/>
    <url>/2020/04/14/%E6%94%BE%E9%80%90%E8%80%85/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>无垠的宇宙仿佛一块巨大的黑色天鹅绒，闪烁的群星变作天鹅绒上美丽的宝石，熠熠生辉的黑暗间一道明亮的轨迹插入！一艘“放逐者”号的小型探索式宇宙飞船在宇宙中已经航行了十年零四个月！</p>          </div><p>“你觉得真的有神存在吗？”</p><p> “这话是什么意思？”</p><p> “我最近老是觉得有种被人监视的感觉，可是又找不出来到底是谁在监视！我有点害怕！”</p><p> “你怕是最近忙晕了吧，脑子出问题了？”</p><p> “我没和你开玩笑！我真的有这种感觉，当我一个人独处的时候就尤为强烈！一开始我也没当回事，可是直到最近发生了那件事，我就确定了我的感觉是真的！”</p><p> “什么事？最近到底发生了什么？你可不要乱来我们这是在太空中，就我们两人，出了事可不会有人来救我们的！”</p><p> “我知道！我没干什么，只是……，你知道的！就我那间实验室，我在我们开始这趟旅程的时候在一个培养基里培育了当时的一种新型细菌，就是为我们生产食物的那种！”</p><p> “我知道，有什么问题吗？”</p><p> “就在几天前，我在培养基的外围发现了一些经过变异的细菌，你不觉得奇怪吗？按照道理来说，它们离开了培养基中间的营养物质就基本无法存活的啊！可现在的情况看上去是他们在争先恐后的往外面爬！”</p><p> “嗯？你为什么说‘争先恐后’？”</p><p> “因为一发现这件事后我就清除了外围的细菌，可是第二天我再去看的时候又出现了这种情况，如果说前面一次是偶然，那这一次又算什么？接下来的几天里，我每天都重复地清理，但每天都会有新的细菌在培养基外出现，而且数量还越来越多！再这样下去，我的培养基就快要空了！”</p><p> “呃，是有些奇怪！不过这也说不了什么吧！折和你感觉被人监视有什么关系吗？”</p><p> “问题在于在此之前我的这种感觉都还是极其轻微的，但从那天起，我几乎每天都会梦到同一件事情！”</p><p> “啥玩意儿！梦到同一件什么事情？”</p><p> “我总是梦到自己似乎在一个实验室里。作为观察者观察一个我也说不上来是什么的东西，嗯，等等！气泡！对，那东西就像是气泡！不，应该是类似于气泡的膜！”</p><p> “这有什么奇怪的，你想多了吧！”</p><p> “不，重点在于气泡里面的东西！”</p><p> “哈哈哈，里面有什么不得了的东西吗？连你都会害怕？”</p><p> “你在梦里看见你自己是什么感受？”</p><p> “你什么意思？”</p><p> “我看到的！气泡里面是宇宙，虽然看上去很小，但是你却可以感觉到那种没有边界，无法逃离的无垠感！还有很多好看的闪闪发光的星星，就像是天鹅绒上面的宝石！我们的飞船就这样在天鹅绒上“滑行着”，我还看见了你我的脸！每当此时我都会惊醒！”</p><p> “哈哈哈，你逗我吗？这哪里奇怪了？你是不是这几天太累了，这么多年的航行确实很枯燥啊！你可不要在这个时候出岔子，我看你这几天精神状态很不稳定！要不接下来的几天就由我来做全部的工作吧，你先休息几天？”</p><p> “你什么意思？你觉得我在开玩笑？我精神好得很！你难道没注意到吗？那些细菌！那些到外围的细菌！不就是我们吗？我们向宇宙外围飞了这么久！你没有想过我们为什么要这个方向一直飞？我们到底再找个什么东西？还是说我们只是吃饱了撑的到处转转而已！？”</p><p> “你说什么呢？我们不是为了探索宇宙来的吗？你不是要研究宇宙的形成的吗？这不就是我们的目的吗？你不知道我们在干什么？那这些年我们传回地球的数据是什么？你现在说这些话才是“吃饱了撑的吧”！”</p><p> “很好，我来告诉你那些数据有什么意义！我们的世界，不，应该说是我们的宇宙是由更高维度的生命创造出来研究他们自身演化历程的！他们为了弄清楚自身的存在，构建了‘宇宙’这个模型来观察生命的诞生与进化，就像是我们研究细菌那样，它们准备很多个培养基，也就是宇宙！但仅仅只有少数的宇宙诞生了生命，更少的宇宙中生命诞生了文明！我们是被自然选择出来的幸运儿，然而这仍然改变不来我们存在价值就是被观察，被记录的事实！我们将会是他们最宝贵的研究材料，当你的研究材料想要逃离你给他们的用来观察的器皿时你会怎么做？如果是我，就像我之前做的那样，我的第一反应是清除！决不能让他们破坏了实验材料的稳定，要知道这可是亿万分之一概率才会出现的奇迹，说什么我都不会让机会丢失的！另外，你忘了一件事，我们最重要的使命不是了解宇宙的形成，而是弄清楚宇宙到底是什么样的！我们的航线一开始就是设定好的，从离开地球开始我们就一直朝着一个方向在前进！反正我们对于那些‘掌权者’根本不重要，当时选中我们来做这次航行就是为了不让我们参与地球的事务，亏我们还激动万分的为自己将成为第一批作超过太阳系的星际航行的人而骄傲！他们一开始就是决定好的不让我们回去，而且航线对于宇宙这种每个方向看起来根本就差不多的东西根本没什么意义！所以，我们只是被利用来寻求可能存在的宇宙的边界的！但是你去看看这些年的数据，你没有发现我们所在的这个宇宙越来越像是一个‘膜’了吗？你还记得很多年前的‘膜理论’吗？你再想想所谓的‘分形宇宙’的看法！我绝对不会相信你没有经历过被监视的感受！我们作为实验对象却正在试图逃出这个‘实验器皿’！你觉得我们前面将会遇到什么？嗯？我们就快要被抹除掉了！”</p><p>… …沉默！</p><p> “你疯了！”</p><p> “呵呵！也许吧！我知道你觉得我说的有理，你无法反驳我！你只是不愿意接受人类悲惨的现实，我们在我们所认为的世界里相互争夺，相互欺骗，相互之间勾心斗角，明争暗斗！到头来只是别人的研究材料，只是想想可能性就觉得可悲可笑！呵呵呵~！”</p><p> “你够了，即使你是对的！我们作为人类只是别人的实验材料，但是当我们诞生出智慧，催生出思想的那一刻起，我们就有了存在的价值，有了灵性！从我们文明诞生伊始我们就是和你所说的更高等的生命是平等的！他们有的东西我们同样是拥有的，我们有作为实验品的可能他们也绝不会排除在外！这个世界上，除了你所说的阴暗面也还有着很多美好的东西！为什么你没有看见这些东西？你没有看见爱，看见追求，看见苦难中那些难能可贵，熠熠生辉的品质？我可以这样给你说：无论地球上的那些人是不是想要将我永久的放逐，我都为自己所正在做的事情感到骄傲，因为我是在为整个人类文明存在做出贡献！我知道长期以来无聊的旅程有多么地折磨一个人的意志！我建议你还是休息吧！现在真正危险的是你，你自己心里也清楚的，在这种长期的孤独状态下是很容易疯掉的！我还不想失去你这个我现在唯一可以说话人！所以你最好是赶快给我想清楚！如果有一天你真的疯了，我会毫不犹豫的杀了你，你知道我会的！”</p><p> “… …你就是这样的人，我知道，你会的！我现在累了，想睡一会了。我会考虑你说的话，再见。”</p><p> 他起身。快速的，低着头，回房去了！看不见他脸上的表情，但是你仍可以感觉到他在发抖！</p><p> “唉~！”</p><p> 剩下来的一个人叹气，面无表情！他知道，至少某些人为的既定事实是大家都心知肚明的，只是他不愿意提起！现在，他就这样坐在那里！</p><p> 不一会，他也起身，记录下探测仪上的数据并传回给遥远的地球，他知道地球有和飞船仪器同步的记录设备作为备份，但还是每天会亲自己记录一遍再传回到地球的数据中心，这是他唯一感觉到与那颗遥远星球还存在着联系的时刻，十多年来，地球与这艘飞船的通讯仅仅只有这冰冷的数据，也只有在这时候他的内心才是最平静的。</p><p> 但是最近的数据似乎越来越奇怪了，所有的数据都在显示飞船附近暗物质密度正在随着航行深入急剧增加着，这意味着飞船承受的引力也会随之加大。飞船似乎正在穿越一个临界带。</p><p> 数据传回地球后，他回到了自己的房间，沉沉睡去，睡着前他在想不知道他的梦里会不会也出现自己！</p><p>“放逐者”仍然在天鹅绒上缓缓前行着。天鹅绒的黑色似乎愈发的深厚了，上面流光的宝石也变得越来越少，到最后也许只会剩下那永无止尽的黑色吧！此刻的地球，数据中心的工作人员发现一直正常连接并同步状态的“放逐者”在发出数据的那一刻，就那一瞬间，完完全全的失去了信号！人们再也无法了解到这个伟大的“放逐者”身上到底发生了什么，只知道它失联之前的所有数据都是正常的并且现阶段来说相当具有研究意义的！几天之后，数据中心将其被黑洞吞噬的消息外放，从此它连同它上面的人真正意义上的被放逐。也许多年以后，新的“放逐者”会找到“他们”的残骸！<br><div class="note note-success">            <p>——end——</p>          </div></p>]]></content>
    
    
    <categories>
      
      <category>创作</category>
      
      <category>小说</category>
      
      <category>科幻</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
      <tag>自己写的</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达机器学习——梯度下降法</title>
    <link href="/2020/02/04/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A021/"/>
    <url>/2020/02/04/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A021/</url>
    
    <content type="html"><![CDATA[<p>太惨了，因为七牛云的域名关系，这个内容里面的图片暂时无法访问了，现在有没有时间去弄这些东西，这能暂时搁置，后面有时间的话再把那些图片找回来，目前的图片已经转移到腾讯云上来了，后面应该是都可以访问的！！！</p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>之前老师让我们去看机器学习的内容,找到了网上普遍推荐的吴恩达老师的机器学习视频,在Coursrea上看了一点点,后面因为网络问题(<del>大家都知道,大天朝的高墙永远耸立</del>)放弃扔那儿了,最近几天新冠病毒肆虐,在家闲的无聊又不想看考研的东西,也不想写论文(<del>真不是我不想,但是我懒</del>)就把它重新拿出来看了。并且看了各位大佬的blog之后深觉挫败，想要把自己也伪装成一个大佬，所以写了这篇文章。有什么问题可以留言哦！！<code>\(^o^)/</code><br><span id="more"></span></p><h1 id="关于机器学习算法的分类"><a href="#关于机器学习算法的分类" class="headerlink" title="关于机器学习算法的分类"></a>关于机器学习算法的分类</h1><p>目前来说较为明确的分类是:</p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>需要预先准备已经有正确结果的数据对模型进行优化调整</p><ul><li>回归</li><li>分类</li></ul><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><p>没有预先准备好的数据集,通过对数据内部结构的挖掘找出各数据间的关系来达到预定目标</p><ul><li>聚类</li><li>分离异常值(<a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E4%BC%9A%E6%95%88%E5%BA%94">鸡尾酒聚会效应</a>)</li></ul><h1 id="第一个算法-单变量线性回归"><a href="#第一个算法-单变量线性回归" class="headerlink" title="第一个算法:单变量线性回归"></a>第一个算法:单变量线性回归</h1><p>回归也就是我们通常用到的拟合,在实际的科研当中,很多时候回需要对我们得到的数据进行处理,用一个函数/曲线来拟合数据间的关系。实现这个拟合过程的算法就叫做回归算法<br><strong>单变量线性回归</strong>(Linear Regression with one Variable)指的是只有一个变量的回归过程,是线性回归里面最简单的,也是整个机器学习中最简单的算法之一(学过高中数学的应该都能理解她的含义,所以这里不过的赘述)</p><h2 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h2><p>我们假设y(我们想要的结果)和x(我们所有的数据)之间具有如下的关系:</p><p>$model:  y = \theta<em>0+\theta_1x=h</em>\theta(x)$ $\theta_i$指的是模型的参数<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_25212f5fb2b83b0478db932c17fe3de7" alt="机器学习模型示意图"></p><h2 id="构建代价函数"><a href="#构建代价函数" class="headerlink" title="构建代价函数"></a>构建代价函数</h2><p>模型建立好后，需要对参数进行调整，调整参数的过程一般来说是用另外的一个算法/模型来确定什么参数是最适合的(就像是直接将所有有可能适合的参数带入模型,然后将预测结果和正确的结果作对比,结果高度吻合的参数就是最优参数),我们把这个算法(函数)叫做<strong>代价函数</strong>(cost function),也通常翻译为损失函数</p><p>最常用的代价函数算法是<strong>平方差</strong>(Squared error function)<strong>方法</strong>,也就是最小二乘法;它的原理是:预测的结果和实际的结果差值最小时的参数是最好的参数(<a href="https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95#4">可以在这里找到关于该方法的具体定义</a>),我们这里采用的算法和最基础的算法不一样,只是在该原理上优化,采用数据集中所有数据的平均平方差最小作为最终的代价函数</p><p>$cost\ function :  J(\theta<em>0,\theta_1)=\dfrac{1}{2m}\sum\limits</em>{i=0}^m(h_\theta(x_i)-y_i)^2$<br>$J(\theta_0,\theta_1)$用以表示cost function<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_f5b0fd9fd99854069b00a3b660c304a5" alt="cost function"><br>我把官方给的资料贴出来,可以点进去之后放大查看!</p><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>我们现在的目的是调整$\theta_0,\theta_1$的值,使得我们的代价函数的值最小,这个时候的$\theta_0,\theta_1$就是最适合的模型参数<br>我们的思路是:</p><ul><li>start with some $\theta_0,\theta_1$</li><li>keep changing $\theta_0,\theta_1$ to reduce $J(\theta_0,\theta_1)$ until we hopefully end up at a minimum</li></ul><p>我们这里采用<strong>梯度下降算法</strong>(Gradient descent algorithm)来解决这个问题(<a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">点击我去往”梯度下降法”的百度页</a>)<br>通俗的来讲就是:</p><blockquote><p>假设你现在在一座山上的某一个位置,突然有急事需要你以最快 的速度赶到山下(最低的位置)。梯度下降算法要求你在当前位置找到坡最陡的方向,沿着这个方向走一段路程到达下一个点(不考虑你是否真的能够从那个地方走,就假如你会飞吧!)。在这个点又重复上面一样的做法,直到最低的位置(至于我们怎么知道某个位置就是最低的位置,在后面会讲到,梯度下降法不需要我们考虑这个问题)</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/68/Gradient_ascent_%28surface%29.png" alt="梯度下降法的三维图像表示"></p></blockquote><h3 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h3><p>我们将梯度下降法的数学表达写成下面的形式:</p><p>$repeat\ until\ convergence{\ \theta_j:=\theta_j-\alpha\frac{\partial}{\partial \theta_j}J(\theta_0,\theta_1)\ $,<br>$for\  j=0\ and\ j=1}$</p><p>其中$\alpha$指的是学习效率,相当于你下山的时候每一步所跨的距离<br>值得我们注意的是,这里的 $:=$ 表示的是赋值操作,即把运算所得的值还给原来的变量，学过程序设计的同学应该都知道的。但是这里的$\theta_0,\theta_1$需要同时赋值(在本文所讲的单变量线性回归当中是这样的,也有其他的算法不是同时赋值的)</p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p>我们可以看到在我们的算法使用了参数减去该参数的偏导数来进行梯度的下降,我们现在来解释为什么我们要使用这样的方法(或者说这个方法有什么样的特征)</p><h4 id="关于-alpha"><a href="#关于-alpha" class="headerlink" title="关于$\alpha$"></a>关于$\alpha$</h4><p>对于单个参数的代价函数$J(\theta)$,有:<br>$\theta := \theta-\alpha\frac{\partial}{\partial\theta}J(\theta)$</p><p>如果$\alpha$太小的话,$\theta$收敛的速度将会很慢(对应你下山的速度很慢,等你到的时候人家都已经解决完所有的事情了,要你有何用?)<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_cf39a956dd8e19a9c13e604da18086b2" alt="a小"><br>如果$\alpha$太大的话,$\theta$将会有可能直接跳过最适合的值(对应你跑太快没注意其实你已经过了你要去的地方)<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_e9e557d0d03daf75c9a1842ca53a3278" alt="a大"></p><h4 id="关于初始点"><a href="#关于初始点" class="headerlink" title="关于初始点"></a>关于初始点</h4><p>如果初始点在最小点的左边,$\theta$的传递将会使得$\theta$向右边移动,从而趋向最小点($\alpha$将会乘以一个负数,即$\theta$将会减去一个负数)<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_c24250417de5ef186514c6ec53f5149b" alt="init左"><br>同理有:初始点在最小点右边时,$\theta$将会向左边移动,从而趋向最小点<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_230b8fc028714b56ce423eb36c6de4ac" alt="init右"><br>在梯度下降的过程中,$\theta$的值不断变化,$\frac{\partial}{\partial\theta}J(\theta)$的值也在不断变化,以下图举例来说,这个偏微分的值是在逐渐减小的(必定是这样的,因为你要取得的值是导数为0的最小值,<strong>如果函数处处连续可导,则必然趋向最小点的过程中导数的绝对值是在减小的</strong>)<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_50ba003760c1fe93a86e4bca9376b0df" alt="导数减小"></p><h4 id="关于最优解"><a href="#关于最优解" class="headerlink" title="关于最优解"></a>关于最优解</h4><p>当我们的$\theta$到达最小值时,偏导数就变为零了,这个时候式子就变成了:<br>$\theta=\theta-\alpha(0)=\theta$<br>$\theta$就已经收敛到这个位置不再变化,即使在整个函数中还有更小的值,但是我们的算法已经不想动了。也就是梯度下降法实际上只能找到局部最优解,(你可以这么理解,你下山其实是为了喝水,而只要有一个窝窝(导数为零)在就有水的存在,所以你就不用去找整座山最低的地方)<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_6c4df1ddaf629e5d741ccb91965678cb" alt="局部最优"><br>事实上,在我们的线性回归当中,代价函数一般来说是不会像上图中那样有很多个极值点(导数为零),基本都只有一个也就是最小点,所以我们的局部最优解其实就是全局最优解。所以在本文的问题中,该算法是比较合理的!</p><p>如果你想对梯度下降法有更进一步的了解,或者还不是很理解你可以<a href="https://zhuanlan.zhihu.com/p/36902908">点击我O(∩_∩)O哈哈~</a><br>要不然你就自己上网搜!!!!!!网上很多大佬厉害着呢!</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>上面我们已经建立好了模型和算法,剩下的事就是将算法转变为代码<br>然而我在写这篇文章的时候花了很多时间,因为我在没有配置好的情况下使用了latex格式的数学公式,导致了非常多的bug。<br><img src="http://q532jr91q.bkt.clouddn.com/blogpic_8b2a6b0700feb1a4cdd03591e93a4fd2" alt="bug">而作为菜鸡的我对此简直是焦麻了！<code>~~~~(&gt;_&lt;)~~~~</code>所以暂时把这边文章放着,等后面有时间了就把这个算法的Python代码弄好贴上来,嘿嘿!(吴恩达的视频里没有这个算法的代码实现的内容,所以需要自己动手)</p><p>另外,为了更好的学习,我把网易云课堂上吴恩达老师视频的链接放到这里(因为它比较系统,还有文档可以下载!)<br><a href="https://study.163.com/course/introduction/1004570029.htm">快点我去网易云课堂学习吧</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>千山万水的第一步</title>
    <link href="/2020/01/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/01/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="网站建成"><a href="#网站建成" class="headerlink" title="网站建成"></a>网站建成</h1><p>开心,我的个人网站终于建立地差不多了!!!</p><h2 id="这个东西实在是太难了"><a href="#这个东西实在是太难了" class="headerlink" title="这个东西实在是太难了"></a>这个东西实在是太难了</h2><span id="more"></span><p>经过十几天的入门，终于将自己的个人博客搭建好了，事实上一开始只是为了更好地整理论文，后来发现大佬们的网页简直不能太强！！！</p><p><img src="https://trees-1301133429.cos.ap-nanjing.myqcloud.com/%E5%A4%A7%E4%BD%AC%E7%9A%84%E5%8D%9A%E5%AE%A2.png" alt="大佬的博客"></p><p>希望以后自己也能成为一个大佬,hahahah<code>~(￣▽￣)~</code>(做梦!)<br>看了这么多别人的博客,愈发觉得将自己的学习过程记录下来放到网络上还算是是一件很有趣的事情。希望自己以后也能坚持下去！！!</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><hr><p>暂时没有测试内容</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站之始</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
