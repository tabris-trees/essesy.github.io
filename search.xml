<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vscode 配置过程记录</title>
    <url>/2024/10/12/vscode-setting-by-me/</url>
    <content><![CDATA[<h1 id="终端美化"><a href="#终端美化" class="headerlink" title="终端美化"></a>终端美化</h1><div class="note info flat"><p>vscode 原本的终端平平无奇，总觉得不是很顺眼，因此想着用 <a href="https://ohmyposh.dev/"><code>oh-my-posh</code></a> 进行美化一下。</p>
<p>主要参考连接：<a href="https://medium.com/@weiyun0912/%E7%BE%8E%E5%8C%96%E4%BD%A0%E7%9A%84-windows-terminal-oh-my-posh-7f150d1497dc">美化你的 Windows Terminal (oh-my-posh)</a></p>
</div>
<p>首先下载 <code>oh-my-posh</code> 软件，这里我们可以直接使用 Windows 的下载工具 <code>Winget</code> 在命令行中下载。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winget install JanDeDobbeleer.OhMyPosh <span class="literal">-s</span> winget</span><br></pre></td></tr></table></figure>
<p>下载之后可以通过 <code>oh-my-posh</code> 查看是否安装成功，<span class='mohu'>如果出现相关的命令，而没有报错的话就代表安装成功了</span></p>
<p>如果已经安装成功，可以直接用下面的命令来应用<a href="https://ohmyposh.dev/docs/themes">官网</a>已经存在的主题：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">oh</span><span class="literal">-my</span><span class="literal">-posh</span> init pwsh -<span class="literal">-config</span> <span class="string">&quot;<span class="variable">$env:POSH_THEMES_PATH</span>\jandedobbeleer.omp.json&quot;</span> | <span class="built_in">Invoke-Expression</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>jandedobbeleer</code> 就是主题的名字，你也可以换成其他的主题名字。</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/image.png" alt="powershell效果图"></p>
<p><a href="https://glitchbone.github.io/vscode-base16-term/#/atelier-forest-light">https://glitchbone.github.io/vscode-base16-term/#/atelier-forest-light</a></p>
]]></content>
      <categories>
        <category>工作</category>
        <category>工具配置</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP-PPPL 暑期学校课程 1 计算等离子体物理简介</title>
    <url>/2023/06/27/CPP-PPPL1/</url>
    <content><![CDATA[<div class="note info flat"><p>这是对2021年 PPPL(Princeton Plasma Physics Laboratory) 暑期学校教授等离子体计算方法的课件进行学习整理之后的笔记.</p>
</div>
<blockquote>
<p>These are notes, lecture slides and code for use in PPPL’s Graduate Summer School, Computational Methods in Plasma Physics mini-course. All material is copyrighted by Ammar Hakim and released under the Creative Commons CC BY License.</p>
</blockquote>
<center><h1>计算等离子体物理简介</h1></center>

<p>动理学作为从微观层面出发解释宏观效应的理论是等离子体物理一个非常有用但复杂的工具, 即使考虑最简单的 Vlasvo-Maxwell 方程也足够描述相当大部分的物理现象.</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial f_{s}}{\partial t} + \nabla_{x} \cdot \left(v f_{s}\right) + \nabla_{v} \cdot \left(\mathbfit{F}_{s} f_{s}\right) = \left(\frac{\partial f_{s}}{\partial t}\right)_{c}
    \end{aligned}
\end{equation}</script><p>其中, $\mathbfit{F}_{s} = q_{s}/m_{s} (\mathbfit{E} + v \times \mathbfit{B})$, 再加上描述电磁场的 Maxwellian 方程:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial \mathbfit{B}}{\partial t}+\nabla \times \mathbfit{E} & =0 \\ \epsilon_{0} \mu_{0} \frac{\partial \mathbfit{E}}{\partial t}-\nabla \times \mathbfit{B} & =-\mu_{0} \sum_{s} q_{s} \int_{-\infty}^{\infty} {v} f_{s} \mathrm{\,d} {v}^{3}
    \end{aligned}
\end{equation}</script><p>这是一个高度非线性的方程组, 场决定了粒子的运动, 粒子的运动反过来产生新的电磁场. 我们做了很多努力来对这个方程组进行精确约化或者在某些特定情况下求解解析值. <span class='mohu'>中科院数学与系统科学研究所的学术报告中就有很多是关于该方程求解的工作.</span></p>
<p>那么, 为什么求解 Vlasov-Maxwell 方程如此困难:</p>
<ul>
<li>场和粒子之间的高阶非线性耦合, 以及不同粒子之间通过长程力作用的小角度碰撞;</li>
<li>多维相空间的参数以及大质量比(电子和离子的质量比为 $m_{e}/m_{p} \approx 1/1836$)的大量粒子种类(会导致计算精度丢失);</li>
<li>从光速到电子等离子体振荡, 从电子回旋到离子回旋, 从介观的流体演化到宏观的平衡态演化, 方程中各种时间和空间上的尺度相差14个数量级.</li>
</ul>
<p>我们这么关心这些方程的数值求解主要是理论上对未知保持好奇, 另外更加重要的是应用上包括磁约束聚变, 等温等离子体等工程应用时求解方程的需要:</p>
<ul>
<li>应用数学和理论物理要求我们开发更加高效的数值方案来求解描述自然的各种复杂方程;</li>
<li>数值方法学科本身的发展, 包括数值能够多大程度的还原物理或者多大程序的利用计算机, 以及研究一些更加先进的数值算法(保结构算法);</li>
<li>更深入的理解描述世界的方程, 更深入的理解世界.</li>
</ul>
<p><span class='mohu'>比较大, 比较空, 但确实是驱动我们科学技术发展的深层次动机.</span></p>
<ul>
<li>计算机提供给了我们一个好的工具理解/设计实验和观测, 我们要利用好这项技术;</li>
<li>大规模的数值计算预实验需要在实际操作之前确定出一条准确可行的方案(避免大型装置实验失败的巨大风险, 生命财产多方面的).</li>
</ul>
<p>课件的目的(当然也是本文章的目的)是介绍一下现代等离子体计算的概念, 尤其是建立起方程中<strong>连续(解析)</strong>和<strong>离散(数值)</strong>性质之间的连接. 主要是以下的两个方面:</p>
<ol>
<li><span style='background: yellow'>说明必须要包含在离散的数值系统当中的物理, 包括不那么直接的性质, 高精确度以及方案求解的阶数;</span></li>
<li><span style='background: yellow'>对求解方案的动理学方程, PIC(Particle in Cell)以及 Vlasov 方程的连续解的一个总体概览</span></li>
</ol>
<div class="note warnning flat"><p>下面就是课件的主题内容, 因为是课件的笔记, 所以将仅仅只是简单精要的总结, 不会有更多的理解, 后面可能会有一个全局的总结来谈谈我学习完之后的一些理解, 这样也能做的更加深入一些.</p>
</div>
<h2 id="离散方程所包含的物理"><a href="#离散方程所包含的物理" class="headerlink" title="离散方程所包含的物理"></a>离散方程所包含的物理</h2><blockquote>
<p>One view of computational physics: we are studying the physics of discretized equations and not really “Nature” itself. Not obvious that these are the same (as measure by some metric).</p>
</blockquote>
<p>很多的物理性质是不那么明显的(indirect), 最简单的例子:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial f}{\partial t} + \frac{\partial f}{\partial x} = 0
    \end{aligned}
\end{equation}</script><div class="note info flat"><p>这是没有外加电磁场, 没有碰撞项, 没有初始速度的经过简化版的一维 Vlasov 方程, 实际上它描述了静态平衡(分布是守恒的)</p>
</div>
<p>从这个式子我们可以推出其 $L_{2}$ 范数是守恒的, 也就是:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial}{\partial t} \frac{1}{2} f^{2} + \frac{\partial }{\partial x} \frac{1}{2} f^{2} = 0
    \end{aligned}
\end{equation}</script><p>这是一个不那么明显的性质, 有时候甚至意识不到它应该是守恒的.</p>
<p>对 Maxwell 方程同样有很重要的 _indirect_ 性质: 能量和动量的守恒, 比如能量守恒可以描述为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial }{\partial t} \left(\frac{\mathbfit{B}^{2}}{2 \mu_{0}} + \frac{\epsilon_{0} \mathbfit{E}^{2}}{2}\right) + \frac{1}{\mu_{0}} \nabla \cdot \left(\mathbfit{E} \times \mathbfit{B}\right) = - \mathbfit{E} \cdot \mathbfit{J} 
    \end{aligned}
\end{equation}</script><details class="toggle" ><summary class="toggle-button" style="">电磁场能量守恒的推导</summary><div class="toggle-content"><p>这是电动力学的基本结果, 高中知识可以得到, 电磁场作用物体实际上不是作用物体本身, 而是作用于电荷或者电流, 同时磁场对运动电荷(电流)产生的力总是与电荷运动的方向垂直的(不做功), 那么我只需要算电场对运动电荷所做的功即可, 也就是:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int \mathbfit{E} \cdot \rho \mathrm{\,d}\tau \mathrm{\,d}\mathbfit{l}
    \end{aligned}
\end{equation}</script><p>$l$ 是电荷在电场作用下运动的距离. 考虑对时间的微分形式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{\,d}W}{\mathrm{\,d}t} &= \int \mathbfit{E} \cdot \rho \mathrm{\,d}\tau \mathrm{\,d}\mathbfit{l}/\mathrm{\,d}t \\
        & = \int \mathbfit{E} \cdot \rho \mathbfit{v} \mathrm{\,d}\tau \\
        &= \int \mathbfit{E} \cdot \mathbfit{j} \mathrm{\,d}\tau
    \end{aligned}
\end{equation}</script><p>然后根据 Maxwell 方程的第四项:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\mathbfit{j} = \frac{1}{\mu_{0}} (\nabla \times \mathbfit{B}) - \epsilon_{0} \frac{\partial \mathbfit{E}}{\partial t} \\
        &\Rightarrow \mathbfit{j} \cdot \mathbfit{E}  = \frac{1}{\mu_{0}} (\nabla \times \mathbfit{B}) \cdot \mathbfit{E} - \frac{\epsilon_{0}}{2} \frac{\partial \mathbfit{E}^{2}}{\partial t}
    \end{aligned}
\end{equation}</script><p>根据矢量恒等式: $\nabla \cdot (\mathbfit{B} \times \mathbfit{E}) = E \cdot (\nabla \times \mathbfit{B}) - \mathbfit{B} \cdot (\nabla \times \mathbfit{E})$ 可以得到</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{j} \cdot \mathbfit{E} = \frac{1}{\mu_{0}} \nabla \cdot \left(\mathbfit{B} \times \mathbfit{E}\right) + \frac{1}{\mu_{0}} \mathbfit{B} \cdot (\nabla \times \mathbfit{E}) - \frac{\epsilon_{0}}{2}\frac{\partial \mathbfit{E}^{2}}{\partial t}
    \end{aligned}
\end{equation}</script><p>再利用 $\nabla \times \mathbfit{E} = -\frac{\partial \mathbfit{B}}{\partial t}$ 经过简单化简就能得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{E} \cdot \mathbfit{j} = -\frac{1}{\mu_{0}} \nabla \cdot (\mathbfit{E} \times \mathbfit{B}) - \frac{1}{2 \mu_{0}}\frac{\partial \mathbfit{B}^{2}}{\partial t} - \frac{\epsilon_{0}}{2} \frac{\partial \mathbfit{E}^{2}}{\partial t}
    \end{aligned}
\end{equation}</script><p>也就是上面正文中的式子, 可以证明这就是电磁场的能量守恒表达式.</p>
</div></details>
<p>但是这是连续的情况下得到结论, 当我们做数值离散的时候保持能量守恒这个特性是需要面对的一个问题.</p>
<p><img src="https://pica.zhimg.com/v2-bdf801a74f6d9fa46148ce50847cbd46_1440w.jpg" alt="Compute methods in plasma-20230625210600"></p>
<center id='f1'><span style='font-weight:bold'>Fig 1. Energy conserving scheme for Maxwell equations (purple) compared to non-conservative scheme (black). Conservation of energy means there is no damping of spurious high-k modes.</span></center>

<p>如果将 Vlasov 方程考虑进去能量守恒还需要加上粒子的动能, 同时体系变成封闭体系, 即:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}}{\mathrm{d}t} \sum _{s} \int _{K} \frac{1}{2} m \left|v\right|^{2} f \mathrm{\,d}z + \frac{\mathrm{d}}{\mathrm{d}t} \int _{\Omega} \left(\frac{\epsilon_{0}}{2} \left|\mathbfit{E}\right|^{2} + \frac{1}{2\mu_{0}} \left|\mathbfit{B}\right|^{2}\right)\mathrm{\,d}^{3}x = 0
    \end{aligned}
\end{equation}</script><p>但是对于离散的数值方案来说这个性质并不是那么明显成立的, 相似的问题在哈密顿方程描述等离子体的数值方案中同样也存在.</p>
<p>除了能量和动量守恒外, Vlasov-Maxwell 方程或者一些其他方程还有着熵在无碰撞情况下是守恒的, 碰撞情况下是单调递增等性质, 这些性质在我们的数值方案中也并不是可以确定存在的.</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}}{\mathrm{d}t} \int _{K} -f \ln(f) \geq 0
    \end{aligned}
\end{equation}</script><p>总能量守恒我们都知道, 一个典型的流体力学代码也包含了总能量守恒这一性质, 但是如果只考虑动能的演化呢? 通常我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial }{\partial t} \int _{\Omega} \frac{1}{2} \rho \mathbfit{u}^{2} \mathrm{\,d}x + \oint _{\partial \Omega} \left(\frac{1}{2} \rho \mathbfit{u}^{2} + \mathbfit{p}\right) \mathbfit{u} \cdot \mathrm{\,d}\mathbfit{s} - \int _{\Omega} \mathbfit{p} \nabla \cdot \mathbfit{u} \mathrm{\,d}x = 0
    \end{aligned}
\end{equation}</script><p>这个式子展示了动能变化来自流体的可压缩性. 在等离子体中 $\mathbfit{J} \cdot \mathbfit{E}$ 这一项也展示了粒子与场之间的能量交换. 但是数值方案中有这个性质吗, 有什么奇怪的交换项将能量在不同项之间的分配给搞砸了吗, 这是一个需要思考的问题. 不正确的离散交换会引起高阶模错误的能量交换行为, 这些模式的精确性将会影响我们理解湍流的本质.</p>
<h2 id="计算等离子体中的一些常见方案"><a href="#计算等离子体中的一些常见方案" class="headerlink" title="计算等离子体中的一些常见方案"></a>计算等离子体中的一些常见方案</h2><h3 id="电磁场中的单粒子运动"><a href="#电磁场中的单粒子运动" class="headerlink" title="电磁场中的单粒子运动"></a>电磁场中的单粒子运动</h3><p>PIC 模拟实际上是在拉格朗日框架下的相空间中求解 Vlasov-Maxwell 方程, 此时的分布函数将会沿着相空间的特征(characteristics)保持不变. 这些特征(characteristics)满足洛伦兹力作用下粒子运动的常微分方程:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}\mathbfit{x}}{\mathrm{d}t} &= \mathbfit{v} \\
        \frac{\mathrm{d}\mathbfit{v}}{\mathrm{d}t} &= \frac{q}{m} (\mathbfit{E}(x,t) + \mathbfit{v} \times \mathbfit{B}(x,t))
    \end{aligned}
\end{equation}</script><p>我们先关注单个粒子的运动方程, 之后再将其与电磁场以及其他粒子耦合起来.</p>
<h3 id="简单谐振子"><a href="#简单谐振子" class="headerlink" title="简单谐振子"></a>简单谐振子</h3><p>首先考虑一个简单谐振子:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}^{2}z}{\mathrm{d}t^{2}} = -\omega^{2} z
    \end{aligned}
\end{equation}</script><p>对这样的方程我们有一个精确的解的形式(<span class='mohu'>高等数学中已经学过</span>) $z = a \cos(\omega t) + b \sin(\omega t)$. 写成一阶常微分方程的形式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}z}{\mathrm{d}t} = v;\ \frac{\mathrm{d}v}{\mathrm{d}t} = -\omega^{2} z
    \end{aligned}
\end{equation}</script><p>这样, 这个简单谐振子的相空间就由坐标 $(z,v)$ 构建起来, 类比到实际物理中这就是牛顿力学的具体表述, 现在我们将 $v$ 乘到第二个式子中以得到动能的形式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\frac{\mathrm{d}}{\mathrm{d}t} \frac{1}{2} v^{2} = -\omega^{2} z \frac{\mathrm{d}z}{\mathrm{d}t} \\
        \Rightarrow &\frac{\mathrm{d}}{\mathrm{d}t} \left(\frac{1}{2} v^{2} + \frac{1}{2} \omega^{2} z^{2}\right) = 0
    \end{aligned}
\end{equation}</script><p>这就是简单谐振子这个系统中能量守恒的表达. 问题是我们怎么在离散的数值方案中保证这个性质也是成立的呢?</p>
<h3 id="前向欧拉方法"><a href="#前向欧拉方法" class="headerlink" title="前向欧拉方法"></a>前向欧拉方法</h3><p>最简单的方案, 采用用差分代替微分的思路:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{z^{n+1} - z^{n}}{\Delta t} = v^{n};\ \frac{v^{n+1}-v^{n}}{\Delta t} = -\omega^{2} z^{n}
    \end{aligned}
\end{equation}</script><p>或者</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        z^{n+1} = z^{n}+\Delta t v^{n};\ v^{n+1} = v^{n}-\Delta t \omega^{2} z^{n}
    \end{aligned}
\end{equation}</script><p>利用这种递推公式可以得出后一时刻的前面的总能量形式为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \left(v^{n+1}\right)^{2}+\omega^{2}\left(z^{n+1}\right)^{2}=\left(1+\omega^{2} \Delta t^{2}\right)\left(\left(v^{n}\right)^{2}+\omega^{2}\left(z^{n}\right)^{2}\right)
    \end{aligned}
\end{equation}</script><p>可以看到, 如果能量守恒后者应该是 $\left(v^{n}\right)^{2}+\omega^{2}\left(z^{n}\right)^{2}$, 但这种方法多出了一个 $\omega^{2} \Delta t^{2}$, 因此这种前向欧拉方法是不具有能量守恒性质的, 实际上每多走一步系统的能量是在增加的. 更近一步地, 我们可以把上面的差分式子写成矩阵形式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \left[\begin{array}{l}z^{n+1} \\ v^{n+1}\end{array}\right]=\underbrace{\left[\begin{array}{cc}1 & \Delta t \\ -\omega^{2} \Delta t & 1\end{array}\right]}_{\text {Jacobian, } J}\left[\begin{array}{l}z^{n} \\ v^{n}\end{array}\right]
    \end{aligned}
\end{equation}</script><p>把前面的矩阵称作 Jacobian 矩阵, 其行列式为: $\det(\mathbfit{J}) = (1+\omega^{2}\Delta t^{2})$, 这正好就是前面能量关系中出现的因子, 于是我们可以很自然地得到结论:</p>
<div class="note success flat"><p>如果某个数值方案的雅可比(Jacobian)矩阵的行列式 $\det(\mathbfit{J}) = 1$, 那么这种方案具有能量守恒的性质, 我们称之为 <strong>“保体积方法”</strong>, 因为这种方法可以保证相空间体积是不变的.</p>
</div>
<h3 id="中点法-Mid-point-Scheme"><a href="#中点法-Mid-point-Scheme" class="headerlink" title="中点法(Mid-point Scheme)"></a>中点法(Mid-point Scheme)</h3><p>另一种更好的方案可能是中点平均格式的数值方法, 其递推公式变成:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{z^{n+1}-z^{n}}{\Delta t} &= \frac{v^{n}+v^{n+1}}{2} \\
        \frac{v^{n+1}-v^{n}}{\Delta t} &= -\omega^{2} \frac{z^{n}+z^{n+1}}{2}
    \end{aligned}
\end{equation}</script><p>这是一种隐式格式的算法, 这意味着下一步的解不仅依赖于当前步的值, 也依赖于下一步的值. 类似的我们也可以写成矩阵形式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \left[\begin{array}{c}z^{n+1} \\ v^{n+1}\end{array}\right]=\frac{1}{1+\omega^{2} \Delta t^{2} / 4}\left[\begin{array}{cc}1-\omega^{2} \Delta t^{2} / 4 & \Delta t \\ -\omega^{2} \Delta t & 1-\omega^{2} \Delta t^{2} / 4\end{array}\right]\left[\begin{array}{c}z^{n} \\ v^{n}\end{array}\right]
    \end{aligned}
\end{equation}</script><p>可以算出对于这种方法 $\det(\mathbfit{J}) = 1$, 因此这是一种相空间体积守恒的方法, 同时你也可以通过代数计算出:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        (v^{n+1})^{2} + \omega^{2} (z^{n+1})^{2} = (v^{n})^{2} + \omega^{2} (z^{n})^{2}
    \end{aligned}
\end{equation}</script><p>这表示这个方法具有能量守恒的特性.</p>
<p>对于简单谐振子来说一个更加严格的约束是 Jacobian 矩阵应该是一个辛矩阵, 满足以下的关系:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{J}^{T} \sigma \mathbfit{J} = \sigma
    \end{aligned}
\end{equation}</script><p>其中 $\sigma$ 是单位辛矩阵:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \sigma = \left[\begin{array}{cc}0 & 1 \\ -1 & 0\end{array}\right]
    \end{aligned}
\end{equation}</script><p>可以证明的是中点方法确实满足这一条件, 应该注意的是一个保体积算法并不一定是具有辛对偶特性的.</p>
<h3 id="精确度和稳定性"><a href="#精确度和稳定性" class="headerlink" title="精确度和稳定性"></a>精确度和稳定性</h3><p>学习精确度以及稳定性的问题一般用下面的一阶常微分方程来入手:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}z}{\mathrm{d}t} = - \gamma z
    \end{aligned}
\end{equation}</script><p>其中, $\gamma = \omega + i \lambda$ 是复频率, 这个方程的严格解为: $z(t) = z_{0} e^{-\gamma t}$, 这表明解会存在一个阻尼 $\lambda &lt; 0$ 或者增长 $\lambda &gt; 0$ 的振荡模式. 对于这个方程, 前向欧拉方法为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        z^{n+1}=z^{n}-\Delta t \gamma z^{n}=(1-\Delta t \gamma) z^{n}
    \end{aligned}
\end{equation}</script><p>中点方法为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        z^{n+1}&=\left(\frac{1-\gamma \Delta t / 2}{1+\gamma \Delta t / 2}\right) z^{n} \\
        &= z^{n} \left(1-\Delta t \gamma - \frac{1}{2} \gamma^{2} \Delta t^{2} - \frac{1}{4} \gamma^{3} \Delta t^{3} + \ldots\right)
    \end{aligned}
\end{equation}</script><p>通常我们检查方案的精确度是看其与严格解的差分形式泰勒展开有多少项是相同的, 在这个例子中泰勒展开如下:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        z\left(t^{n+1}\right)=z\left(t^{n}\right)\left(1-\gamma \Delta t+\frac{1}{2} \gamma^{2} \Delta t^{2}-\frac{1}{6} \gamma^{3} \Delta t^{3}+\ldots\right)
    \end{aligned}
\end{equation}</script><p>可以看出前向欧拉方法只有一阶的精度, 而中点方法却有三阶的精度.</p>
<p>如果对于某个问题的数值方案产生的误差不会随着时间的迭代而增加我们就称这个数值方法是 <strong>稳定的</strong>. 可以用一个简单的数(amplification factor)来判断:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \left|\frac{e^{n+1}}{e^{n}}\right| = \left|\frac{z^{n+1} - z_{\star}^{n+1}}{z^{n} - z_{\star}^{n}}\right| = \left|\frac{D(z^{n})-D(z_{\star}^{n})}{z^{n} - z_{\star}^{n}}\right|
    \end{aligned}
\end{equation}</script><p>其中, $z_{\star}^{n}$ 表示当前步的精确解, $D(z^{n})$ 表示数值方案对应的差分关系. 在这个例子中(我们这里只考虑 $\lambda = 0$ 的情况, 即没有阻尼或者增长的情况), 前向欧拉格式对应的 amplification factor 为 $1 - \Delta t \omega$. 要保证数值误差不增长( $\omega &gt; 0$ ), 需要 $\Delta t \leq \frac{2}{\omega}$. 所以我们说前向欧拉方法是<strong>条件稳定的</strong>. 如果是中点方法, amplification factor 很明显为 1, 也就是说用中点法数值求解这个方程是 <strong>无条件稳定的</strong>, 这意味着你可以取一个很大的计算步长而不会引起误差的爆炸 <span class='mohu'>Of course, the error will increase with the large $\Delta t$</span>.</p>
<p>虽然前向欧拉方法是条件稳定的算法, 但是我们依旧可以在它的基础上开发更稳定更精确的算法. 前面提到的两种算法都是单步算法, 只需要计算一次就可以得到结果, 实际计算的时候我们还可以采用多步算法(multi-stage), 比如龙格库塔方法(Runge-Kutta methods), 这种方法具有较高的精度以及较强的稳定性. 值得注意的是这些龙格库塔方法对简单谐振子来说并不能保证能量守恒, 反而会导致能量的衰减, 如果要保证物理性质不丢失, 还需要检验算法的相关特性.</p>
<h3 id="电磁场中的单粒子运动数值计算"><a href="#电磁场中的单粒子运动数值计算" class="headerlink" title="电磁场中的单粒子运动数值计算"></a>电磁场中的单粒子运动数值计算</h3><p>前面已经给出了带电粒子在电磁场中的运动方程, 很明显, 如果没有电场存在系统的动能将会是一个常数:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{1}{2} \left|\mathbfit{v}\right|^{2} = \text{constant}
    \end{aligned}
\end{equation}</script><p>这意味着在几何上, 没有电场存在时速度矢量将会始终落在在空间中的一个球面上.</p>
<p>这里我们给出带电粒子运动方程的中点格式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathbfit{x}^{n+1}-\mathbfit{x}^{n}}{\Delta t}&=\frac{\mathbfit{v}^{n+1}+\mathbfit{v}^{n}}{2} \\ \frac{\mathbfit{v}^{n+1}-\mathbfit{v}^{n}}{\Delta t}&=\frac{q}{m}\left(\overline{\mathbfit{E}}(\mathbfit{x}, t)+\frac{\mathbfit{v}^{n+1}+\mathbfit{v}^{n}}{2} \times \overline{\mathbfit{B}}(\mathbfit{x}, t)\right)
    \end{aligned}
\end{equation}</script><p>overbar 表示新旧位置电磁场的平均, 一般来说, 这会使我们的数值方法变得非线性. 我们也可以使用一种交错式(或者也称之为<strong>蛙跳格式</strong>)的推进方法:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathbfit{x}^{n+1}-\mathbfit{x}^{n}}{\Delta t} & =\mathbfit{v}^{n+1 / 2} \\ \frac{\mathbfit{v}^{n+1 / 2}-\mathbfit{v}^{n-1 / 2}}{\Delta t} & =\frac{q}{m}\left(\mathbfit{E}\left(\mathbfit{x}^{n}, t^{n}\right)+\frac{\mathbfit{v}^{n+1 / 2}+\mathbfit{v}^{n-1 / 2}}{2} \times \mathbfit{B}\left(\mathbfit{x}^{n}, t^{n}\right)\right)
    \end{aligned}
\end{equation}</script><p>这看起来是一种隐式格式的方法, 通常是构建一个 $3 \times 3$ 的线性系统来代表这个方程, 然后通过取逆的方式来决定 $\mathbfit{v}^{n+1}$. Boris 算法采用以下的步骤来更新这个方程:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{v}^{-} & =\mathbfit{v}^{n-1 / 2}+\frac{q}{m} \mathbfit{E}^{n} \frac{\Delta t}{2} \\ \frac{\mathbfit{v}^{+}-\mathbfit{v}^{-}}{\Delta t} & =\frac{q}{2 m}\left(\mathbfit{v}^{+}+\mathbfit{v}^{-}\right) \times \mathbfit{B}^{n} \\ \mathbfit{v}^{n+1 / 2} & =\mathbfit{v}^{+}+\frac{q}{m} \mathbfit{E}^{n} \frac{\Delta t}{2}
    \end{aligned}
\end{equation}</script><p>这个过程中, 需要进行两次电场对速度的推进以及一次磁场对速度的旋转<sup><a href="#fn_1" id="reffn_1">1</a></sup>. 一旦速度通过这种方式计算出来之后, 我们可以很轻松的更新出下一时刻的位置. 其中磁场对粒子速度的旋转被分成两个步骤进行:</p>
<ol>
<li>计算 $\mathbfit{s}$ 和 $\mathbfit{t}$ 这两个中间矢量<script type="math/tex; mode=display">
t = \frac{q \mathbfit{B}}{m} \frac{\Delta t}{2} \\ s= \frac{2 t}{1+\left|t\right|^{2}}</script></li>
<li>计算 $v^{\prime} = v^{-}+v^{-} \times \mathbfit{t}$, 然后 $v^{+} = v^{-} + v^{\prime} \times \mathbfit{s}$.</li>
</ol>
<p>一些具体的细节还可以参考 Birdsall 和 Langdon 的书 4-3 以及 4-4 部分<sup><a href="#fn_2" id="reffn_2">2</a></sup>. 如果没有电场存在的情况下 Boris 方法计算的动能是守恒的, 另一些 Boris 计算方式的优点可以看 Qin et al. (2013) 的文章<sup><a href="#fn_3" id="reffn_3">3</a></sup>.</p>
<h3 id="求解-Maxwell-方程组"><a href="#求解-Maxwell-方程组" class="headerlink" title="求解 Maxwell 方程组"></a>求解 Maxwell 方程组</h3><p>解决完电磁场中带电粒子的推进, 我们还需要通过计算 Maxwell 方程组来考虑场与电流电荷之间的自洽. 首先考虑真空中的 Maxwell 方程组:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial \mathbfit{B}}{\partial t}+\nabla \times \mathbfit{E}=0 \\ \epsilon_{0} \mu_{0} \frac{\partial \mathbfit{E}}{\partial t}-\nabla \times \mathbfit{B}=0
    \end{aligned}
\end{equation}</script><p>于是我们可以得到两条守恒定律:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{d}{d t} \int_{\Omega} \mathbfit{E} \times \mathbfit{B} d^{3} \mathbfit{x}=0 \\ \frac{d}{d t} \int_{\Omega}\left(\frac{\epsilon_{0}}{2}|\mathbfit{E}|^{2}+\frac{1}{2 \mu_{0}}|\mathbfit{~B}|^{2}\right) d^{3} x=0
    \end{aligned}
\end{equation}</script><p>注意这些守恒律都是全局的, 我们也可以写出带有能量通量的局部守恒律. 如果有效的计算这些方程并保留其守恒特性呢? 考虑到 Maxwell 方程具有以下几个特性: </p>
<ul>
<li>特殊的几何结构, 电场 $\mathbfit{E}$ 是矢量, 但磁场 $\mathbfit{B}$ 是二重向量(bivector)<sup><a href="#fn_4" id="reffn_4">4</a></sup><sup><a href="#fn_5" id="reffn_5">5</a></sup></li>
<li>完整的电磁场在 4 维时空的时空代数形式下被表示为一个二重向量</li>
</ul>
<p>也就是说事实上, 我们正在处理两个不同几何类型的物体, 这表明离散麦克斯韦方程组也应该以某种方式继承这一点. Yee 算法, 或者说 <strong>有限差分时域算法</strong> 是目前在考虑几何结构方面最成功也是最简单的算法, 这种方法被应用在大部分的 PIC 模拟中 <span class='mohu'>尽管最近人们开始研究保结构有限元算法以及一些其他的方法</span>.</p>
<p><img src="https://pic3.zhimg.com/v2-1a84e0ceb38c2bd3d5807ca1d7bf6b78_1440w.jpg" alt="Compute methods in plasma-20230627201409" style="zoom:50%;" ></p>
<center id='f2'><span style='font-weight:bold'>Fig 2. Illustration of the Yee-cell.</span></center>

<p>Yee 网格对 Maxwell 方程的差分约化简直就像是魔法一样 <span class='heimu'>(OK, 其实我并不是很懂这个方法有多么牛逼, 原谅我还是太菜了, 但是原文就是这么说的!!!)</span>. 这些更新方案在时间上是交错的, 过程中使用了两种不同的离散旋度运算符:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{B}^{n+1 / 2} & =\mathbfit{B}^{n-1 / 2}-\Delta t \nabla_{E} \times \mathbfit{E}^{n} \\ \mathbfit{E}^{n+1} & =\mathbfit{E}^{n}+\Delta t / c^{2} \nabla_{F} \times \mathbfit{B}^{n+1 / 2}
    \end{aligned}
\end{equation}</script><p>这里 $\nabla _{F} \times $ 符号以及 $\nabla _{E} \times $ 符号都是离散的旋度算符:</p>
<ul>
<li>第一种算符作用于面(Face)中心的磁场并计算其旋度, 最终得到在网格(cell)边上的值;</li>
<li>第二种算符作用于边(Edge)中心的电场并计算其旋度, 最终得到网格面上的值.</li>
<li>这种网格方法也暗含了<span style='background: pink'>电流必须和电场在同一位置, 同时需要半个时间步长计算一次</span>.</li>
</ul>
<p>这种对偶性巧妙地反映了麦克斯韦方程组的基本几何形状. 时间上的错位反映了这样一个事实: 在四维时空中, 电磁场是时空中的一个二重向量. 我们也可以展示出这种离散方法严格地保持了 Maxwell 方程组中散度关系:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \nabla_{F} \cdot \mathbfit{B}^{n+1 / 2} & =0 \\ \nabla_{E} \cdot \mathbfit{E}^{n} & =0
    \end{aligned}
\end{equation}</script><p>对于等离子体来说, Maxwell 方程组还需要满足电流守恒的约束:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial \varrho_{c}}{\partial t} + \nabla \cdot \mathbfit{J} = 0
    \end{aligned}
\end{equation}</script><p>其中, $\varrho_{c}$ 是电荷密度, $\mathbfit{J}$ 是电流密度. 在 Yee 网格离散的形式下上式变成了:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\varrho_{c}^{n+1}-\varrho_{c}^{n}}{\Delta t}+\nabla_{E} \cdot \mathbfit{J}^{n+1 / 2}=0
    \end{aligned}
\end{equation}</script><p>这个过程中必须要确认从粒子到电流的计算不会出错以保证这个表达式是成立的, 更多的细节一下在 Esirkepov, Comp. Phys. Communications, 135 144-153 (2001)<sup><a href="#fn_6" id="reffn_6">6</a></sup> 这篇文章中找到.</p>
<h2 id="总结与正在进行的工作"><a href="#总结与正在进行的工作" class="headerlink" title="总结与正在进行的工作"></a>总结与正在进行的工作</h2><ul>
<li>计算等离子体物理学是困难的: 还有许多工作要做, 以便为各种等离子体应用创建工具; 在方案设计中必须考虑到微妙的间接性质.</li>
<li>潜在高影响力领域: 需要限制可能的聚变装置的空间, 并帮助了解预期的燃烧等离子体状态.</li>
</ul>
<p>最后是 A. Hakim 教授的一些个人建议, 这里直接贴原文:</p>
<blockquote>
<ol>
<li>Computational physics is a rapidly evolving field. Good field to be in!</li>
<li>Strive for technical excellence. Do not settle for existing methods or tools and spend time in understanding deeply both the physics of the equations and the numerics used to solve them. Go beyond your classwork and thesis reasearch (make it a point to read arxiv physics.comp-ph and math.NA postings every day).</li>
<li>Modern computational physics is moving to C and C++: please learn them. Use good software practices (write modular code, use version control, build systems, regression tests). Even for your thesis code!</li>
<li>To become really good you must apprentice yourself to a genuine expert.</li>
<li>If you become an expert at the (i) physics (ii) mathematics of the numerical methods (iii) programming and software techniques, you will be in a very strong position to contribute to development in many different fields. You will bring unique skills which few other people will be.</li>
</ol>
</blockquote>
<hr>
<blockquote id="fn_1">
<sup>1</sup>. 有关Boris算法的更多详情可以参考: <a href="https://www.particleincell.com/2011/vxb-rotation/">Particle Push in Magnetic Field (Boris Method) (particleincell.com)</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. C K Birdsall &amp; A B Langdon., Plasma Physics via Computer Simulation (CRC Press)<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. Qin, H., Zhang, S., Xiao, J., et al. 2013, Physics of Plasmas, 20, 084503<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. <a href="https://en.wikipedia.org/wiki/Bivector">https://en.wikipedia.org/wiki/Bivector</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. <a href="https://en.wikipedia.org/wiki/Mathematical_descriptions_of_the_electromagnetic_field">https://en.wikipedia.org/wiki/Mathematical_descriptions_of_the_electromagnetic_field</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. Esirkepov, T. Zh. 2001, Computer Physics Communications, 135, 144<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>等离子体物理</category>
        <category>计算等离子体物理</category>
      </categories>
      <tags>
        <tag>等离子体</tag>
        <tag>计算等离子体物理</tag>
        <tag>计算方法</tag>
        <tag>计算机模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>TORIC 简单介绍</title>
    <url>/2023/06/22/TORIC/</url>
    <content><![CDATA[<center><div style='height:2mm;'></div><div>伍先树, 李景春<br>南方科技大学&ensp;地球与空间科学系<br>2023-06-20</div></center>

<div class="note info flat"><p>TORIC 程序是一个计算模拟 ICRF(离子回旋频段) 甚至可以模拟低杂波的全波解程序, 由德国马普研究所下的等离子体研究所的 M, Brambilla 及其合作者共同开发完成，现在的接替 Brambilla 的主要开发者为Roberto Bilato. TORIC 可以被用来求解任意轴对称环几何位形下以及有限拉莫尔半径近似下的离子回旋波段的麦克斯韦波方程.</p>
<p style="text-align:right">&mdash;&mdash;郑振 2021</p></div>
<hr>
<h2 id="TORIC-输入文件"><a href="#TORIC-输入文件" class="headerlink" title="TORIC 输入文件"></a>TORIC 输入文件</h2><p>运行 TORIC 程序需要名为 <code>torica.inp</code> 的 namelist 文件. 文件包含的内容很多, 分别涉及到不同的板块. 具体的细节可以在 <a href="https://users.euro-fusion.org/expert/transp/Toric/Manual/frame.htm">官方手册页面</a> 找到. 以下是用实际文件对重要参数(需要经常修改)做一些简单的说明:</p>
<h3 id="toric-mode"><a href="#toric-mode" class="headerlink" title="toric_mode"></a>toric_mode</h3><p>设置程序的运行模式, 该部分内容由主程序 <code>t4_aamian.F</code> 读取, 对应不同模式的计算.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &amp;toric_mode</span><br><span class="line">!</span><br><span class="line">!  Read by the program calling toric</span><br><span class="line">!</span><br><span class="line">     toricmode = &quot;equil&quot; # Producing an equilibrium file with i2mex</span><br><span class="line">!      toricmode = &quot;toric&quot; # Using TORIC to solve the wave equations.</span><br><span class="line">!     toricmode = &#x27;sumnph&#x27; # Superposing the results for several toroidal modes </span><br><span class="line">!     toricmode = &quot;ssfpql&quot; # The quasilinear Fokker-Planck solver SSFPQL</span><br><span class="line">!     toricmode = &quot;fppmod&quot;</span><br><span class="line">!     toricmode = &#x27;diagns&#x27; # Using TORIC in the diagnostic mode.</span><br><span class="line">!</span><br><span class="line">!  Accepted values: &quot;equil&quot;, &quot;toric&quot;, &quot;ssfpql&quot;, &quot;sumnph&quot;,</span><br><span class="line">!                   &quot;qldce&quot;, &quot;&quot;fppmod&quot;, &quot;diagns&quot;</span><br><span class="line">!</span><br><span class="line">  /</span><br></pre></td></tr></table></figure>
<p>各模式主要的功能上面的代码注释中已经简单介绍了, 我们运行程序时一般只用前两种模式, <code>equigs</code> 模式用于准备 <code>toric</code> 模式下程序运行所需的平衡文件. 其余模式在 <code>toric</code> 模式下会按照需要依次运行(通过设置对应的参数而被调用).</p>
<h3 id="toricainp"><a href="#toricainp" class="headerlink" title="toricainp"></a>toricainp</h3><p>用于存放控制 TORIC 运行的数据 (Parameters for resolution, antenna, output) 的地方, 通过 <code>hf_read</code> 读取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &amp;toricainp</span><br><span class="line">!</span><br><span class="line">!  Read from subroutine hfread, &quot;contained&quot; in t4_torica</span><br><span class="line">!</span><br><span class="line">       isol   = 1,</span><br><span class="line">!             mode of operation of the TORIC code</span><br><span class="line">!             =  0  Explorative(diagnostic) mode:                                </span><br><span class="line">!                      Magnetic configuration                        </span><br><span class="line">!                      Density &amp; temperature profiles,               </span><br><span class="line">!                      Dielectric properties vs X                    </span><br><span class="line">!                      Dielectric properties vs TH (IPLTHT = 1)      </span><br><span class="line">!             =  1  Run mode, Maxwellian plasmas</span><br><span class="line">!                      Construction and inversion of the stiffness   </span><br><span class="line">!                      matrix; results are printed, plotted, and     </span><br><span class="line">!                      written on disk if required.   </span><br><span class="line">!             =  2  Run mode, with non-maxwellian minority</span><br><span class="line">!                      In this case, the namelist /qlmininp/ must specify</span><br><span class="line">!                      the minority species and the file where the </span><br><span class="line">!                      data from the run of SSFPQL are to be read.</span><br><span class="line">!</span><br><span class="line">!                   Note: always check vacuum extrapolation with</span><br><span class="line">!                   isol = -1 before using a new configuration!</span><br><span class="line">       nvrb   =   3,</span><br><span class="line">! --------------------------------------------------------------------</span><br><span class="line">!  Definition of the variables and mesh for the run</span><br><span class="line">! --------------------------------------------------------------------</span><br><span class="line">!            Number of components of the electric field:</span><br><span class="line">!            NVRB = 2 - parallel field omitted (for comparison</span><br><span class="line">!                       with old codes omitting E_//.)</span><br><span class="line">!            NVRB = 3 - parallel field evaluated (normal option)</span><br><span class="line">       nelm   = 450,</span><br><span class="line">!            Number of radial finite elements</span><br><span class="line">       ntt    =  512,</span><br><span class="line">!            Number of points in the poloidal angle (theta) mesh:</span><br><span class="line">!            must be a power of 2 (FFT) and satisfy NTT &gt;= 2*NMOD+1</span><br><span class="line">       nmod   =  255,</span><br><span class="line">!            Number of modes in the solution  (preferably odd):</span><br><span class="line">!            NOTE: to optimize use of the information in the poloidal </span><br><span class="line">!            mesh the best choice is NMOD = NTT/2-1 (see below).</span><br><span class="line">!            A value of NMOD &lt;&lt; NTT/2-1 can lead to inaccuracies.</span><br><span class="line">!</span><br><span class="line">!           Example: With MASTCH=1 the largest job accepted by the </span><br><span class="line">!            IPP IBMaix or a normal laptop has (about): </span><br><span class="line">!                   NTT = 64, NMOD = 31, NELM = 450.</span><br><span class="line">!</span><br><span class="line">!           nelm = 200, ntt = 256, nmod = 127 can perform well</span><br><span class="line">!           on the TianHe cluster. </span><br><span class="line">! --------------------------------------------------------------------</span><br><span class="line">       nptvac =  50,</span><br><span class="line">       mxmvac =  15,</span><br><span class="line">!                         It is recommented not to exceed MXMVAC = 15</span><br><span class="line">! --------------------------------------------------------------------</span><br><span class="line">!  H.F. and antenna parameters</span><br><span class="line">! --------------------------------------------------------------------</span><br><span class="line">       freqcy = 16.0E6,</span><br><span class="line">!            Applied frequency, in hz.</span><br><span class="line">       nphi   =  18,</span><br><span class="line">!            Toroidal mode number.</span><br><span class="line">       antlen = 50,</span><br><span class="line">!            Length of the antenna in the poloidal direction (cm)</span><br><span class="line">       antlc  = 1.2,</span><br><span class="line">!            Effective propagation constant of the antenna.</span><br><span class="line">!             ANTLC &gt; 0 - the current ends abruptly at the feeders</span><br><span class="line">!             ANTLC &lt; 0 - the current goes to zero at the feeders</span><br><span class="line">!                         (works only with a large value of ntt).</span><br><span class="line">!             ANTLC = -999. - poloidally uniform excitation</span><br><span class="line">       theant = 0.,</span><br><span class="line">!            poloidal position of the central point of the antenna </span><br><span class="line">!             (degrees from the outer equatorial plane)</span><br><span class="line">! --------------------------------------------------------------------</span><br><span class="line">       iflr   = 1,</span><br><span class="line">       ibweld = 2,</span><br><span class="line"></span><br><span class="line">       ibpol  = 1,</span><br><span class="line">       iqtor  = 1,</span><br><span class="line">       icoll  = 0,</span><br><span class="line">       enhcol = 1.,</span><br><span class="line">!                        Must be very large (10^5) to have any effect</span><br><span class="line">       imdedg = 2,</span><br><span class="line">       iezvac = 1,</span><br><span class="line">       icosig = 0,</span><br><span class="line">!                        Use ICOSIG &lt;&gt; 0 only in exceptional cases!</span><br><span class="line">       iregax = 1,</span><br><span class="line">!                        IREGAX=1 and intchb &gt; 0 recommended when</span><br><span class="line">!                        IBW are propagative near the magnetic axis</span><br><span class="line">       mastch = 1,</span><br><span class="line">       lenwrd = 8,</span><br><span class="line">! ----------------------------------------------------------------------</span><br><span class="line">! Input of parameters for the control of the output:</span><br><span class="line">! ----------------------------------------------------------------------</span><br><span class="line">       iout   = 1,</span><br><span class="line">!             printed output control:</span><br><span class="line">!              = 0  normal output.</span><br><span class="line">!              = 1  detailed output.</span><br><span class="line">!              = 2  complete output: includes radial behaviour of the</span><br><span class="line">!                   Fourier coefficients of the electric field.</span><br><span class="line">       iwdisk = 1,</span><br><span class="line">!             output on disk (fort.9, only with ISOL=1)</span><br><span class="line">!              = 0  skipped</span><br><span class="line">!              = 1  done (specify file name in the JCL job)</span><br><span class="line">       idlout = 1,</span><br><span class="line">!             output for IDL plots </span><br><span class="line">!             IDLOUT = 0   skipped</span><br><span class="line">!             IDLOUT &gt; 0   executed (normal setting)</span><br><span class="line">       ipltht = 1,</span><br><span class="line">!            plot of dielectric tensor as function of theta</span><br><span class="line">!            on selected magnetic surfaces</span><br><span class="line">       io_ncdf = 1,</span><br><span class="line">!            The output for plots is made in netcdf format</span><br><span class="line">!            At present only available for ISOL = 1 or 2</span><br><span class="line">! ----------------------------------------------------------------------</span><br><span class="line">       zeff = 1.5,</span><br><span class="line">!                      If Zeff is &gt;= 1._r8 it will be used throughout</span><br><span class="line">!                                  &lt; 1._r8  it will be reevaluated.</span><br><span class="line">       iclres = 0</span><br><span class="line">!                      iclres = 1 adds collisions around isolated ion-ion </span><br><span class="line">!                                 resonances. Use with care!</span><br><span class="line">!                      dnures = Width (cm) / tnures = strength (a.u.)</span><br><span class="line">       dnures = 5.0</span><br><span class="line">       tnures = 10.0</span><br><span class="line">!</span><br><span class="line">       scratchpath = &#x27;/tmp/&#x27;</span><br><span class="line">       timing_on = .true.</span><br><span class="line">       pcblock = 4</span><br><span class="line"> /</span><br></pre></td></tr></table></figure>
<p><span style='background: pink'>以上参数中被框起来作了详细说明的部分都是经常需要更改的参数.</span></p>
<h3 id="equidata"><a href="#equidata" class="headerlink" title="equidata"></a>equidata</h3><p>设置控制平衡的参数(包括 equigs, profnt 等文件)的位置.</p>
<p>首先是总体的控制参数, 其中比较重要的有: <code>igsmhd</code>, <code>dist_plawall(1/2/3/4)</code>, <code>idprof</code>, <code>inputpath</code>, <code>profnt_file</code> 以及 <code>equil_file</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &amp;equidata</span><br><span class="line">!</span><br><span class="line">!  Read from subroutine t4_equi_master in module t4_mod_equil</span><br><span class="line">!</span><br><span class="line">      igsmhd = 1,</span><br><span class="line">!                               = 1: from file produced by i2mex</span><br><span class="line">!                               = 0: analytic</span><br><span class="line">!</span><br><span class="line">      intchb = 7</span><br><span class="line">!                               &lt;=0: spline interpolation</span><br><span class="line">!                               &gt;0: chebyshev interpolation</span><br><span class="line">!                                   of order m = min(12, max(5,intchb))</span><br><span class="line">      dist_plafars = 0.</span><br><span class="line">!                               Distance plasma-faraday shield (cm)</span><br><span class="line">!                               (counted from scrape-off edge)</span><br><span class="line">      dist_plaant = 5.0</span><br><span class="line">!                               Distance plasma-antenna (cm)</span><br><span class="line">!                               (idem, .ge. dist_plafars)</span><br><span class="line">      dist_plawall(1) = 12.0</span><br><span class="line">      dist_plawall(2) = 16.</span><br><span class="line">      dist_plawall(3) =  8.</span><br><span class="line">      dist_plawall(4) = 16.</span><br><span class="line">!                              Distance plasma-wall (cm)</span><br><span class="line">!                              (1-4) : outer, up, inner, down</span><br><span class="line">!                              (must be &gt; dist_plaant)</span><br><span class="line">      idprof = 0</span><br><span class="line">!                              =  1 : Profiles from external file</span><br><span class="line">!                              =  0 : analytic profiles</span><br><span class="line">!</span><br><span class="line">      inputpath   = &#x27;./&#x27;</span><br><span class="line">      profnt_file = &#x27;profnt_62585.02800&#x27;</span><br><span class="line">!            where the file of profile data.</span><br><span class="line">      equil_file  = &#x27;equigs_038204.data&#x27;</span><br><span class="line">!            where the equigs file prepared by toricmode = &quot;equil&quot;.</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<p>如果上面的参数中设置了 <code>igsmhd = 0</code> 或者 <code>idprof = 0</code>, 那么还需要对应解析计算的参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! ------------------------------------------------------------------------</span><br><span class="line">!  The following data are used only with a default analytic equilibrium</span><br><span class="line">!  (igsmhd = 0).</span><br><span class="line">!</span><br><span class="line">      rtor   = 167.0        ! Major radius (cm)</span><br><span class="line">      rplasm = 44.0         ! Plasma radius (cm)</span><br><span class="line">!</span><br><span class="line">      ashift = 5.0          ! Shafranov Shift</span><br><span class="line">      aellip = 1.00         ! Ellipticity on axis</span><br><span class="line">      sellip = 1.60         ! Ellipticity at separatrix</span><br><span class="line">      strian = -0.22        ! Triangularity at separatrix</span><br><span class="line">      iudsym = 1</span><br><span class="line">      azvert = 0.0</span><br><span class="line">      strigz = 0.0</span><br><span class="line">      sp_xs1 = 0.0</span><br><span class="line">!</span><br><span class="line">      bzero  = 1.97         ! Magnetic field at the geometric center</span><br><span class="line">      aicurr = 830.         ! Toroidal current (kA)</span><br><span class="line">      ppjte = 2.0</span><br><span class="line">      ppjti = 1.5</span><br><span class="line">!</span><br><span class="line">! -----------------------------------------------------------------------</span><br><span class="line">!  The following data are used only with analytic profiles (iprodf = 0)</span><br><span class="line">!</span><br><span class="line">      nspec  = 2</span><br><span class="line">!                               Number of ion species</span><br><span class="line">!                               Should not exceed parameter nspmx</span><br><span class="line">      mainsp = 1             ! Reference species (for charge neutrality)</span><br><span class="line"></span><br><span class="line">      atm(1) = 2.            ! Atomic mass</span><br><span class="line">      atm(2) = 3.</span><br><span class="line">!     atm(3) = 2. </span><br><span class="line">!     atm(4) = 16.</span><br><span class="line"></span><br><span class="line">      azi(1) = 1.            ! Atomic charge</span><br><span class="line">      azi(2) = 2.</span><br><span class="line">!     azi(3) = 1.</span><br><span class="line">!     azi(4) = 7.</span><br><span class="line"></span><br><span class="line">      aconc(2) = 0.22        ! Concentrations (n_i/n_e)</span><br><span class="line">!     aconc(3) = 0.02  </span><br><span class="line">!     aconc(4) = 0.0045</span><br><span class="line"></span><br><span class="line">      denec  = 5.0E13        ! Central electron density (cm^-3)</span><br><span class="line">      tempec = 4          ! Central electron temperature (keV)</span><br><span class="line"></span><br><span class="line">      tempic(1) = 3.5      ! Central ion temperature (keV)</span><br><span class="line">      tempic(2) = 3.5 </span><br><span class="line">!     tempic(3) = 8.0  </span><br><span class="line"></span><br><span class="line">      ppnei = 2.0            ! Inner power in the density profile</span><br><span class="line">      ppnee = 0.500          ! Outer power in the density profile</span><br><span class="line"></span><br><span class="line">      pptei = 2.0       ! Inner power in the electron temperature profile</span><br><span class="line">      pptee = 0.5       ! Outer power in the electron temperature profile</span><br><span class="line"></span><br><span class="line">      pptii(1) = 2.0    ! Inner power in the ion temperature profile</span><br><span class="line">      pptie(1) = 0.5    ! Outer power in the ion temperature profile</span><br><span class="line">      pptii(2) = 2.0  </span><br><span class="line">      pptie(2) = 0.5  </span><br><span class="line">!     pptii(3) = 4.0  </span><br><span class="line">!     pptie(3) = 1.5  </span><br><span class="line"></span><br><span class="line">      dnsepr = 0.5E13,    ! Density at the last closed surface</span><br><span class="line">      tesepr = 0.20,      ! Electron temperature at the last closed surface</span><br><span class="line">      tisepr(1) = 0.20,   ! Ion temperature at the last closed surface</span><br><span class="line">      tisepr(2) = 0.20,</span><br><span class="line">!     tisepr(3) = 10.,</span><br><span class="line"></span><br><span class="line">      so_thickness = 0., ! Scrape-off thickness (cm)</span><br><span class="line">      gldn   = 3.0,      ! Density gradient length in scrape-off</span><br><span class="line">      glte   = 3.,       ! Electron temperature gradient length in scrape-off</span><br><span class="line">      glti(1)   = 3.,    ! Ion temperature gradient length in scrape-off</span><br><span class="line">      glti(2)   = 3.,</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<h3 id="gfreadinp"><a href="#gfreadinp" class="headerlink" title="gfreadinp"></a>gfreadinp</h3><p>用于设置 gfile 文件的位置, 只在 <code>toricmode = &quot;equil&quot;</code> 时会被读取.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &amp;gfreadinp</span><br><span class="line">!</span><br><span class="line">! Read from subroutine gfread in module t4_mod_toi2mex</span><br><span class="line">!</span><br><span class="line">    gfile= &#x27;H2DNv3_2g033332.00000&#x27;</span><br><span class="line">!</span><br><span class="line">    nmhd     = 165              ! number of radial psi points default=201</span><br><span class="line">    ntheta   = 129              ! number of &quot;theta&quot; points default = 129</span><br><span class="line"></span><br><span class="line">    i2mex_LAST_NORM_SURFACE_IS = 0.95</span><br><span class="line">!                               ! Name speaks for itself</span><br><span class="line">    ic1 = 2                     ! index of first (non-singular) surface</span><br><span class="line">    inc = -1                    ! index of last surface</span><br><span class="line">!                               ! (-1: makes it equal to npsi)</span><br><span class="line">    imom1 =  10                 ! Number of Fourier modes per mag. surface</span><br><span class="line"> /</span><br></pre></td></tr></table></figure>
<p>一般来说只需要设置 gfile 文件相对于前文 <code>inputpath</code> 参数的相对路径即可, 另外一些自定义的参数可以在官方文件中查找对应的解释.</p>
<h3 id="ssfpqlinp-qlmininp-tofppmodinp-diaginp"><a href="#ssfpqlinp-qlmininp-tofppmodinp-diaginp" class="headerlink" title="ssfpqlinp, qlmininp, tofppmodinp, diaginp"></a>ssfpqlinp, qlmininp, tofppmodinp, diaginp</h3><p>剩下的设置基本不需要更改, 具体的细节也可以在官方文档中找到. 只将以上部分的内容改成不同案例对应的参数已经足够正常的程序运行了.</p>
<hr>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>接下来用 <span style='background: yellow'>和龙-2</span> 的平衡位形(<span style='background: #B6D1F9'>H2DNv3_2g033332.00000</span>)和典型的密度、温度剖面(<span style='background: #B6D1F9'>剖面1002-ti=1.5te.xlsx</span>)来计算一个实例.</p>
<h3 id="用-i2mex-生成平衡文件"><a href="#用-i2mex-生成平衡文件" class="headerlink" title="用 i2mex 生成平衡文件"></a>用 i2mex 生成平衡文件</h3><p>第一步需要使用 i2mex 程序将通常的 gfile 文件转化为 TORIC 程序求解波动方程时需要的 equigs 文件. 这一步只需要在 torica.inp 文件中对应位置处设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toricmode = &quot;equil&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gfile= &#x27;H2DNv3_2g033332.00000&#x27;</span><br></pre></td></tr></table></figure>
<p>通过 <code>sbatch runth_Ptoric</code> 命令提交任务后等待程序运行, 之后会生成 <code>fort.22</code> 文件, 该文件就是 TORIC 运行所需的平衡文件, 下图是其和 gfile 文件的区别:</p>
<center>
<table><tr>
<td><img src="https://image.tabirstrees.top/images/2025/02/22/20250222161430848.png" width="400" border=1/></td>
<td><img src="https://image.tabirstrees.top/images/2025/02/22/20250222161519050.png" width="400" border=1/></td>
</tr></table>
</center>

<center id='f1'><span style='font-weight:bold'>Fig 1. The left is "gfile" file and the right one is the "equigs" file used in TORIC</span></center>

<p>这里如果我们直接将 <code>fort.22</code> 文件放进 <code>torica.inp</code> 对应的位置可能会引起报错, 最好先改成 <code>XXX.dat</code> 的文件名格式.</p>
<h3 id="准备剖面文件"><a href="#准备剖面文件" class="headerlink" title="准备剖面文件"></a>准备剖面文件</h3><p>平衡文件准备好之后, 还需要按照 TORIC 读取剖面文件的方式准备剖面文件, 根据手册, 读取剖面文件的程序用以下格式(伪代码)进行:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(lun22,<span class="string">&#x27;(A10,4i4)&#x27;</span>)  var_name, nprodt, nspec, mainsp,</span><br><span class="line">    &amp;                            kdiff_itemp</span><br><span class="line"></span><br><span class="line">  var_name    (for legibility)</span><br><span class="line">  nprodt      <span class="keyword">number</span> of points <span class="keyword">in</span> the radial variable psi</span><br><span class="line">  nspec       <span class="keyword">number</span> of ion species</span><br><span class="line">  mainsp      species to be used to impose charge neutrality</span><br><span class="line">  kdiff_itemp Control of individual ion temperature profiles</span><br><span class="line">              = <span class="number">0</span> - <span class="built_in">All</span> ion species have the same temperature</span><br><span class="line">                    (the <span class="keyword">file</span> <span class="keyword">contains</span> <span class="keyword">only</span> one T_i profile)</span><br><span class="line">              = <span class="number">1</span> - Each ion species has a different temperature</span><br><span class="line">                    (the <span class="keyword">file</span> must contain NSPEC t_i profiles)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>  isp=<span class="number">1</span>,nspec</span><br><span class="line">           read(lun22,<span class="string">&#x27;(2i4)&#x27;</span>)  iatm, iazi</span><br><span class="line">           atm(isp) = iatm</span><br><span class="line">           azi(isp) = iazi</span><br><span class="line">        <span class="keyword">enddo</span></span><br><span class="line"></span><br><span class="line">  atm(i)      Atomic mass of soecies i</span><br><span class="line">  azi(i)      Atomic charge of species i</span><br><span class="line"></span><br><span class="line">        read(lun22,<span class="string">&#x27;(A10)&#x27;</span>)  var_name</span><br><span class="line">        read(lun22,<span class="string">&#x27;(5E16.9)&#x27;</span>)  tbpsi</span><br><span class="line"></span><br><span class="line">  tbpsi:      mesh points <span class="keyword">in</span> the radial variable psi</span><br><span class="line"></span><br><span class="line">        read(lun22,<span class="string">&#x27;(A10)&#x27;</span>)  var_name</span><br><span class="line">        read(lun22,<span class="string">&#x27;(5E16.9)&#x27;</span>)  tbne</span><br><span class="line"></span><br><span class="line">  tbne:       electron density profile (cm^-<span class="number">3</span>) on the mesh tbpsi</span><br><span class="line"></span><br><span class="line">        read(lun22,<span class="string">&#x27;(A10)&#x27;</span>)  var_name</span><br><span class="line">        read(lun22,<span class="string">&#x27;(5E16.9)&#x27;</span>)  tbte</span><br><span class="line"></span><br><span class="line">  tbte:     electron temperature (keV) on the mesh tbpsi</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> isp=<span class="number">1</span>,nspec</span><br><span class="line">           <span class="keyword">if</span>(isp .eq. mainsp)  <span class="keyword">cycle</span></span><br><span class="line">           read(lun22,<span class="string">&#x27;(A10)&#x27;</span>)  var_name</span><br><span class="line">           read(lun22,<span class="string">&#x27;(5E16.9)&#x27;</span>)  tbni(<span class="number">1</span>:nprodt,isp)</span><br><span class="line">        <span class="keyword">enddo</span></span><br><span class="line"></span><br><span class="line">  tbni(isp)   ion density profile (cm^-<span class="number">3</span>) on the mesh tbpsi</span><br><span class="line">              NOTE: the profile of MAINSP is evaluated by TORIC</span><br><span class="line">                    imposing charge neutrality</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> isp=<span class="number">1</span>,nsptmp</span><br><span class="line">           read(lun22,<span class="string">&#x27;(A10)&#x27;</span>)  var_name</span><br><span class="line">           read(lun22,<span class="string">&#x27;(5E16.9)&#x27;</span>)  tbti(<span class="number">1</span>:nprodt,isp)</span><br><span class="line">        <span class="keyword">enddo</span></span><br><span class="line"></span><br><span class="line">  tbti:     ion temperature (keV) on the mesh tbpsi</span><br><span class="line">            NOTE: TORIC sets nsptmp = <span class="number">1</span>     <span class="keyword">if</span> kdiff_itemp = <span class="number">0</span></span><br><span class="line">                             nsptmp = nspec <span class="keyword">if</span> kdiff_itemp = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><span style='background: pink'>值得注意的是, 文件的第一行在</span> <code>var_name</code> <span style='background: pink'>后应该还有五个参数而非四个, 如果按照手册中的四个参数进行剖面文件的准备将会报错</span>, 经过查看源代码 <code>t4_mod_profnt.F</code>, 确认了第一行的参数应该是:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(lun22,<span class="string">&#x27;(A10,5i4)&#x27;</span>)  var_name, nprodt, nspec, mainsp,</span><br><span class="line">    &amp;                            kdiff_idens, kdiff_itemp</span><br><span class="line"></span><br><span class="line">  var_name    (for legibility)</span><br><span class="line">  nprodt      <span class="keyword">number</span> of points <span class="keyword">in</span> the radial variable psi</span><br><span class="line">  nspec       <span class="keyword">number</span> of ion species</span><br><span class="line">  mainsp      species to be used to impose charge neutrality</span><br><span class="line">  kdiff_idens Control of individual ion density profiles</span><br><span class="line">  kdiff_itemp Control of individual ion temperature profiles</span><br></pre></td></tr></table></figure>
<p>这里我们也简单的写了一个对应的 Python 脚本来进行剖面文件的准备:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 引入需要的函数库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> fortranformat <span class="keyword">as</span> ff</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 读取 xlsx 文件</span></span><br><span class="line">path = <span class="string">&quot;profile.xlsx&quot;</span></span><br><span class="line">df1 = pd.read_excel(path, header=<span class="number">0</span>)</span><br><span class="line">psi = df1.iloc[:, [<span class="number">0</span>]].values</span><br><span class="line">ne = (df1.iloc[:, [<span class="number">2</span>]].values) * <span class="number">1e19</span> / <span class="number">1e6</span></span><br><span class="line">ni = df1.iloc[:, [<span class="number">3</span>]].values / <span class="number">1e6</span></span><br><span class="line">Te = df1.iloc[:, [<span class="number">4</span>]].values</span><br><span class="line">Ti = df1.iloc[:, [<span class="number">5</span>]].values</span><br><span class="line">i_charge = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">i_mass = [<span class="number">1</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入少子的情形</span></span><br><span class="line">i_X = [<span class="number">0.06</span>]</span><br><span class="line">n_minority = ne * np.array(i_X)</span><br><span class="line">n_main = (</span><br><span class="line">    ne - np.reshape(np.<span class="built_in">sum</span>(np.array(i_charge[<span class="number">1</span>:]) * n_minority, <span class="number">1</span>), (<span class="number">201</span>, <span class="number">1</span>))</span><br><span class="line">) / np.array(i_charge[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 写入文件</span></span><br><span class="line">pf = <span class="built_in">open</span>(<span class="string">&quot;profnt_ENN_test_0.06.dat&quot;</span>, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line"><span class="comment"># first line: filename;number of point node;ion specise;main ions;temperature setup</span></span><br><span class="line">linewrite1 = ff.FortranRecordWriter(<span class="string">&quot;(A10,5i4)&quot;</span>)</span><br><span class="line">line1 = linewrite1.write([<span class="string">&quot;Prof_ENN&quot;</span>, <span class="number">201</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">pf.writelines(line1 + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># mass and charge of each ion</span></span><br><span class="line">linewrite2 = ff.FortranRecordWriter(<span class="string">&quot;(2i4)&quot;</span>)</span><br><span class="line">line2 = linewrite2.write([<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">3</span>])</span><br><span class="line">pf.writelines(line2 + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># linewrite_h = ff.FortranRecordWriter(&quot;(A10)&quot;)</span></span><br><span class="line"><span class="comment"># psi</span></span><br><span class="line"><span class="comment"># pf.writelines(linewrite_h.write([&quot;Psi&quot;]) + &quot;\n&quot;)</span></span><br><span class="line">pf.writelines(<span class="string">&quot;Psi&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">number_writer = ff.FortranRecordWriter(<span class="string">&quot;(5E16.9)&quot;</span>)</span><br><span class="line">psiwrite = number_writer.write(psi)</span><br><span class="line">pf.writelines(psiwrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># ne</span></span><br><span class="line"><span class="comment"># pf.writelines(&quot;ne [cm^-3]\n&quot;)</span></span><br><span class="line"><span class="comment"># pf.writelines(linewrite_h.write([&quot;ne [cm^-3]&quot;]) + &quot;\n&quot;)</span></span><br><span class="line">pf.writelines(<span class="string">&quot;ne [cm^-3]&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">newrite = number_writer.write(ne)</span><br><span class="line">pf.writelines(newrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># Te</span></span><br><span class="line"><span class="comment"># pf.writelines(&quot;Te [keV]\n&quot;)</span></span><br><span class="line"><span class="comment"># pf.writelines(linewrite_h.write([&quot;Te [keV]&quot;]) + &quot;\n&quot;)</span></span><br><span class="line">pf.writelines(<span class="string">&quot;Te [keV]&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tewrite = number_writer.write(Te)</span><br><span class="line">pf.writelines(tewrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># ni</span></span><br><span class="line"><span class="comment"># pf.writelines(&quot;ni_D [cm^-3]\n&quot;)</span></span><br><span class="line"><span class="comment"># pf.writelines(linewrite_h.write([&quot;nD [cm^-3]&quot;]) + &quot;\n&quot;)</span></span><br><span class="line">pf.writelines(<span class="string">&quot;nD [cm^-3]&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">niwrite = number_writer.write(<span class="built_in">list</span>(n_main))</span><br><span class="line">pf.writelines(niwrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># Te</span></span><br><span class="line"><span class="comment"># pf.writelines(&quot;Te [keV]\n&quot;)</span></span><br><span class="line"><span class="comment"># pf.writelines(linewrite_h.write([&quot;TD [keV]&quot;]) + &quot;\n&quot;)</span></span><br><span class="line">pf.writelines(<span class="string">&quot;TD [keV]&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tiwrite = number_writer.write(Ti)</span><br><span class="line">pf.writelines(tiwrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">pf.writelines(<span class="string">&quot;nH [cm^-3]&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">niwrite = number_writer.write(<span class="built_in">list</span>(n_minority))</span><br><span class="line">pf.writelines(niwrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># Te</span></span><br><span class="line"><span class="comment"># pf.writelines(&quot;Te [keV]\n&quot;)</span></span><br><span class="line"><span class="comment"># pf.writelines(linewrite_h.write([&quot;TD [keV]&quot;]) + &quot;\n&quot;)</span></span><br><span class="line">pf.writelines(<span class="string">&quot;TH [keV]&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tiwrite = number_writer.write(Ti)</span><br><span class="line">pf.writelines(tiwrite + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">pf.close()</span><br></pre></td></tr></table></figure>
<p>最终得到的文件形式如图所示:</p>
<p><img alt="picture 3" src="https://image.tabirstrees.top/images/2025/02/22/20250222161641831.png"/></p>
<center id='f2'><span style='font-weight:bold'>Fig 2. The preview of profile data used in TORIC</span></center>

<p>这里我们采用 H(B11) 作为加热场景, 少子浓度设置为 6%.</p>
<h3 id="设置输入文件-torica-inp"><a href="#设置输入文件-torica-inp" class="headerlink" title="设置输入文件 torica.inp"></a>设置输入文件 <code>torica.inp</code></h3><p>此处为了简单起见, 我们仅针对 <span style='background: yellow'>和龙-2</span> 的天线频率以及网格划分进行修改, 根据 <span style='background: yellow'>和龙-2</span> 的基本参数估算各离子的共振线, 得到得结果如图所示:</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222162300591.png" alt="picture 4"></p>
<center id='f3'><span style='font-weight:bold'>Fig 3. The resonance line of different particles.</span></center>

<p>可以看到对于 H(B11) 体系要保证在中心位置处吸收需要频率大概位于 50MHz(H 基频) 或者 30MHz(B11 谐频), 这里我们先选取 30MHz 作为天线的发射频率. 因此在上面的输入文件中我们只修改以下几个部分:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">toricmode = <span class="string">&quot;toric&quot;</span>,</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">nvrb   =   3,</span><br><span class="line">nelm   = 450,</span><br><span class="line">ntt    =  256,</span><br><span class="line">nmod   =  127,</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">freqcy = 30.0E6,</span><br><span class="line">nphi   =  18,</span><br><span class="line">antlen = 50,</span><br><span class="line">antlc  = 1.2,</span><br><span class="line">theant = 0.,</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">inputpath   = &#x27;./&#x27;</span><br><span class="line">profnt_file = &#x27;profnt_ENN_test_0.06.dat&#x27;</span><br><span class="line">equil_file  = &#x27;equigs.dat&#x27;</span><br></pre></td></tr></table></figure>
<p>其他参数保持原来的设置不变, 然后提交任务运行. 最终会生成三个文件: <code>fort.9</code>, <code>fort.10</code> 以及 <code>fort.21</code>. <code>fort.9</code> 是写入到文件中的程序输出(netCDF格式), <code>fort.10</code> 是文本格式的用于画图的数据文件, <code>fort.21</code> 是 netCDF 格式的画图数据文件.</p>
<p>通过读取 <code>fort.21</code> 中的结果绘制图件, 我们可以得到以下的结果:</p>
<p><img alt="picture 4" src="https://image.tabirstrees.top/images/2025/02/22/20250222164700655.png" /><br><!-- <img alt="picture 4" src="images/manulEplusandabsor_main.png" />   --></p>
<center id='f4'><span style='font-weight:bold'>Fig 4. The contour plot of the result.</span></center>

<p><img alt="picture 5" src="https://image.tabirstrees.top/images/2025/02/22/20250222165855947.png" />  </p>
<center id='f5'><span style='font-weight:bold'>Fig 5. Power absorption by different
particles along the radius direction.</span></center>

<p><img alt="picture 6" src="https://image.tabirstrees.top/images/2025/02/22/20250222165947053.png" />  </p>
<center id='f6'><span style='font-weight:bold'>Fig 6. Current Density Induced by Waves.</span></center>

<p>这里可以看到离子吸收并没有在中心位置, 结合图3考虑可能是波频率设置的不太恰当, 因为这里只是运行 TORIC 程序的一个简单示例, 就不对此展开深入的分析.</p>
<hr>
<h2 id="考虑离子尾部能量的情况"><a href="#考虑离子尾部能量的情况" class="headerlink" title="考虑离子尾部能量的情况"></a>考虑离子尾部能量的情况</h2><p>某些时候我们还需要考虑离子吸收能量之后形成超热尾部分布(suprathermal minority tails)的情况, 这需要在已经完成前述计算过程的基础上的通过调用 <code>SSFPQL</code> 模块求解准线性 Fokker-Planck 方程来估计离子的分布, 然后再一次迭代进 <code>TORIC</code> 主模块中计算.</p>
<p>由于我们此前对 <span style='background: yellow'>和龙-2</span> 的计算中离子没有产生超热尾端的分布(<span class='heimu'>也有可能是计算过程中出现了失误</span>), 所以这里采用做程序 BENCHMARK 时所用的 <span style='background: yellow'>CFETR</span> (He3)-D-T 加热体系(Chengyi Song et al. 2021)来举例. 模拟使用的参数以及结果如图7~图9所示:</p>
<center><img alt="picture 1" src="https://image.tabirstrees.top/images/2025/02/22/20250222170239706.png" /></center>  
<center id='f7'><span style='font-weight:bold'>Fig 7. The parameters of simulation for CFETR.</span></center>

<p><img alt="picture 2" src="https://image.tabirstrees.top/images/2025/02/22/20250222170757395.png"/></p>
<center id='f8'><span style='font-weight:bold'>Fig 8. The contour plot of the results for CFETR.</span></center>  

<center><img alt="picture 3" src="https://image.tabirstrees.top/images/2025/02/22/20250222170937314.png"/></center>  
<center id='f9'><span style='font-weight:bold'>Fig 9. Power absorption by different particles along the radius direction for CFETR.</span></center>

<h3 id="通过-SSFPQL-计算离子分布"><a href="#通过-SSFPQL-计算离子分布" class="headerlink" title="通过 SSFPQL 计算离子分布"></a>通过 <code>SSFPQL</code> 计算离子分布</h3><p>首先是在原有计算结果的基础上调用 <code>SSFPQL</code> 模块, 实际上该模块是通过读取前面讲到的 <code>fort.9</code> 文件(netCDF 格式的输出文件)来与 <code>TORIC</code> 主程序耦合, 这里我们需要在 <code>torica.inp</code> 中设置 <code>/ssfpqlinp/</code> 部分的参数, 在此案例中如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! *********************************************************************</span><br><span class="line">!   Namelist entries needed by SSFPQL (quasilinear solver for the ions)</span><br><span class="line">! *********************************************************************</span><br><span class="line">!</span><br><span class="line">!     namelist /ssfpqlinp/</span><br><span class="line">!    &amp;    power, iex_sumnph, joutql, nrdpsi, legmod, idlout, iwrdql,</span><br><span class="line">!    &amp;    path_to_t4data, t4data_file, timing_on</span><br><span class="line">!</span><br><span class="line">! -------------------------------------------------------------------- !</span><br><span class="line"> &amp;ssfpqlinp</span><br><span class="line">!</span><br><span class="line">!  Read by subroutine t4_ssfpql in module t4_mod_ssfpql</span><br><span class="line">!</span><br><span class="line">      power = 3.6,</span><br><span class="line">!                             Total absorbed power (MW)</span><br><span class="line">      emxfac(1) = 200.,</span><br><span class="line">      emxfac(2) = 100.,</span><br><span class="line">!                             multipliers of T_i in the definition </span><br><span class="line">!                             of the max energy in the velocity mesh</span><br><span class="line">      iex_sumnph = 0,</span><br><span class="line">!                             Control of input from TORIC</span><br><span class="line">!                             = 0 - only one toroidal mode</span><br><span class="line">!                             = 1 - weighted superposition of several toroidal modes</span><br><span class="line">!                             (performed by t4_sumnph, with its own namelist)</span><br><span class="line">      joutql = 1,</span><br><span class="line">!                             Control of printed output:</span><br><span class="line">!                             = 0 - essential results (recommended)</span><br><span class="line">!                             = 1 - detailed results</span><br><span class="line">      nrdpsi = 46,</span><br><span class="line">!                             Number of radial points (uniform in psi) where</span><br><span class="line">!                             the qlfp equation for ions is to be solved.</span><br><span class="line">      legmod = 6,</span><br><span class="line">!                             number of Legendre polynomials in the ion</span><br><span class="line">!                             distribution functions</span><br><span class="line">!                             Recommended: 5 &lt;= legmod &lt;= 7</span><br><span class="line">      nptu   = 201,</span><br><span class="line"></span><br><span class="line">      idlout = 1,</span><br><span class="line">!                             Plots of distribution functions, power profiles, etc.</span><br><span class="line">!                             = 1 - done</span><br><span class="line">!                             = 0 - skipped.</span><br><span class="line">      iwdisk = 1,</span><br><span class="line">!                             1 - netCDF format</span><br><span class="line">!                             -1 - binary</span><br><span class="line">      path_to_t4data  = &#x27;./&#x27;</span><br><span class="line">!                             output of toricmode = &quot;toric&quot; (named &quot;fort.9&quot;)</span><br><span class="line">      t4data_file     = &#x27;fort.9&#x27;</span><br><span class="line">      iwrdql = 1,</span><br><span class="line">!                             Output for iteration by TORIC with nonMaxwellian</span><br><span class="line">!                             minority distribution.</span><br><span class="line">      timing_on = .true.</span><br><span class="line">!                             Control of time trace:</span><br><span class="line">!                             .true.  - time tracing on</span><br><span class="line">!                             .false. - time tracing off</span><br><span class="line"> /</span><br><span class="line">! -------------------------------------------------------------------- ! </span><br></pre></td></tr></table></figure>
<p>同时需要把运行模式改成对应的设置, 即:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toricmode = ssfpql,</span><br></pre></td></tr></table></figure>
<p>提交任务后会得到两个文件, <code>fort.8</code> 以及 <code>fort.12</code>. 前者是后续程序运行的输入文件, 后者是任务输出文件, 两者都是文本格式, 可以直接打开. 因为要用到 <code>fort.8</code>, 一般要对其进行查看, 我们的案例中如图10所示:</p>
<center>
<table><tr>
<td><img src="https://image.tabirstrees.top/images/2025/02/22/20250222171007327.png" width="400" border=1/></td>
<td><img src="https://image.tabirstrees.top/images/2025/02/22/20250222171025853.png" width="400" border=1/></td>
</tr></table>
</center>
<center id='f10'><span style='font-weight:bold'>Fig 10. The input file for 'isol = 2' to read the minority non-maxwellian profile.</span></center>

<p><span style='background: pink'>需要注意的是,</span> fort.8 <span style='background: pink'>文件中起始位置通常是主要离子(文件开头的两个数字分别表示离子种类(nspec)和剖面网格, 主离子的离子种类为 1)的非麦克斯韦分布的剖面(左图), 而后续的</span> <code>QLMINH</code> <span style='background: pink'>模块需要少子(nspec = 2)的非麦克斯韦剖面, 因此需要删掉前面主离子的部分内容(右图)</span></p>
<h3 id="再次运行-TORIC-主程序得到结果"><a href="#再次运行-TORIC-主程序得到结果" class="headerlink" title="再次运行 TORIC 主程序得到结果"></a>再次运行 TORIC 主程序得到结果</h3><p>得到少子的非麦克斯韦剖面后, 就可以再次以 <code>isol = 2</code> 的运行模式再次运行 TORIC 主程序得到结果, 此时还需要设置读取的少子剖面文件的位置, 对 <code>torica.inp</code> 做如下更改:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      toricmode = &quot;toric&quot;,</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">          isol  = 2,</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">            .</span><br><span class="line">&amp;qlmininp</span><br><span class="line">!</span><br><span class="line">!  Read by subroutione t4_qlm_init in t4_mod_qlminh</span><br><span class="line">!</span><br><span class="line">      path_to_qldata = &#x27;./&#x27;</span><br><span class="line">      qlmin_file = &#x27;fort.8&#x27;</span><br><span class="line">!            The path of input (non-maxwellian profile for minority)</span><br><span class="line"> /</span><br></pre></td></tr></table></figure>
<p>重新运行之后得到三个文件(<code>fort.9/10/21</code>), 并利用 <code>fort.21</code> 画图, 如图所示:</p>
<center><img alt="picture 6" src="https://image.tabirstrees.top/images/2025/02/22/20250222171114778.png"/></center> 
<center id='f11'><span style='font-weight:bold'>Fig 11. The contour plot of the results for CFETR when the minority superthermal tail has been considered.</span></center> 

<center><img alt="picture 7" src="https://image.tabirstrees.top/images/2025/02/22/20250222171137116.png"/></center>  
<center id='f12'><span style='font-weight:bold'>Fig 12. Power absorption by different particles along the radius direction for CFETR when the minority superthermal tail has been considered.</span></center>

<center><img alt="picture 8" src="https://image.tabirstrees.top/images/2025/02/22/20250222171154509.png"/></center>  
<center id='f13'><span style='font-weight:bold'>Fig 13. Current Driven by different waves along the radius direction for CFETR when the minority superthermal tail has been considered.</span></center>

<p>由于只是作为演示, 这里的结果就不做具体分析.</p>
<hr>
<p>以上就是 TORIC 程序的一个简单介绍, 这个类似于文档的东西是给了解相关领域(托克马克磁约束聚变离子回旋加热)的人准备的, 实际上只是一个简化版本的程序操作手册, 给有需要的人提供参考<span class='mohu'>(互联网上实在是找不到类似的东西, 同时有项目需要写这么一份文档, 所以分享出来. 真正做这个领域, 需要这份文档的人应该比较少才对.)</span>.</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>等离子体物理</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>聚变</tag>
        <tag>离子回旋加热</tag>
        <tag>数值模拟</tag>
        <tag>程序</tag>
      </tags>
  </entry>
  <entry>
    <title>理想磁流体平衡</title>
    <url>/2023/02/13/PPB-idelMHDequi/</url>
    <content><![CDATA[<center><h1>理想磁流体平衡</h1></center>

<div class="note info flat"><p>本文是王晓刚老师《等离子体物理基础》第二章内容的笔记整理，方便此后查阅</p>
</div>
<p>从物理上来看，一个系统总是趋于能量最低的平衡状态，此时的运动形式相对简单。一般来说，我们将磁流体的平衡指的是<strong>力学平衡（磁流体力学的平衡）</strong>，而非热力学平衡（速度分布的平衡，对应的是动理学理论的平衡）。这种平衡对于可控核聚变来说是非常重要的，我们需要将温度极高的等离子体通过外部力场约束在固定范围内以提供聚变产生的原材料，完成这一目标的首要条件就是做到磁流体平衡。</p>
<h2 id="磁场的一般表示"><a href="#磁场的一般表示" class="headerlink" title="磁场的一般表示"></a>磁场的一般表示</h2><p>根据Maxwell方程组中的高斯定理我们知道：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla \cdot \mathbfit{B} = \frac{\partial B_x}{\partial x}+\frac{\partial B_y}{\partial y}+\frac{\partial B_z}{\partial z} = 0
    \end{aligned}
\end{equation}</script><p>这就是说磁场的三个分量并非独立的，因此实际上磁场可以只用两个分量来表示。通过矢量恒等式：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla \cdot (\vec{A} \times \vec{B}) = (\nabla \times \vec{A} ) \cdot \vec{B} - \vec{A} \cdot (\nabla \times \vec{B})
    \end{aligned}
\end{equation}</script><p>再者一个矢量可以写成标量的梯度形式，因此我们选择将描述磁场的两个分量表示成 $\nabla \alpha $, $ \nabla \beta$，有：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla \cdot (\nabla \times \vec{A}) = 0 \implies \mathbfit{B} = \nabla \alpha \times \nabla \beta
    \end{aligned}
\end{equation}</script><p>考虑直角坐标系下的磁力线方程（磁场$\mathbfit{B}$与磁力线的方向是一致的）：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}x}{B_x} = \frac{\mathrm{d}y}{B_y} = \frac{\mathrm{\,d}z}{B_z}
    \end{aligned}
\end{equation}</script><p>上述方程可以提取出两个独立的方程：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}y}{\mathrm{d}x} = \frac{B_y}{B_x}, \frac{\mathrm{d}z}{\mathrm{d}x} = \frac{B_z}{B_x}
    \end{aligned}
\end{equation}</script><p>这两个方程的解分别对应了两个三维空间中的曲面，曲面的交线（两个曲面方向导数的叉乘 $\mathbfit{B} = \nabla \alpha \times \nabla \beta$ ，这就正好对应了前面提到的描述磁场只需要两个独立的变量，即曲面 $C_{\alpha}, C_{\beta}$ ）即是磁力线。</p>
<p><img src="https://pica.zhimg.com/v2-ebc5a2913971e69f7d1376d20f6f7ef4_1440w.jpg" alt = "PPB-idelMHDequi-f1" width = "300"></p>
<center id='f1'><span style='font-weight:bold'>Fig 1 上述过程的几何描述</span></center>

<p>这两个曲面的选择可以是任意的，所以同一个磁场可能对应多种不同的选择进行描述。因此，我们进一步可以把磁场写成：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \mathbfit{B} = F(\psi) \nabla \zeta + \nabla \psi \times \nabla \zeta
    \end{aligned}
    \label{eq:bfield}
\end{equation}</script><p>这样就变成了一个正交曲线坐标系($\nabla \psi, \nabla \zeta, \nabla \chi = \nabla \psi \times \nabla \zeta$)所表示的磁场, 于是我们可以把磁力线方程写成:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}l}{B} = \frac{\mathrm{d}\psi}{\mathbfit{B} \cdot \nabla \psi} = \frac{\mathrm{d}\chi}{\mathbfit{B} \cdot \nabla \chi} = \frac{\mathrm{d}\zeta}{\mathbfit{B} \cdot \nabla \zeta}
    \end{aligned}
\end{equation}</script><p>的形式. 如果我们选取聚变中常用的”托卡马克环坐标系($\psi(r), \theta, z$)”, 则有:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}l}{B}  = \left(\frac{\mathrm{d}\psi}{B_r \mathrm{\,d}\psi/\mathrm{\,d}r} = \right) \frac{\mathrm{d}r}{B_r} = \frac{r \mathrm{d}\theta}{B_{\theta}} = \frac{\mathrm{d}z}{B_z}
    \end{aligned}
\end{equation}</script><h2 id="磁约束等离子体的力学平衡"><a href="#磁约束等离子体的力学平衡" class="headerlink" title="磁约束等离子体的力学平衡"></a>磁约束等离子体的力学平衡</h2><p>所谓力学平衡就是说等离子体的运动状态不随时间改变, 即 $\partial/\partial t = 0$. 我们通常所说的等离子体平衡就是指这种力学平衡(在运动状态不变的情况下, $\mathbfit{u} \not = 0$ 称为”稳态平衡”, $\mathbfit{u} = 0$ 称为”静态平衡”).</p>
<p>根据理想磁流体方程:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        n m_i \left(\frac{\partial \mathbfit{u}}{\partial t} + \mathbfit{u} \cdot \nabla \mathbfit{u}\right) = -\nabla p + \frac{(\nabla \times \mathbfit{B}) \times \mathbfit{B}}{4\pi}
    \end{aligned}
\end{equation}</script><p>等离子体平衡时有:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \rho_m (\mathbfit{u} \cdot \nabla \mathbfit{u}) = - \nabla p + \frac{(\nabla \times \mathbfit{B}) \times \mathbfit{B}}{4\pi}
    \end{aligned}
\end{equation}</script><p>如果是静态平衡则变成:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla p = \frac{(\nabla \times \mathbfit{B}) \times \mathbfit{B}}{4\pi} = \frac{\mathbfit{J} \times \mathbfit{B}}{c}\ (\text{忽略位移电流项})
    \end{aligned}
    \label{eq:1}
\end{equation}</script><p>这个时候我们看到这种两个叉乘在一起的一般都会利用矢量恒等式进行化简, 回去翻翻矢量恒等式的列表, 发现有 $\nabla (\mathbfit{A} \cdot \mathbfit{B}) = \mathbfit{A} \times (\nabla \times \mathbfit{B}) + \mathbfit{B} \times (\nabla \times \mathbfit{A}) + \mathbfit{A} \cdot \nabla \mathbfit{B} + \mathbfit{B} \cdot \nabla \mathbfit{A}$. 把这里的磁场带进去就有:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        (\nabla \times \mathbfit{B}) \times \mathbfit{B} = - \frac{\nabla B^2}{2} + \mathbfit{B} \cdot \nabla \mathbfit{B}
    \end{aligned}
\end{equation}</script><p>结合公式 $\eqref{eq:1}$ 于是我们可以得到在静态平衡下</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla \left(p + \frac{B^2}{8\pi}\right) = \frac{\mathbfit{B} \cdot \nabla \mathbfit{B}}{4\pi} = \hat{b} \nabla_{\parallel} \left(\frac{B^2}{8\pi}\right) + \pmb{\kappa} \frac{B^2}{4\pi}
    \end{aligned}
\end{equation}</script><p>其中, 磁场单位矢量 $\hat{b} \equiv \mathbfit{B}/B$, 平行磁场的梯度 $\nabla_{\parallel} \equiv \hat{b} \cdot \nabla$, $\pmb{\kappa} \equiv \hat{b} \cdot \nabla \hat{b} = \nabla_{\parallel} \hat{b}$. 根据矢量与张量的点乘运算</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        &\mathbf{A} \cdot \mathbfit{A} = \sum_{ij} T_{ij}\mathbfit{e}_i\mathbfit{e}_j \cdot \sum_{l} f_l\mathbfit{e}_l = \sum_{ijl} T_{ij}f_{l}\mathbfit{e}_{i} \delta_{jl} = \sum _{ij} T_{ij} f_{j} e_{i}, \\
        &\mathbfit{A} \cdot \mathbf{A} = \sum _{ij} f_{i} T_{ij} e_{j}
    \end{aligned}
\end{equation}</script><p>所有带有平行分量的张量都会消失, 所以很明显 $\pmb{\kappa}$ 是垂直磁场方向的. 于是上式还可以写成是分量的形式:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla_{\perp} \left(p + \frac{B^2}{8\pi}\right) = \pmb{\kappa} \frac{B^{2}}{4\pi},\ \nabla_{\parallel} p = 0
    \end{aligned}
    \label{eq:15}
\end{equation}</script><h2 id="磁面和磁通函数"><a href="#磁面和磁通函数" class="headerlink" title="磁面和磁通函数"></a>磁面和磁通函数</h2><p>对于任意变量都可以写成 $f = f(x,y)$ 形式的平板模型(slab model), 我们可以将 $\ref{eq:bfield}$ 取 $\zeta = -z, \psi = \psi(x,y)$ 来表示磁场:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \mathbfit{B} = -F(\psi) \hat{z} + \hat{z} \times \nabla \psi \equiv B_z(\psi) \hat{z} + \hat{z} \times \nabla \psi
    \end{aligned}
    \label{eq:B2}
\end{equation}</script><p>这里我们可以看到, $z$ 方向是和 $\psi$ 有关的量, 同时垂直与 $z$ 方向的矢量取到的是 $\nabla \psi$, 这样很明显可以看出 $\psi = \psi(x, y)$ 是磁矢势的 $z$ 方向分量, 我们可以将其称为<strong>磁通函数</strong>. </p>
<div class="note info flat"><p>关于为什么要这样取值, 我们考虑磁场表示形式公式 $\ref{eq:bfield}$, $\psi$ 和 $\zeta$ 所表示的定义于 $(x, y, z)$ 坐标上的两个曲面是相互垂直的, 平板模型中一个曲面定义在 $(x, y)$ 坐标上, 另一个必然定义于 $z$ 坐标. 而 $\zeta$ 在两项中都是梯度项 $\nabla \zeta$, 这样自然是将 $\zeta$ 取成和 $z$ 相关, 至于正负号的选择就直接带进去试一试, 然后取简单的那一种形式就OK了. <span class='mohu'>个人理解, 仅供参考!</span></p>
</div>
<p>然后我们再回到原本的”正交磁力线坐标”, 即 $(x, y, z) \to (\psi, \chi, z)$. 这里 $\chi$ 坐标满足 $\nabla \chi \parallel \hat{z} \times \nabla \psi$ (之前说过 $\psi, \chi, \zeta = -z$ 之间是相互垂直的). 那么很显然地必然会有磁场的分量在 $\nabla \chi$ 方向上, 即 $\mathbfit{B}_{\chi}$. 换句话说, 在 $(x, y)$ 平面内必然会有磁力线在 $\psi(x, y) = C(\text{常数})$ 的曲线上(三维空间中这条曲线沿着 $z$ 方向延伸成一个曲面, 实际上就是类似于等势面, 只不过只是磁势的一个分量的等势). 这样, 在两条曲线 $\psi = \psi_{1}, \psi = \psi_{2}$ 上随便找两个点连起来, 穿过这条连线(同样在三维空间中是一个曲面)的磁力线根数被定义为<strong>极向磁通量</strong>:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \iint_{\psi_{1} \to \psi_{2}} \mathbfit{B}_{x} \cdot \mathrm{\,d}\mathbfit{S}_{\psi, z} = \Psi_{\psi, \chi}
    \end{aligned}
\end{equation}</script><p>固定的 $\psi_{1}, \psi_{2}$ 之间的任意连线的极向磁通量一定相等. 这样我们在 $\psi_{1}$ 上选取 $x_{1}$, 在 $\psi_{2}$ 上选取 $x_{2}$, 完成对 $z$ 方向的积分后可以得到:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \iint _{\psi_{1} \to \psi_{2}} \mathbfit{B}_{x} \cdot \mathrm{\,d}\mathbfit{S}_{\psi, z} &= \underbrace{L_{z} \int_{x_{1}}^{x_{2}} B_y \mathrm{\,d}x = L_{z} \int_{x_{1}}^{x_{2}} \frac{\partial \psi}{\partial y} \mathrm{\,d}x}_{\text{因为}\psi\text{是磁势的}\hat{z}\text{分量}} \\
        &= L_{z} \int _{\psi_{1}}^{\psi_{2}} \mathrm{\,d}\psi = L_{z} (\psi_{2}-\psi_{1})
    \end{aligned}
\end{equation}</script><p>很显然我们可以得出结论: 磁通函数 $\psi(x, y)$ 是 $\hat{z}$ 方向上单位长度上的极向磁通量.</p>
<p>根据Maxwell方程组以及之前得到的理想磁流体平衡方程, 结合磁场表示式 $\ref{eq:B2}$ 还可以得到:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \mathbfit{J} &= \frac{c}{4\pi} \nabla \times \mathbfit{B} = \frac{c}{4\pi} \left(\frac{\mathrm{d}F}{\mathrm{d}\psi} \hat{z} \times \nabla \psi + \hat{z} \nabla ^{2} \psi\right), \\
        \nabla p &= \frac{\mathbfit{J} \times \mathbfit{B}}{c} = -\left(\nabla ^{2} \psi + F \frac{\mathrm{d}F}{\mathrm{d}\psi}\right) \frac{\nabla \psi}{4\pi}
    \end{aligned}
\end{equation}</script><p>可以看到, $\nabla p$ 仅仅只与 $\psi$ 有关, 上述方程的解应该有着 $p = p(\psi)$ 的形式, 那么在 $p = \text{常数}$ 的”面”上, 我们有磁通函数 $\psi = \text{常数}$ 的结论. 所以我们可以将这个曲面称为 <strong>“磁面”</strong>.</p>
<p><img src="https://pic1.zhimg.com/v2-107fd6fca2ee4205fed6074157b0b48a_1440w.jpg" alt="PPB-idelMHDequi-磁通量" width = "300"></p>
<center id='f2'><span style='font-weight:bold'>Fig 2. 上述过程的图像表示</span></center>

<p>利用 $p = p(\psi)$, 上述的方程可以进一步化简:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        &\frac{4\pi \nabla p(\psi)}{\nabla \psi} = -\nabla ^{2} \psi - F(\psi) \frac{\mathrm{d}F(\psi)}{\mathrm{d}\psi} \\
        &\implies \nabla ^{2} \psi = -4\pi \left(\frac{\nabla p(\psi)}{\nabla \psi} + F(\psi)\frac{\mathrm{d}F(\psi)}{4\pi \mathrm{d}\psi}\right) \\
        &\because \nabla p(\psi) = \frac{\mathrm{d}p}{\mathrm{d}\psi} \nabla \psi, F(\psi)\frac{\mathrm{d}F(\psi)}{\mathrm{d}\psi} = \frac{\mathrm{d}}{\mathrm{d}\psi} \frac{F(\psi)^{2}}{2} \\ 
        &\implies \nabla ^{2} \psi = -4\pi \frac{\mathrm{d}}{\mathrm{d}\psi} \left(p(\psi) + \frac{F(\psi)^{2}}{8\pi}\right) \\
    \end{aligned}
\end{equation}</script><p>再加上 $F(\psi)$ 是磁场的 $-z$ 分量(式 $\ref{eq:B2}$), 有:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla ^{2} \psi = -4\pi \frac{\mathrm{d}}{\mathrm{d}\psi} \left[p + \frac{B_{z}^{2}}{8\pi}\right]
    \end{aligned}
\end{equation}</script><p>我们称这个方程为 <strong>磁面方程</strong>, 其适用于各种坐标系.</p>
<p>事实上, 从式 $\ref{eq:15}$ 中我们可以得到: 沿着一条磁力线有 $p = \text{常数}$. 如果这个磁力线卷曲成一个曲面, 曲面上处处都有同一个 $p$, 曲面的法线由 $\nabla p = \nabla _{\perp} p$ 给出. 同时, 根据静态平衡的方程我们可以有: $\mathbfit{B} \perp \nabla p, \mathbfit{J} \perp \nabla p$, 所以电流也在这个表面上, 也就是磁面上.</p>
<p><img src="https://pic1.zhimg.com/v2-669e2ae15df9031231f9ca46243080dc_1440w.jpg" alt="PPB-idelMHDequi-f3" width = "300"></p>
<center id='f3'><span style='font-weight:bold'>Fig 3. 磁面, 压强梯度以及电流分布</span></center>

<h2 id="磁冻结"><a href="#磁冻结" class="headerlink" title="磁冻结"></a>磁冻结</h2><p>在流体力学中存在涡旋方程: $\partial \mathbfit{\omega}/\partial t = \nabla \times (\mathbfit{u} \times \mathbfit{\omega})$, 同时我们可以证明”涡旋”是冻结在流体中的, 即涡旋是和流体一起运动的. 在理想磁流体模型中, 磁场满足的磁感应方程具有和涡旋方程一致的形式: $\partial \mathbfit{B}/\partial t = \nabla \times (\mathbfit{u} \times \mathbfit{B})$. 我们可以合理的做出推测磁力线也是”冻结”在等离子当中的.</p>
<details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">王晓刚老师书中磁冻结效应的推导(没怎么看明白)</summary><div class="toggle-content"><p>将磁场的一般表示形式带入到磁感应方程中可以得到, 方程左边：</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\partial \mathbfit{B}}{\partial t} = \nabla \frac{\partial \alpha}{\partial t} \times \nabla \beta + \nabla \alpha \times \nabla \frac{\partial \beta}{\partial t} = \nabla \times \left(\frac{\partial \alpha}{\partial t} \nabla \beta - \frac{\partial \beta}{\partial t}\nabla \alpha\right)
    \end{aligned}
\end{equation}</script><p>方程右边: </p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla \times (\mathbfit{u} \times \mathbfit{B}) &= \nabla \times \left[\mathbfit{u} \times \left(\nabla \alpha \times \nabla \beta\right)\right] \\
        &= \nabla \times \left[\nabla \alpha (\mathbfit{u} \cdot \nabla \beta) - \nabla \beta (\mathbfit{u} \cdot \nabla \alpha)\right]
    \end{aligned}
\end{equation}</script><p>其中 $\mathbfit{u} \cdot \nabla \alpha(\beta)$ 得到一个标量, 再乘上 $\alpha$, 上式实际上是对一个标量的梯度做叉乘, 最终的结果为 0(很容易证明, 基础的高等数学场论知识). 于是有:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \nabla \times \left(\frac{\mathrm{d} \alpha}{\mathrm{d} t} \nabla \beta - \frac{\mathrm{d}  \beta}{\mathrm{d} t} \nabla \alpha\right) = 0
    \end{aligned}
\end{equation}</script><p>也就是说:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d} \alpha}{\mathrm{d} t} \nabla \beta - \frac{\mathrm{d}  \beta}{\mathrm{d} t} \nabla \alpha = \nabla \Psi
    \end{aligned}
\end{equation}</script><p><span class='mohu'>因为对一个标量的梯度求旋度必然等于零.</span></p>
<p>这里我们选择合适的度规, 使得 $\nabla \Psi = 0$. 此时由于 $\nabla \beta$ 以及 $\nabla \alpha$ 不会为零, 则必然会有:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d} \alpha}{\mathrm{d} t} = \frac{\mathrm{d} \beta}{\mathrm{d} t} = 0
    \end{aligned}
\end{equation}</script><p>这也就表明确定磁力线的两组曲面 $\alpha(x, y, z) = C_\alpha, \beta(x, y, z) = C_{\beta}$ 都是随着流体元运动的守恒量, 因此其交线——磁力线也随着流体元运动不变.</p>
</div></details>
<p>由于上述的这个方式对于我们这种物理小白来说实在是不太友好, 所以我们这里考虑另外一种磁冻结效应的证明方式:</p>
<p>根据 $\partial \mathbfit{B}/\partial t = \nabla \times (\mathbfit{u} \times \mathbfit{B})$, 我们知道:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\partial \mathbfit{B}}{\partial t} - \nabla \times (\mathbfit{u} \times \mathbfit{B}) = 0
    \end{aligned}
\end{equation}</script><p>同时, 磁通量可以通过磁场的面积分(即通过的磁力线的多少)得到, 也就是: $\Phi = \iint_{S} \mathbfit{B} \cdot  \mathrm{\,d}\mathbfit{S}$, 于是我们考虑对 $(27)$ 式的两边做一个面积分:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \iint_{S} \frac{\partial \mathbfit{B}}{\partial t} \cdot \mathrm{\,d}\mathbfit{S} = \frac{\partial \iint_{S} \mathbfit{B} \cdot \mathrm{\,d}\mathbfit{S}}{\partial t} = \frac{\partial \Phi}{\partial t}
    \end{aligned}
\end{equation}</script><script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \iint_{S} \nabla \times (\mathbfit{u} \times \mathbfit{B}) \cdot \mathrm{\,d}S = -\oint _{\partial S} (\mathbfit{B} \times \mathbfit{u}) \cdot \mathrm{\,d}\mathbfit{l} = -\oint _{\partial S} \mathbfit{B} \cdot  \mathbfit{u} \times  \mathrm{\,d}\mathbfit{l}
    \end{aligned}
\end{equation}</script><p><img src="https://picx.zhimg.com/v2-f76f245c16be2a5cde7d336666709101_1440w.jpg" alt="磁冻结示意图" width = "500"></p>
<center id='f4'><span style='font-weight:bold'>Fig 4. 磁冻结示意图</span></center>

<p>根据上图我们可以知道 $(29)$ 式实际上是磁流体流动引起的磁通量变化, 加上 $(28)$ 式表示的原本的磁通量就是理想磁流体中总的磁通量随时间的变化. 即:</p>
<script type="math/tex; mode=display">\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}\Phi}{\mathrm{d}t} &= \frac{\partial \Phi}{\partial t} + \oint _{\partial S} \mathbfit{B} \cdot  \mathbfit{u} \times  \mathrm{\,d}\mathbfit{l} \\
        &=\iint _{S} \frac{\partial \mathbfit{B}}{\partial t} - \nabla \times (\mathbfit{u} \times \mathbfit{B}) \cdot \mathrm{\,d}S \\ &= 0
    \end{aligned}
\end{equation}</script><p>这就证明了一个固定的流体元的磁通量是随时间不变的, 也就是磁场冻结在流体中.</p>
<p>从微观角度来看, 一般来说磁冻结意味着带电粒子沿着磁力线作回旋运动. 然而系统中存在的各种物理量的梯度会导致粒子在不同的磁力线之间作横越磁力线的漂移运动, 那么磁冻结的图像应该怎么理解就是一个需要仔细讨论的问题. 从静态平衡的方程出发:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \nabla _{\perp p} = \frac{\mathbfit{J}_{\perp} \times \mathbfit{B}}{c}
    \end{aligned}
\end{equation}</script><p>或者是:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{J}_{\perp} = - \frac{c \nabla _{\perp p} \times \mathbfit{B}}{B^{2}}
    \end{aligned}
\end{equation}</script><p>也就是说, 等离子体电流是由静态平衡下的压强梯度漂移导致的. 很明显这个电流的存在会减弱原本的磁场, 因此被称为<strong>抗磁漂移</strong>. 前面的讨论我们已经知道电流是在磁面上存在的, 所以带电粒子实际上是在磁面上被 “冻结” 的. 而磁面是磁力线卷曲而成的曲面, 所以我们也可以说带电粒子实际上还是被冻结在同一条磁力线上.</p>
<p>要说的是, 磁流体近似下的电流是由压强梯度引起的, 而各种梯度运动的本质都是 Larmor 半径效应引起的, 所以磁流体电流的物理图像是 Larmor 半径的最低阶近似.</p>
<h2 id="Z-箍缩-theta-箍缩"><a href="#Z-箍缩-theta-箍缩" class="headerlink" title="Z - 箍缩, $\theta$ - 箍缩"></a>Z - 箍缩, $\theta$ - 箍缩</h2><p>磁约束平衡问题是理想磁流体平衡的一个重要的应用研究, 下面针对几个简单的几何位型作一些介绍, 比如类似单个直线导体中的电流或者螺线管线圈中电流产生的磁场对等离子体的约束.</p>
<h3 id="Z-箍缩"><a href="#Z-箍缩" class="headerlink" title="Z - 箍缩"></a>Z - 箍缩</h3><p>首先是第一种情况, 电流沿着柱对称几何的轴向(z 方向), 产生的磁场可以表示为 $\mathbfit{B} = \hat{\theta}B_{\theta}(r)$, 即图5所示. 根据之前的平衡方程我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\frac{\mathrm{d}}{\mathrm{d}r}\left(p + \frac{B_{\theta}^{2}}{8\pi}\right) = -\frac{B_{\theta}^{2}}{4 \pi r} \\
        &\frac{\mathrm{d}p}{\mathrm{d}r} = -\frac{1}{8 \pi r^{2}}\frac{\mathrm{d}}{\mathrm{d}r}(r^{2} B_{\theta}^{2})
    \end{aligned}
\end{equation}</script><p><img src="https://pic4.zhimg.com/v2-76ed48af14b1bbdca228420549f05ae1_1440w.jpg" alt="Z - 箍缩" width = "500"></p>
<center id='f5'><span style='font-weight:bold'>Fig 5. Z - 箍缩</span></center>

<p>这样, 我们就可以更具需要的等离子体压强分布计算应该采用什么样的电流分布, 或者根据已有的电流分布计算会得到什么样的等离子体压强分布.</p>
<p>在这种位型下, $B_{z} = 0$, 这意味着等离子体是不稳定的(后面会讨论). 在强电工程技术的研究中会需要利用这种不稳定性来设计具有”自然”的快速响应性质的过载保护开关. 惯性约束聚变中, 也可以采用这种方案: 在非常细的丝状导线上同非常强的电流使导线融化成等离子体, 电流产生的洛伦兹力 $\mathbfit{J} \times \mathbfit{B}$ 会朝着中心来”箍缩”这些等离子体, 从而产生高能量粒子和 X 射线引发聚变. 这种装置作为强 X 射线源以及强脉冲聚变中子源也有着广泛的应用前景.</p>
<h3 id="theta-箍缩"><a href="#theta-箍缩" class="headerlink" title="$\theta$ 箍缩"></a>$\theta$ 箍缩</h3><p>如果电流方向在 $\theta$ 方向, 则产生的磁场为 $\mathbfit{B} = \hat{z}B_{z}(r)$, 如图6所示.</p>
<p><img src="https://picx.zhimg.com/v2-026dbd8b175609dd5a25c3b415f8e0a3_1440w.jpg" alt="θ - 箍缩" width="300"></p>
<center id='f6'><span style='font-weight:bold'>Fig 6. θ - 箍缩</span></center>

<p>同样的, 我们可以利用平衡方程得到以下的关系:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \left(p + \frac{B^{2}}{8 \pi}\right)_{r < a} = \frac{B^{2}(a)}{8 \pi}
    \end{aligned}
\end{equation}</script><p>$r = a$ 表示等离子体的边界, 同样的我们需要从电流分布计算压强分布, 或者根据压强分布计算所需的电流分布. 同时, 在这种位型下 $B_{\theta} = 0$, 等离子体”非常安全(稳定)”, 其稳定性我们也放到下一节中论述. 这也意味着该位型下没有轴向的约束(单粒子运动中平行于磁场方向是不会受到力的), 磁镜和环形约束可以用来解决这一问题.</p>
<h3 id="磁镜"><a href="#磁镜" class="headerlink" title="磁镜"></a>磁镜</h3><p>将 $\theta$ - 箍缩中等离子体柱两端的磁场 $B_{z}$, 我们就可以得到一个”磁镜”位型, 如图7所示.</p>
<p><img src="https://pic1.zhimg.com/v2-cc96c7bf6aa441183545a8f4e9751b9a_1440w.jpg" alt="磁镜" width="300"></p>
<center id='f7'><span style='font-weight:bold'>Fig 7. 磁镜</span></center>

<p>这种位型通常被称为”线性装置”, 曾经是磁约束等离子体研究的最重要装置. 伴随磁镜装置的还有一个很重要的概念, “绝热不变量”. 磁镜装置的第一个不变量是”磁矩不变量”, 即带电粒子在围绕磁力线做高频回旋运动时, 在长时间尺度上我们可以认为粒子单位质量的回旋运动产生的磁矩</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mu = \frac{v_{\perp}^2}{2 B}
    \end{aligned}
\end{equation}</script><p>是一个近似的守恒量, 沿着磁力线 $l$, 粒子单位质量的动能可以写成:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \varepsilon = \mu B(l) + \frac{1}{2} v_{\parallel}^{2}
    \end{aligned}
\end{equation}</script><p>这可以看成带电粒子沿着磁力线在”磁势阱” $\mu B(l)$ 中的运动. 在磁场的极小值 $B_{\min }$ 两侧如果有一个极大值 $B_{\max }$, 那么对于 $\varepsilon \leq \mu B(l)$ 的粒子会被磁势阱捕获, 从而在两个极大值之间”弹跳(bounce)”. 对于更长的时间, 这个弹跳的周期运动会给我们第二个绝热不变量:”弹跳不变量”. 再加上磁场曲率的存在, 带电粒子会在跨越磁力线的方向上存在漂移, 这个运动近似是一个围绕磁镜圆形截面的周期运动. 在非常长的时间尺度下, 我们将得到有关漂移的第三个绝热不变量. 一般来说, 磁约束等离子体中很少用到后面一种不变量. 另外, 地球磁场的偶极磁场也可以近似地看成是一个磁镜系统, 并且这三种绝热不变量在地球磁层等离子体中的研究是非常重要的. 由于磁势阱的存在, 这种磁约束位型下, 带电粒子的速度空间存在”损失锥(loss cone)”不稳定性, 这将大大影响等离子体约束的时间.</p>
<h3 id="环形约束和托卡马克"><a href="#环形约束和托卡马克" class="headerlink" title="环形约束和托卡马克"></a>环形约束和托卡马克</h3><p>为了解决轴向上没有约束的问题, 我们将 $\theta$ - 约束中的环形线圈围成一个圆环(图8绿色部分), 但此时由 $B_{z}$ 弯成的环向场在环内侧比环外侧强, 导致指向环内测的磁场梯度. 根据单粒子运动的结论, 这会导致垂直于这个梯度方向的漂移. 因此, 为了消除这个漂移, 我们需要在原本的场上叠加一个极向场(图8的中心螺管线). 这就是托卡马克装置的设计思路.</p>
<p><img src="https://pic1.zhimg.com/v2-09c3c196a580129d68506d4787a6f3ea_1440w.jpg" alt="托卡马克(绿色的是环形线圈)" width="300"></p>
<center id='f8'><span style='font-weight:bold'>Fig 8. 托卡马克(绿色的是环形线圈)</span></center>

<p>很显然的, 环向场要比极向场强得多, 极向场的引入使得磁面拓扑呈环状, 每条磁力线都会经历环的内侧和外侧, 而因为向环内的磁场梯度的存在, 使得一条磁力线上会有环内侧的强场区和环外侧的弱场区, 这构成了一个”磁镜”位型, 这种特殊的磁镜效应对粒子的捕获是托卡马克等离子体的一个非常重要的性质. 这种环形约束的平衡是一种二维平衡, 接下来就讨论二维平衡位型满足的条件.</p>
<h2 id="一维平衡-螺旋箍缩"><a href="#一维平衡-螺旋箍缩" class="headerlink" title="一维平衡, 螺旋箍缩"></a>一维平衡, 螺旋箍缩</h2><h3 id="一维圆柱等离子体的平衡"><a href="#一维圆柱等离子体的平衡" class="headerlink" title="一维圆柱等离子体的平衡"></a>一维圆柱等离子体的平衡</h3><p>我们知道轴对称的柱状等离子体($\theta$ - 箍缩)的物理量具有 $f = f(r)$ 的形式, 并且 $B_{r} = 0$. 因此, 磁面方程可以写成 $r = r_{0}$ 的形式. 根据静态平衡方程我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}}{\mathrm{d}r} \left(p + \frac{B^{2}}{8 \pi}\right) = \frac{B^{2}}{4 \pi} \kappa(r) = -\frac{B_{\theta}^{2}}{4 \pi r} \left(\text{因为圆的曲率为} -\frac{1}{r}\right)
    \end{aligned}
\end{equation}</script><p>如果既有环向场($\theta$), 又有极向场($z$), 也就是说磁场可以被写成: $\mathbfit{B} = \hat{\theta} B_{\theta}(r) + \hat{z} B_{z}(r)$, 那么静态平衡得到的结果将会变成:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d}}{\mathrm{d}r} \left(p + \frac{B_{\theta}^{2}}{8 \pi} + \frac{B_{z}^{2}}{8 \pi}\right) = \frac{B_{\theta}^{2}}{4 \pi r}
    \end{aligned}
\end{equation}</script><p>由于这种位型的磁力线和电流都是螺旋形的, 所以我们一般称之为”螺旋箍缩”. 在这种平衡下, $\nabla \cdot \mathbfit{B} = 0$ 显然是满足的(因为没有 $B_{r}$, 即没有向外发射的无法闭合的磁力线). 因此我们需要通过一个方程(式 38)来决定三个未知函数($p, B_{\theta}, B_{z}$), 其中轴向(z 方向)和环向(θ 方向)自由度由周期条件来确定; 另外一个则可以用 r 的两个边界条件($r = 0$ 和 $r = a$)来确定.</p>
<h3 id="安全因子"><a href="#安全因子" class="headerlink" title="安全因子"></a>安全因子</h3><p>现在我们来看磁场的两个分量是如何绕成磁面的, 在这样的螺旋形磁场位型中, 一根磁力线需要同时经过大小两个半径(主半径 R 以及小半径 r)的圆(图9所示, 红色为小圆, 蓝色为大圆, 这两个圆分别对应着极向和环向的磁场, 大小半径的概念在托卡马克核聚变的研究中也经常使用).</p>
<p><img src="https://pica.zhimg.com/v2-510c267e6acce7dce0a9698ca33d78ae_1440w.jpg" alt="螺旋箍缩" width="500"></p>
<center id='f9'><span style='font-weight:bold'>Fig 9. 螺旋箍缩</span></center>

<p>根据最开始的托卡马克坐标(θ, r, z)磁力线的方程, 我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{r \mathrm{d}\theta}{\mathrm{d}z} &= \frac{B_{\theta}}{B_{z}} \\
        \Rightarrow \frac{r \mathrm{d}\theta}{\mathrm{d}z} &= \frac{B_{\theta} 2 \pi R}{B_{z} 2 \pi R} \\
        \Rightarrow \frac{2 \pi R \mathrm{\,d}\theta}{\mathrm{\,d}z} &= \frac{B_{\theta} 2 \pi R}{B_{z} r} \\
        \Rightarrow \frac{\mathrm{\,d}z}{2 \pi R} &= \frac{B_{z} r}{B_{\theta} 2 \pi R \mathrm{\,d}\theta}
    \end{aligned}
\end{equation}</script><p>这里我们一个叫”安全因子(safety factor)”的量, 也就是:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        q(r) \equiv \frac{r B_{z}(r)}{R B_{\theta}(r)}
    \end{aligned}
\end{equation}</script><p>其中由于 $B_{\theta}$ 以及 $B_{z}$ 都会随着 r 变化, 所以安全因子也会随着 r 进行变化. 有了安全因子的定义之后我们可以得到: </p>
<script type="math/tex; mode=display">(\Delta z)_{\Delta \theta = 2 \pi} = q(r) 2 \pi R</script><p>这也就意味着实际上安全因子表示磁力线在 $\hat{\theta}$ 方向上转完一整圈时在 $\hat{z}$ 方向上转过的圈数(也可以说是走过的周期数). 在下一节中我们可以看到安全因子和等离子体平衡的稳定性有关系, 这也是安全因子这个名字的原因. 在 z - 箍缩中, 由于 $B_{z} = 0$, 安全因子为 0, 等离子体是不安全的, 也就是说不稳定的. 而在 θ - 箍缩下, $B_{\theta} = 0$, $q \to  \infty$, 等离子体是很安全的, 也就是说是”绝对稳定”的.</p>
<p>另外, 由于 $q(r)$ 是连续变化的, 因此对于 $q(r)$ 我们可以取到无穷多分段连续的无理数, 也可以取到无穷多个”分立”的有理数(也就是有理数在数轴上的分布是分立的). 当我们取到有理数 $q(r) = m/n$ 的磁面(有理磁面)时, 磁力线环绕大圆 m 圈, 绕小圆 n 圈后会回到最开始的地方首尾相接, 这也就意味着此时的磁力线是无法铺满整个磁面的. 实际上就是有理磁面上的磁力线总是在重复之前的轨迹, 一条磁力线是没法遍历磁面上所有的点, 但无理磁面上的磁力线因为不会回到原来的起点, 不会重复之前走过的路, 所以会在磁面上遍历所有的位置. 从测度上来说, 有理磁面上的磁力线所占据的区域测度为零, 物理上来说这个磁面是”软”的, 容易出现不稳定性. 因此相对来说, 无理磁面具有很好的物理性质. 关于这个问题, 王晓钢老师的<a href="https://blog.sciencenet.cn/blog-39346-286012.html">博客</a>有更详细的解释(<span class='mohu'>实际上也差不多, 哈哈哈哈哈</span>).</p>
<h2 id="Grad-Shafranov-方程"><a href="#Grad-Shafranov-方程" class="headerlink" title="Grad - Shafranov 方程"></a>Grad - Shafranov 方程</h2><p>接下来考虑更复杂的环形约束等离子体的二维平衡分布及其性质, 二维平衡满足的方程为 Grad - Shafranov 方程, 用来研究托卡马克等离子体, 这里我们先进一步引入托卡马克坐标系.</p>
<h3 id="托卡马克-Tokamak-坐标系"><a href="#托卡马克-Tokamak-坐标系" class="headerlink" title="托卡马克(Tokamak)坐标系"></a>托卡马克(Tokamak)坐标系</h3><p>一般由于托卡马克甜甜圈形状的特征我们可以采用柱坐标($R, \zeta, Z$)或者环坐标($r, \theta, z$)来描述托卡马克位型, 其中 $\hat{z}$ 为弧长的方向.</p>
<p><img src="https://pic2.zhimg.com/v2-064b1be573f3a6254e349ae4f62c06fd_1440w.jpg" alt="托卡马克坐标系" width="400"></p>
<center id='f10'><span style='font-weight:bold'>Fig 10. 托卡马克坐标系</span></center>

<p>我们可以很轻松地给出这两个坐标系之间的关系:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        R &= R_{0} + r \cos \theta \\
        \zeta &= -\frac{z}{R_{0}} \\
        Z &= r \sin \theta
    \end{aligned}
\end{equation}</script><p>很显然的, 这样的平衡是轴对称的, 也就是 $\mathrm{d}/\mathrm{d}\zeta = 0$. 取磁面 $\psi = \psi(R, Z)$, 此时有 $\frac{\partial \psi}{\partial \zeta}=0$, 前面提到过磁力线可以看成是两个曲面的交线, 将这两个曲面选择成相互正交的曲面可以得到一个正交坐标系, 对应到托卡马克中, 我们可以选择磁面 $\psi$ 和 $-\hat{z}$ 方向对应的曲面, 根据磁场的表达式 $\ref{eq:bfield}$, $\ref{eq:B2}$, 我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{B} = -F(\psi)\hat{z} + \hat{z} \times \nabla \psi
    \end{aligned}
\end{equation}</script><p>由于 $\hat{\zeta}$ 和 $\hat{z}$ 是相互对应的, (用 $\hat{\zeta}/R$ 取代 $\hat{z}$), 可以得到: </p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbfit{B} &= \frac{F(\psi)}{R} \hat{\zeta} - \frac{\hat{\zeta}}{R} \times \nabla \psi \\
        &= \mathbfit{B}_{\zeta} - \frac{\hat{\zeta}}{R} \times \nabla \psi \\
        &= \mathbfit{B}_{\zeta} - \frac{\hat{\zeta}}{R} \times \left(\frac{\partial \psi}{\partial R} + \frac{\partial \psi}{\partial Z}\right) \\
        &= \mathbfit{B}_{\zeta} + \frac{1}{R} \frac{\partial \psi}{\partial R} \hat{Z} - \frac{1}{R} \frac{\partial \psi}{\partial Z} \hat{R}
    \end{aligned}
\end{equation}</script><p>也就是说:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        B_{\zeta} &= \frac{F(\psi)}{R} \\
        B_{R} &= -\frac{1}{R} \frac{\partial \psi}{\partial Z} \\
        B_{Z} &= \frac{1}{R} \frac{\partial \psi}{\partial R}
    \end{aligned}
\end{equation}</script><p>我们假设磁轴在 $R = R_{a}$, $Z = 0$ 的位置, 并且 $\psi(R_{a}, 0) = 0$. 计算极向磁通(可以理解为穿过 $z = 0$ 平面的磁通量):</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \Psi_{p} = \iint_{Z = 0} B_{z} \mathrm{d}S = \int_{0}^{2 \pi}\mathrm{\,d}\zeta \int _{R_{a}}^{R} R \left[\frac{1}{R} \frac{\partial \psi}{\partial R}\right] \mathrm{\,d}R = 2 \pi \psi
    \end{aligned}
\end{equation}</script><h3 id="Grad-Shafranov-方程-1"><a href="#Grad-Shafranov-方程-1" class="headerlink" title="Grad - Shafranov 方程"></a>Grad - Shafranov 方程</h3><h4 id="等离子体电流密度"><a href="#等离子体电流密度" class="headerlink" title="等离子体电流密度"></a>等离子体电流密度</h4><p>在等离子体平衡的小节中, 我们知道一些基本的关系式(切换成国际单位制)</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mu_0\mathbfit{J}&=\nabla \times \mathbfit{B} \\
        \nabla p &= \mathbfit{J}\times \mathbfit{B}
    \end{aligned}
\end{equation}</script><p>通过简单的推导我们可以得到（注意我们采用的坐标系的正交关系是：R, $\zeta$, Z 是一种极向圆柱坐标系, 相关信息可以在<a href="https://prefetch.eu/know/concept/polar-cylindrical-coordinates/">此处找到</a>）：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mu_{0} \mathbf{J}=\nabla \times \mathbf{B}=-\frac{\partial B_{\zeta}}{\partial Z} \hat{\mathbf{R}}+\left(\frac{\partial B_{R}}{\partial Z}-\frac{\partial B_{Z}}{\partial R}\right) \hat{\zeta}+ \left(\frac{\partial B_{\zeta}}{\partial R}+\frac{B_{\zeta}}{R} \right)\hat{\mathbf{Z}}
    \end{aligned}
\end{equation}</script><p>由于 $F(\psi) = R B_{\zeta}$, 因此极向的电流密度就可以直接得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mu_0 J_{R} &= - \frac{1}{R} \frac{\partial F(\psi)}{\partial R} \\
        \mu_0 J_{Z} &= \frac{1}{R}\frac{\partial \left(R B_{\zeta}\right)}{\partial R} = \frac{1}{R} \frac{\partial F(\psi)}{\partial R}
    \end{aligned}
\end{equation}</script><p>在我们感兴趣的大部分情况中极向电流都比较小从而可以忽略. 同样的, 环向电流也可以从上面的式子中得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mu_{0} J_{\zeta} & =\frac{\partial B_{R}}{\partial Z}-\frac{\partial B_{Z}}{\partial R} \\ & =-\frac{1}{R} \frac{\partial^{2} \psi}{\partial Z^{2}}-\frac{\partial}{\partial R}\left(\frac{1}{R} \frac{\partial \psi}{\partial R}\right)
    \end{aligned}
\end{equation}</script><p>由方程(46)的第二项可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \nabla P=\mathbfit{J} \times \mathbfit{B}=\left[\begin{array}{c}J_{\zeta} B_{z}-J_{z} B_{\zeta} \\ J_{z} B_{r}-J_{r} B_{z} \\ J_{r} B_{\zeta}-J_{\zeta} B_{r}\end{array}\right]
    \end{aligned}
\end{equation}</script><p>现在我们考虑平行于磁场方向上的力是平衡的, 也就是说在上述方程的基础上点乘磁场我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        0=\mathbfit{B} \cdot \nabla P
    \end{aligned}
\end{equation}</script><p>这暗示沿着磁场线 $P$ 将会是一个常数值(这样的形式可以满足该方程的解, 也许还有其他形式的解, 但已有证明可以说明对称位型下这个解确实是满足的). 也就是前面提到的 $P=P(\psi)$. 于是上式变成了:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        0=\mathbfit{B} \cdot \frac{\mathrm{d} P}{\mathrm{d} \psi} \nabla \psi
    \end{aligned}
\end{equation}</script><p>再考虑环向上的平衡, 根据方程(50)我们有:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        J_{Z} B_{R}-J_{R}B_{Z}=\frac{1}{R} \frac{\partial P}{\partial \zeta}=0\ (P=P(\psi) \rightarrow \partial P/\partial \zeta=0)
    \end{aligned}
\end{equation}</script><p>将极向电流密度依次代入, 得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial F}{\partial R} B_{R}+\frac{\partial F}{\partial Z} B_{Z}=0
    \end{aligned}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}        
        \mathbfit{B} \cdot \nabla g=0\ (\partial F(\psi)/\partial \zeta=0)
    \end{aligned}
\end{equation}</script><p>基于上述相同的原因, 我们也可以说明 $F=F(\psi)$ 的成立. 这个函数通常被称为 <strong>极向电流密度函数</strong>, 具体的原因可以从参考文献中找到.</p>
<p>最后我们来讨论沿着主半径方向的力学平衡:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial P}{\partial R}&=J_{\zeta} B_{Z}-J_{Z} B_{\zeta} \\
        &=\frac{1}{\mu_{0}}\left(\frac{\partial B_{R}}{\partial Z}-\frac{\partial B_{Z}}{\partial R}\right) B_{Z}-\frac{1}{\mu_{0} R} \frac{\partial\left(R B_{\zeta}\right)}{\partial R} B_{\zeta} \\ 
        &=-\frac{1}{\mu_{0}}\left(\frac{\partial}{\partial Z}\left(\frac{1}{R} \frac{\partial \psi}{\partial Z}\right)+\frac{\partial}{\partial R}\left(\frac{1}{R} \frac{\partial \psi}{\partial R}\right)\right) \frac{1}{R} \frac{\partial \psi}{\partial R}-\frac{1}{\mu_{0} R} \frac{\partial\left(R B_{\zeta}\right)}{\partial R} B_{\zeta} \\ 
        &=-\frac{1}{\mu_{0} R}\left(\frac{1}{R} \frac{\partial^{2} \psi}{\partial Z^{2}}+\frac{\partial}{\partial R}\left(\frac{1}{R} \frac{\partial \psi}{\partial R}\right)\right) \frac{\partial \psi}{\partial R}-\frac{1}{\mu_{0} R} \frac{\partial\left(R B_{\zeta}\right)}{\partial R} B_{\zeta} \\
        \Longrightarrow &\frac{\partial P}{\partial \psi} \frac{\partial \psi}{\partial R}=-\frac{1}{\mu_{0} R}\left(\frac{1}{R} \frac{\partial^{2} \psi}{\partial Z^{2}}+\frac{\partial}{\partial R}\left(\frac{1}{R} \frac{\partial \psi}{\partial R}\right)\right) \frac{\partial \psi}{\partial R}-\frac{1}{\mu_{0} R} \frac{\partial\left(R B_{\zeta}\right)}{\partial \psi} \frac{\partial \psi}{\partial R} B_{\zeta}
    \end{aligned}
\end{equation}</script><p>将最后得到的方程两边同时除上 $\partial \psi/\partial R$ 乘上 $\mu_{0} r^{2}$, 我们就可以得到 <strong>Grad-Shafranov 方程</strong>, 它可以给出环形位型下的等离子体平衡条件:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial^{2} \psi}{\partial Z^{2}}+R \frac{\partial}{\partial R}\left(\frac{1}{R} \frac{\partial \psi}{\partial R}\right)=-\mu_{0} R^{2} \frac{\mathrm{d} P}{\mathrm{d} \psi}-F(\psi) \frac{\mathrm{d} F(\psi)}{\mathrm{d} \psi}
    \end{aligned}
\end{equation}</script><p>我们将与坐标系相关的部分抽取出来, 即令: </p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \Delta^{*} \equiv \frac{\partial^{2}}{\partial Z^{2}}+R \frac{\partial}{\partial R}\left(\frac{1}{R} \frac{\partial}{\partial R}\right)
    \end{aligned}
\end{equation}</script><p>原方程可以简化为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \Delta^{*} \psi=-\mu_{0} R^{2} \frac{\mathrm{d} P}{\mathrm{d} \psi}-F \frac{\mathrm{d} F}{\mathrm{d} \psi}
    \end{aligned}
\end{equation}</script><p>在环形坐标系 $(r, \theta, z)$ 下, 平衡状态下有 $\partial/\partial \zeta=-R_{0} \partial/\partial z=0$, 我们得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \Delta^{*}=\nabla^{2}-\frac{2}{R_{0}+r \cos{\theta}} \left(\cos{\theta}\frac{\partial}{\partial r}-\sin{\theta}\frac{1}{r} \frac{\partial }{\partial \theta} \right)
    \end{aligned}
\end{equation}</script><p>有关此方程的解以及平衡控制的问题都是磁约束聚变领域的前沿问题, 很多论文对此进行研究, 在此就不在赘述.</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="note info flat"><ol>
<li><a href="https://prefetch.eu/know/concept/grad-shafranov-equation/">https://prefetch.eu/know/concept/grad-shafranov-equation/</a></li>
<li><a href="https://www.questjournals.org/jram/papers/v7-i4/E07043438.pdf">https://www.questjournals.org/jram/papers/v7-i4/E07043438.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Grad%E2%80%93Shafranov_equation">https://en.wikipedia.org/wiki/Grad%E2%80%93Shafranov_equation</a></li>
<li><a href="https://youjunhu.github.io/research_notes/tokamak_equilibrium_htlatex/tokamak_equilibrium.html">https://youjunhu.github.io/research_notes/tokamak_equilibrium_htlatex/tokamak_equilibrium.html</a></li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
        <category>等离子体物理</category>
      </categories>
      <tags>
        <tag>等离子体物理</tag>
        <tag>磁流体力学</tag>
        <tag>磁约束核聚变</tag>
      </tags>
  </entry>
  <entry>
    <title>理论物理速成——经典力学 I</title>
    <url>/2022/12/06/classical-mechanics-1/</url>
    <content><![CDATA[<!-- ![classical-mechanics-1-cover](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/post/classical-mechanics-1-cover.jpg) -->
<h1 id="第一部分-拉格朗日力学原理"><a href="#第一部分-拉格朗日力学原理" class="headerlink" title="第一部分 拉格朗日力学原理"></a><center>第一部分 拉格朗日力学原理</center></h1><div class="note primary flat"><p>Highlight：</p>
<ol>
<li>最小作用量原理是怎么来的;</li>
<li>拉格朗日函数是怎么来的;</li>
<li>最小作用量原理、拉格朗日函数、牛顿经典力学原理之间的自洽;</li>
</ol>
</div>
<h2 id="最小作用量原理"><a href="#最小作用量原理" class="headerlink" title="最小作用量原理"></a>最小作用量原理</h2><p>物理学关注的本质是世间万物的<strong>运动</strong>, 即系统状态随时空的演化, 抽象到数学就是微分方程系统的演化.</p>
<p>在牛顿的世界观里, 意思是<strong>力是改变物体运动的原因</strong>, 存在力和加速度之间的表达式 $\vec{F}=ma$. 在这样的观点下, 考察物体的状态就必须要对物体进行受力分析, 但很多时候(比如存在<strong>约束</strong>的时候)我们没有办法完全确定物体所受的力(因为<strong>约束限制的是物体的运动, 它对物体作用的力会随着物体运动的不同而发生改变, 和物体的运动一样是一个待确定的量</strong>), 因此牛顿力学的诸多限制促使我们寻求另外一种对物体运动的思考方式, 这种思考方式更加接近于事物的本质, 如果说牛顿运动定律是牛顿通过自然观察总结出来的定律, 那么接下来我们讨论的就可能是万物运动所遵循的最基本的法则, 自然机器的”底层逻辑”——<strong>最小作用量原理</strong>.</p>
<p>所谓最小作用量原理其实是一个很符合哲学概念的假设, 即万事万物的运动总是以牺牲最小的代价为原则, 这个代价在物理学上就被定义为作用量, 实际上这个概念来自自然界中各种极值现象, 比如光总是走最短的路线, 或者液滴总是呈现表面积最大的球形. 当然也可能人的经验感觉在这个概念的发展过程中起到了重要的作用, 比如让球从曲面的高处落下时通常会沿着梯度最大的方向运动, 总的来说追求极值的状态是一件自然而然的事情. 一旦我们接受了这样的原理(事实上我们也很容易就能接受这样的假设), 就会发现它似乎可以解释我们所面临的所有相关问题.</p>
<h3 id="从能量谈起"><a href="#从能量谈起" class="headerlink" title="从能量谈起"></a>从能量谈起</h3><p>关于物体的运动或者说物体的状态, <strong>“能量”</strong> 是一个绝对绕不开的名词, 人们从日常生活中提炼的第一个深刻思想便是<strong>能量守恒</strong>, 最早追溯到莱布尼兹, 他指出: 以落体运动来说，物体升起的高度是与初速度的平方成正比，因之作用在物体上的力的效应必定是与其重量所给予的速度平方而不是速度成正比的，这就是机械能守恒的最早的形式, 即重力势能和动能的相互转化. 物理学的发展过程中提出过很多种能量的概念, 但最终回到粒子层面就只存在两种能量的形式:</p>
<ul>
<li>动能</li>
<li>势能</li>
</ul>
<p>实际上这就是构成机械能守恒的两种能量形式, 同时在牛顿力学的基础上, 我们有:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        F(x) = - \frac{\mathrm{d} V(x)}{\mathrm{d} x}
    \end{aligned}
\end{equation}</script><p>也就是说势能函数的定义可以通过上式的积分操作给出:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        V(x)=-\int{F(x) \mathrm{d} x}
    \end{aligned}
\end{equation}</script><p>对于上面这个式子的表述换句话说就是<strong>力总是沿着具有更低势能的方向来推动粒子</strong>, 同时势能函数越陡峭, 力就越大. 并且, 根据势能和动能之和守恒, 沿着势能函数降低时动能( $1/2mv^2$ )将增加, 势能函数的时间导数( $v \mathrm{d} V /\mathrm{d} x$ )对应了动能的时间导数( $m v \dot{v}$ ), 所以很自然的势能越陡峭, 力就越大, 同时粒子的加速度越大, 这样就得到牛顿运动定律的表述形式.</p>
<p>这里有一个很重要的问题, 即存在力决定势能还是存在势能决定力? 牛顿力学体系中力是一个实实在在的概念, 因为通常我们面对的是相互接触的物体, 但如果对象变成苹果和地球, 或者粒子与粒子时力的概念就变得抽象起来. 另外对于物质弱耦合态(比如无碰撞等离子体)的压强的讨论也是一个很值得思考的问题, 通过统计力学(动理论)的方式推导出来动量方程中的压强梯度项实际上就是来自于动量本身的变化, 其作用形式和力的概念相似, 所以我们定义其为压强梯度力. 因此我们也许可以说实际上决定物体如何运动的是能量的变化, 运动即势能和动能相互转化的过程, 这个过程是通过力的概念来完成和体现的.</p>
<p>在能量的概念下讨论物体的状态时, 我们经常能够听到<strong>稳态</strong>或者<strong>平衡</strong>的说法, 根据牛顿力学, 力是改变物体运动状态的原因, 而力是势能函数的梯度, 这样一来势能函数的形状就决定了物体保持原本状态的能力, 即平衡的能力. 从数学上来说, 如果系统势能位于势能函数的极值处, 即:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\mathrm{d} V}{\mathrm{d} x} = 0
    \end{aligned}
\end{equation}</script><p>时称作平衡态, 按照极大值点和极小值点又可以分为”非稳定平衡态”和”稳定平衡态”. 同时一个系统可能具有多个平衡态(势能函数具有多个极值点), 平衡态之间的位置称为”势阱”和”势垒”.</p>
<p><img src="https://pic4.zhimg.com/v2-6e9e0cc48b1e957edbd1b119adc94d7f_1440w.jpg" alt="classical-mechanics-1-6f5a7e35fb603e7701495747f03c17b"></p>
<p>经验告诉我们, 物体总是趋向于处于能量更低的状态, 换句话说就是, 如果暂时不考虑物体从一个状态变化到另一个状态的中间过程(运动过程), 物体下一个时刻的状态可以完全自由选择的话, 物体总是会倾向于选择能量最低的那一种状态, 对人来说就相当于是选择最轻松的状态. 这么说来, 宇宙也喜欢躺平(<span class='heimu'>躺平是在遵循自然地法则O(∩_∩)O哈哈~</span>).</p>
<h3 id="对作用量的思考"><a href="#对作用量的思考" class="headerlink" title="对作用量的思考"></a>对作用量的思考</h3><p>上面的这种原则给出了在多个状态之间的选择, 那么对于目前的状态和被选择的能量最低的状态之间的过程, 即: <strong>物体如何选择从一个状态到另一个状态之间的运动呢</strong>?</p>
<p>换成一个最简单的力学问题, 上面的这个问题被表述为: <span style='background: yellow'>如果我们知道初始时刻 $t_0$ 和运动之后某一时刻 $t_1$ 的位置 $x_0$, $x_1$, 在不知道其他条件的情况下有办法确定出物体在这个时间段内的运动吗?</span> 从牛顿力学的观点来看这几乎是一个不可能的问题, 牛顿力学需要知道初始状态( $x_0$ )以及受力( $F$, 实际上是 $\ddot{x}$ )然后对未来甚至是过去进行预测或者回溯, 相当于在 $x-t$ 坐标下知道曲线上的一个点和曲线(上每一个点)的方向, 也就是已经知道该怎么画出这条曲线了. 而现在的问题是确定一条连接已知两个点的曲线, 我们可以有无数种选择方式, 但大自然最终只会有一条确定的曲线, 我们想知道的就是造物主是如何确定这条曲线的!</p>
<p><img src="https://pic4.zhimg.com/v2-bd9836c914b97b2015655faec699a3e3_1440w.jpg" alt="classical-mechanics-1-2"></p>
<p>对比之前不同状态之间的选择, 加上各种自然现象给我们的暗示, 我们可以很自然的做出那个从哲学上来说是如此的优美的假设. 既然我们的造物主这么喜欢极值, 说不定对于路径的选择也是遵循某种极值法则来的. 也就是说, 每一种运动方式, 即每一条路径都对应了一个数(这个数被我们称作 <strong>“作用量”</strong>), 在上面的图中, 很显然这个数是 $x(t_0)$ 和 $x(t_1)$ 之间的运动的积分. 这个不同运动对应的数, 或者说运动对应的函数我们用 $\mathcal{L}$ 来表示, 描述空间中的运动需要两个量: 位置 $q$ 和速度 $\dot{q}$, 再加上单独的时间维, 我们可以确定出一个描述力学体系运动的函数:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L}(q_i, \dot{q}_i,t)
    \end{aligned}
\end{equation}</script><p>那么作用量就被表述为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{A} = \int_{t_0}^{t_1}\mathcal{L(q_i, \dot{q}_i,t)} \mathrm{d}t
    \end{aligned}
\end{equation}</script><p>也就是说作用量 $\mathcal{A}$ 实际上是函数 $\mathcal{L}$ 的积分, 通过变分法求出满足使得 $\mathcal{A}$ 得极小值的函数 $\mathcal{L}$ 即可, 其对应的运动形式就是自然在无数条轨迹中选择的那一条.</p>
<h2 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h2><p>上面的内容中我们假设了世界遵循的一般规律, 即最小作用量原理, 这一部分我们就直接尝试从最小作用量原理推出物体运动的方程, 来看看世界选择的运动形式是什么样的.</p>
<p>首先应该注意到, 我们的作用量作为函数是不依赖于时间的, 这与描述运动的 $\mathcal{L}$ 函数不同, $\mathcal{L}$ 通过 $q(t)$, $\dot{q}(t)$ 隐含了最终变量 $t$, 但是在 $\mathcal{L}$ 到作用量 $\mathcal{A}$ 的积分中, $t$ 已经被积分掉了, 因此作用量依赖的不再是时间 $t$ 而是 $q(t)$ 的函数形式, 是函数到数的映射. 对这样一个依赖于函数的函数作微分的操作来自于数学的<strong>泛函分析</strong>, 即”变分法”, 其过程和处理数到数的映射的微积分类似.</p>
<p>现在我们要求对作用量 $\mathcal{A}$ 的变分 $\delta \mathcal{A} = 0$, 作为作用量取到极值的条件. 即我们需要挑选出满足下面两个条件的函数 $q(t)$:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \begin{cases}
           \mathbf{q}(t_0)  = \mathbf{q}_0, \mathbf{q}(t_1) = \mathbf{q}_1 \\
           \delta \mathcal{A} = \delta \int_{t_0}^{t_1} \mathcal{L}(\mathbf{q}(t), \dot{\mathbf{q}}(t),t) \mathrm{d}t= 0
        \end{cases}
    \end{aligned}
\end{equation}</script><p>重点是第二项的变分, 我们将其单独拿出来分析:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \delta \mathcal{A} &= \delta \int_{t_0}^{t_1} \mathcal{L}(\mathbf{q}(t), \dot{\mathbf{q}}(t),t) \mathrm{d}t\\
        &= \int_{t_0}^{t_1} \sum_{i}\left( \frac{\partial \mathcal{L}}{\partial q_i} \delta q_i + \frac{\partial \mathcal{L}}{\partial \dot{q}_i} \delta \dot{q}_i \right) \mathrm{d}t\\
    \end{aligned}
\end{equation}</script><p>其中, $\delta \dot{q}_i$ 变分和微分可以交换次序, 即 $\delta \dot{q}_i = \mathrm{d}/\mathrm{d}t (\delta q_i)$, 那么上式的被积分的第二项可以变为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\int_{t_0}^{t_1} \sum_{i}\frac{\partial \mathcal{L}}{\partial \dot{q}_i}\frac{\mathrm{d}}{\mathrm{d}t}(\delta q_i) \mathrm{d}t \\
        &= \int_{t_0}^{t_1} \frac{\partial \mathcal{L}}{\partial \dot{q}_i}\mathrm{d}(\delta q_i) \\
        &= \left. \sum_{i}\frac{\partial \mathcal{L}}{\partial \dot{q}_i}\delta q_i \right|_{t_0}^{t_1} - \int_{t_0}^{t_1} \sum_{i} \delta q_i \mathrm{d}\left( \frac{\partial \mathcal{L}}{\partial \dot{q}_i} \right)
    \end{aligned}
\end{equation}</script><p>其中由于 $t_1$ 和 $t_2$ 时刻的位置都是固定的, 所以 $\delta q_i$ 在这两个位置都为零, 即上式第一项为零, 第二项有:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \delta q_i \mathrm{d}\left( \frac{\partial \mathcal{L}}{\partial \dot{q}_i} \right) = \delta q_i \frac{\mathrm{d}}{\mathrm{d} t}\left( \frac{\partial \mathcal{L}}{\partial \dot{q}_i} \right) \mathrm{d}t
    \end{aligned}
\end{equation}</script><p>将上述结论代回到 $(6)$ 式中, 有:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \delta \mathcal{A} = \int_{t_0}^{t_1} \sum_{i} \left( \frac{\partial \mathcal{L}}{\partial q_i} - \frac{\mathrm{d}}{\mathrm{d}t}\left( \frac{\partial \mathcal{L}}{\partial \dot{q}_i} \right) \delta q_i \right) \mathrm{d}t = 0
    \end{aligned}
\end{equation}</script><p>要求 $\mathcal{L}$ 满足上式, 只能是:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial \mathcal{L}}{\partial q_i} - \frac{\mathrm{d}}{\mathrm{d}t}\left( \frac{\partial \mathcal{L}}{\partial \dot{q}_i} \right) = 0
    \end{aligned}
\end{equation}</script><p>对所有的 $i$ 都成立才行. 这就是 <span style='background: pink'>拉格朗日方程</span>, 它就是自然界选择的实际运动所满足的微分方程, 其中对运动进行描述的量 $\mathcal{L}$ 被称为 <span style='background: pink'><strong>拉格朗日量</strong></span> 或者 <span style='background: pink'><strong>拉格朗日函数</strong></span>. 可以指出的是, 一个拉格朗日函数对应了一个力学体系, 但一个力学体系却可以有多个拉格朗日函数来表述, 这是由于两个不同的拉格朗日函数各自得到的作用量的变分可能是一样的. 实际上表述出来为:</p>
<p>$\mathcal{L} = \mathcal{L}(\mathbf{q}, \dot{\mathbf{q}}, t)$ 与 <script type="math/tex">\mathcal{L}^\prime = \mathcal{L}(\mathbf{q}, \dot{\mathbf{q}}, t) + \frac{\mathrm{d}}{\mathrm{d} t}f(\mathbf{q}, t)</script> 描述的是同一个力学系统.</p>
<h2 id="从拉格朗日力学到牛顿力学"><a href="#从拉格朗日力学到牛顿力学" class="headerlink" title="从拉格朗日力学到牛顿力学"></a>从拉格朗日力学到牛顿力学</h2><p>上面的过程虽然给出了一个运动对应的拉格朗日函数以及它所需要满足的微分方程, 但这个函数的具体形式还尚不清楚, 对于具体的问题我们也没法直接上手分析, 所以这一部分的内容就来讨论这个函数的具体形式是什么样的, 实际上就是将拉格朗日力学与牛顿力学建立起联系的过程.</p>
<p>参考系的选择对于一个力学体系的研究来说是非常重要的, 按照现代引力理论的观点, 引力并不是实际存在的力, 而时空的不均匀性引起的物体运动状态的改变, 即在现实的任意的参考系(地球)中, 时空的不均匀性将会导致不受外力作用的物体无法保持静止. 但是我们总能找到一个参考系, 时空间相对它来说是均匀且各向同性的, 这样的参考系称为: <span style='background: pink'><strong>惯性参考系</strong></span>, 在这样的参考系中, 自由(没有外力作用的情况下)物体将会永远保持它的运动状态.</p>
<p>对于这样一个惯性系中自由运动的质点, 时间和空间的均匀性意味着运动对应的函数不显含时间 $t$ 和位置 $q$, 这样一来, $\mathcal{L}$ 就只能是速度 $v$ 的函数. 同时, 空间的各向同性意味着速度的方向不会影响运动, 拉格朗日量应该只取决于速度的大小, 对于速度这样一个矢量来说, 平方之后的量刚好能够满足条件, 即:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L} = \mathcal{L}(\mathbf{v}^2) = \mathcal{L}(v^2)
    \end{aligned}
\end{equation}</script><p>同时, 由于拉格朗日函数不显含位置矢量, 即 $\partial \mathcal{L}/\partial \mathbf{r} = 0$, 其满足的拉格朗日方程就变成:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\frac{\mathrm{d}}{\mathrm{d}t}\frac{\partial \mathcal{L}}{\partial \dot{\mathbf{r}}} = 0 \\
        &\implies \frac{\partial \mathcal{L}}{\partial \mathbf{v}} = \operatorname{const}\\
    \end{aligned}
\end{equation}</script><p>根据公式 $(12)$:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\frac{\partial \mathcal{L}(\mathbf{v}^2)}{\partial \mathbf{v}} = \frac{\partial \mathcal{L}}{\partial \mathbf{v}} \cdot 2\mathbf{v} = \operatorname{const}\\
        &\implies \operatorname{const} \cdot 2\mathbf{v} = \operatorname{const}\\
        &\implies \mathbf{v} = \operatorname{const}
    \end{aligned}
\end{equation}</script><p>这样我们从时空间均匀且各向同性的假设出发, 推出来了这样的参考系中自由物体运动状态不变的<span style='background: pink'><strong>惯性定理</strong></span>. </p>
<p>如果此时我们引入另外一个惯性参考系, 它相对于第一个惯性系作匀速直线运动, 根据时空间均匀且各向同性的性质, 自由物体在这两个不同的惯性参考系中的运动应该是等价的, 力学规律是相同的, 这就是<span style='background: pink'><strong>伽利略相对性原理</strong></span>. 那么我们假设现在有两个惯性系 $K$ 和 $K^{\prime}$, 两者之间以一个无穷小的速度 $\epsilon$ 相对运动, 根据拉格朗日量和速度的平方有关, 我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L}^{\prime} = \mathcal{L}(v^{\prime 2}) = \mathcal{L}(v^{2} + 2 \mathbf{v} \cdot \mathbf{\epsilon} + \epsilon^{2})
    \end{aligned}
\end{equation}</script><p>将这个式子对无穷小量 $\epsilon$ 进行泰勒展开, 忽略高阶无穷小项:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L}(v^{\prime 2}) = \mathcal{L}(v^{2}) + 2 \frac{\partial \mathcal{L}}{\partial v^{2}} \mathbf{v} \cdot \mathbf{\epsilon}
    \end{aligned}
\end{equation}</script><p>由于 $K$ 和 $K^{\prime}$ 都是惯性系, 所以应该满足关系:</p>
<script type="math/tex; mode=display">
\mathcal{L}(v^{\prime 2}) = \mathcal{L}(v^{2}) + \frac{\mathrm{d}}{\mathrm{d} t} f(\mathbf{r}, t) = \mathcal{L}(v^{2}) + \frac{\partial f}{\partial \mathbf{r}} \cdot \mathbf{v} + \frac{\partial f}{\partial t}</script><p>即式 $(16)$ 中的第二项要作为时间的全导数存在, 而且惯性系中的拉格朗日量不显含时间, 那么我们有:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        2 \frac{\partial \mathcal{L}}{\partial v^{2}} \mathbf{\epsilon} = \frac{\partial f}{\partial \mathbf{r}}
    \end{aligned}
\end{equation}</script><p>这个式子左边不含有 $\mathbf{r}$, 右边不含有 $\mathbf{v}$, 还要求左右相等, 只能是两边都等于一个常数, 令这个常数为: $m \epsilon$, 则可以得到自由质点的拉格朗日量为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L} = \frac{1}{2} m v^{2}
    \end{aligned}
\end{equation}</script><p>其中, $m$ 被定义为 <span style='background: pink'><strong>质量</strong></span>.</p>
<p>这样可以得到无相互作用的质点系的拉格朗日量为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L} = \sum_{\alpha} \frac{m_{\alpha}v^{2}_{\alpha}}{2}
    \end{aligned}
\end{equation}</script><p>对于存在相互作用的自由质点系(质点系内存在相互作用, 但整个质点系不受到任何外力作用), 需要考虑相互作用对拉格朗日量的影响, 这一项必然包含多个质点的坐标, 即:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L} = \sum_{\alpha}\frac{1}{2} m_{\alpha} v_{\alpha}^{2} + G(\mathbf{r}_1, \mathbf{r}_2, \mathbf{r}_3, \cdots, \mathbf{r}_{N}, t)
    \end{aligned}
\end{equation}</script><p>其中, 我们将第一部分无相互作用质点系的拉格朗日函数表示为 $T$, 根据之前牛顿力学的结论我们知道这实际上就是质点系的动能, 后续我们将给出它的一般含义. 而后面相互作用对拉格朗日量的影响我们设定为只和所有质点在同一时刻的位置有关, 并且这种相互作用时瞬时传递的, 只有这样才能满足伽利略相对性原理, 这在朗道的书中有更详细的描述, 同时由于时间的各向同性, 证明我们的力学系统是可逆的, 这一点是所有经典力学成立的前提.</p>
<p>通过上面的拉格朗日函数的形式, 结合运动满足的拉格朗日方程, 有:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial \mathcal{L}}{\partial \mathbf{r}_{\alpha}} &= \frac{\mathrm{d}}{\mathrm{d}t}\frac{\partial \mathcal{L}}{\partial \mathbf{v}_{\alpha}} \\
        \implies \frac{\partial G}{\partial \mathbf{r}_{\alpha}} &= m_{\alpha} \mathbf{a}_{\alpha} = \mathbf{F}_{\alpha}
    \end{aligned}
\end{equation}</script><p>对上述过程如果令 $G = -V$, 那就直接回到了之前牛顿力学的形式, 即:</p>
<script type="math/tex; mode=display">
\mathbf{F} = - \frac{\partial V}{\partial \mathbf{r}}</script><p>其中, $V$ 就是势能函数, 表示质点系中的相互作用. 同时拉格朗日函数形式变成了:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathcal{L} = T - V
    \end{aligned}
\end{equation}</script><p>这就是我们常见的拉格朗日函数形式了.</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>理论物理</category>
        <category>经典力学</category>
      </categories>
      <tags>
        <tag>理论物理</tag>
        <tag>经典力学</tag>
        <tag>最小作用量原理</tag>
        <tag>拉格朗日力学</tag>
      </tags>
  </entry>
  <entry>
    <title>磁流体力学方程组的推导</title>
    <url>/2022/10/13/PPB-MHD-E/</url>
    <content><![CDATA[<p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/post/MHD-E-20221013234420.png" alt="科学网一三流体磁重联模型大尺度磁岛融合、激波、尾涡结果1-朱伯情的博文"></p>
<div class="note primary flat"><p>本文基于王晓钢老师的《等离子体物理》第一章的内容对等离子体流体描述的基本方程组进行大致推导，作为本人的学习笔记方便后续学习，也供相关领域的同学交流学习。</p>
</div>
<h1 id="双流体模型"><a href="#双流体模型" class="headerlink" title="双流体模型"></a>双流体模型</h1><h2 id="从动理论方程到磁流体方程"><a href="#从动理论方程到磁流体方程" class="headerlink" title="从动理论方程到磁流体方程"></a>从动理论方程到磁流体方程</h2><p>一般来说总是先学习等离子体的流体描述再学习动理学描述（按照国内的习惯），但实际上动理学的描述更加基本，更加触及物理本质。如果我们遵循朗道大佬的遗志，从物理的本质出发得到我们所关注的现象，动理学描述才是一开始我们应该接触的理论。所以我们这里假设大家都简单地了解过动理学描述的内容，至少知道速度分布函数与其宏观物理量之间的关系以及空间无碰撞等离子体最常使用的弗拉索夫（Vlasov）方程：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial{f}}{\partial{t}}+\vec{\dot{r}} \cdot \nabla f + \vec{\dot{v}} \cdot \frac{\partial f}{\partial \vec{v}} = 0
    \end{aligned}
\end{equation}</script><p>上述方程是对玻尔兹曼（Boltzmann）方程的简化，方程左边是对 $ f $ 的<strong>全微分</strong>，右边是碰撞项为零（造成的分布函数的变化）。对碰撞项采用不同的近似我们将的到不同的描述方程。</p>
<p>根据统计物理的理论，对上述 Vlasov 方程取速度的零阶矩积分：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int \frac { \partial f } { \partial t } \mathrm{d} \vec{v}+ \int \vec{v} \cdot \frac { \partial f } { \partial \vec{r} } \mathrm{d} \vec{v} + \int \frac { q } { m } ( \vec{E} + \vec{v} \times \vec{B} ) \cdot \frac { \partial f } { \partial \vec{v} } \mathrm{d} \vec{v} = 0
    \end{aligned}
\end{equation}</script><p>由于：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int f \mathrm{d}\vec{v} &= n \\
        \int f \vec{v} \mathrm{d}\vec{v} &= n\vec{u}
    \end{aligned}
\end{equation}</script><p>方程（2）的前两项可以很简单的给出：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int \frac{\partial f}{\partial t} \mathrm{d}\vec{v} &= \frac{\partial n}{\partial t} \\[8pt]
        \int \vec{v} \cdot \frac{\partial f}{\partial \vec{r}} \mathrm{d}\vec{v} &= \frac{\partial }{\partial \vec{r}} \cdot (n\vec{u}) = \nabla \cdot (n\vec{u})
    \end{aligned}
\end{equation}</script><p>将第三项拆开，首先来看含有 $\vec{E}$ 的项：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int \frac{q}{m} \vec{E} \cdot \frac{\partial f}{\partial \vec{v}} \mathrm{d}\vec{v} = \frac{q}{m} \int \frac{\partial}{\partial \vec{v}} \cdot (f \vec{E})\ \mathrm{d}\vec{v} = \int_{\vec{S} \infty} f \vec{E} \cdot \mathrm{\vec{S}} = 0
    \end{aligned}
\end{equation}</script><p>上述过程用到了在速度空间中的高斯定理，当 $v \rightarrow \infty$ 时，$f \rightarrow 0$ 的速度比 $v^{-2} \rightarrow 0$ 的速度更快对所有具有有限能量的分布是必要的，所以我们可以判断上式等于零。</p>
<p>对于（2）式中左边的最后一项我们可以做出定性的分析，$\vec{v} \times \vec{B}$ 与 $\partial /\partial \vec{v}$ 的矢量方向必定是垂直的，所以：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int \frac{q}{m} (\vec{v} \times \vec{B}) \cdot \frac{\partial f}{\partial \vec{v}}\ \mathrm{d}\vec{v} = 0
    \end{aligned}
\end{equation}</script><p>于是我们得到 <strong>连续性方程</strong>：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\frac{\partial n_\alpha}{\partial t} + \nabla \cdot (n_\alpha \vec{u}_\alpha) = 0}
    \end{aligned}
\end{equation}</script><p>下标 $\alpha$ 表示不同种类的粒子。</p>
<p>基于同样的过程，对 Vlasov 方程取速度的二阶矩积分（方程的左右两边乘上 $m\vec{v}$ 然后积分）有：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \int \vec{v} \frac{\partial f}{\partial t}\ \mathrm{d}\vec{v} + m \int \vec{v}(\vec{v} \cdot \nabla)f\ \mathrm{d}\vec{v} + q \int \vec{v} (\vec{E} + \vec{v} \times \vec{B}) \cdot \frac{\partial f}{\partial \vec{v}}\ \mathrm{d}\vec{v} = 0 
    \end{aligned}
\end{equation}</script><p>对第一项和第三项有：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \int \vec{v} \frac{\partial f}{\partial t}\ \mathrm{d}\vec{v} = m \frac{\partial (n \vec{u})}{\partial t}
    \end{aligned}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \int \vec{v} (\vec{E} + \vec{v} \times \vec{B}) \cdot \frac{\partial f}{\partial \vec{v}}\ \mathrm{d}\vec{v} &= \int \frac{\partial}{\partial \vec{v}} \cdot \left[f \vec{v}(\vec{E} + \vec{v} \times \vec{B})\right] \mathrm{d}\vec{v} \\[8pt]
        &- \int f \frac{\partial}{\partial \vec{v}} \cdot \left[\vec{v}(\vec{E}+\vec{v}\times\vec{B})\right] \mathrm{d}\vec{v} \\[8pt]
        &= \int \frac{\partial}{\partial \vec{v}} \cdot \left[f \vec{v}(\vec{E} + \vec{v} \times \vec{B})\right] \mathrm{d}\vec{v} \\[8pt]
        &- \int \left(\frac{\partial}{\partial \vec{v}} \cdot f \vec{v}\right)(\vec{E} + \vec{v} \times \vec{B}) \mathrm{d}\vec{v} \\[8pt]
        &- \int \left(f \vec{v} \cdot \frac{\partial}{\partial \vec{v}}\right)(\vec{E} + \vec{v} \times \vec{B}) \mathrm{d}\vec{v}
    \end{aligned}
\end{equation}</script><p>与之前的分析类似，利用高斯定理可以得到前两个积分为零。又因为 $\partial/\partial \vec{v}$ 与 $\vec{v}$ 平行，即 $\vec{v} \cdot \partial/\partial \vec{v} = 1$，则：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        q \int \vec{v} (\vec{E} + \vec{v} \times \vec{B}) \cdot \frac{\partial f}{\partial \vec{v}}\ \mathrm{d}\vec{v} &= -q \int f(\vec{E}+\vec{v}\times\vec{B})\mathrm{d}\vec{v} \\[8pt]
        &= -q n (\vec{E}+\vec{u}\times\vec{B})
    \end{aligned}
\end{equation}</script><p>对（8）式中的第二项有：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \int \vec{v}(\vec{v} \cdot \nabla)f\ \mathrm{d}\vec{v} = m \int \nabla \cdot (\vec{vv}) f \mathrm{d}\vec{v}-m \int \vec{v}(\nabla \cdot \vec{v})f\ \mathrm{d}\vec{v}
    \end{aligned}
\end{equation}</script><p>但在六维相空间中，$\nabla$ 与 $\vec{v}$ 是无关的，所以 $\nabla \cdot \vec{v} = 0$。则上式变为：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \int \vec{v}(\vec{v} \cdot \nabla)f\ \mathrm{d}\vec{v} = m \nabla \cdot \int f\vec{vv}\mathrm{d}\vec{v} = \nabla \cdot nm\overline{\vec{vv}}
    \end{aligned}
\end{equation}</script><p>对等离子体中的每一个粒子速度分为随流体运动的平均流体速度 $\vec{u}$ 和热速度 $\vec{\theta }$，即 $\vec{v} = \vec{u}+\vec{\theta}$， 如此一来，（13）式变为：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \nabla \cdot nm\overline{\vec{vv}} = \nabla \cdot (nm\vec{uu}) + \nabla \cdot (nm\overline{\vec{\theta\theta}}) + \nabla \cdot (2nm\vec{u}\overline{\vec{\theta}})
    \end{aligned}
\end{equation}</script><p>平均热速度 $\overline{\vec{\theta}}$ 显然为零，同时我们将 $nm\overline{\vec{\theta\theta}}$ 定义为 <strong>压力张量</strong> $\vec{P}$。则通过一阶矩积分我们得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \frac{\partial (n \vec{u})}{\partial t} &+ \nabla \cdot (nm\vec{uu}) + \nabla \cdot \vec{P} - qn(\vec{E}+\vec{u}\times\vec{B}) \\[8pt]
        &= m \frac{\partial n}{\partial t} \vec{u} + nm \frac{\partial \vec{u}}{\partial t}+ (\nabla \cdot nm\vec{u}) \vec{u} \\[8pt]
        &+ nm\vec{u} \cdot \nabla \vec{u} +\nabla \cdot \vec{P} - qn(\vec{E}+\vec{u}\times\vec{B}) \\[8pt]
    \end{aligned}
\end{equation}</script><p>上式中第一项和第三项可以用连续性方程相互抵消：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \frac{\partial n}{\partial t} \vec{u} + (\nabla \cdot nm\vec{u}) \vec{u} = m \vec{u} \left( \frac{\partial n}{\partial t} + \nabla \cdot n\vec{u} \right) = 0
    \end{aligned}
\end{equation}</script><p>再加上流体各向同性的假设，得到 <strong>动量方程</strong> ：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{n_\alpha m_\alpha \left( \frac{\partial\vec{u}_\alpha}{\partial t} + \vec{u}_\alpha \cdot \nabla \vec{u}_\alpha \right) = n_\alpha q_\alpha (\vec{E}+\vec{u}_\alpha \times \vec{B}) - \nabla \cdot \vec{P}_\alpha}
    \end{aligned}
\end{equation}</script><p><strong>上述过程中我们可以看到，零阶矩得到的连续性方程中包含有一阶矩得到的动量方程中的项—— $\nabla \cdot (nm\vec{u})$ ，而动量方程中又包含了二阶矩得到的量—— $\nabla \cdot \vec{P}$ ，以此类推可以无限递推下去，各阶矩之间是相互耦合的，因此我们需要在二阶矩处做出截断。</strong></p>
<p>即不再进行动理学方程的二阶矩积分，而将动量方程中 $\nabla  \cdot \vec{P}$ 变成 $\nabla p_\alpha$，并利用下面的 <strong>状态方程</strong> 进行计算：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\frac{\partial p_\alpha}{\partial t} + \vec{u}_\alpha \cdot \nabla p_\alpha = - \gamma p_\alpha \nabla \cdot \vec{u}_\alpha}
    \end{aligned}
\end{equation}</script><p>实际上这是绝热状态下状态方程的近似，具体可以参考热力学教材。</p>
<h2 id="双流体模型-1"><a href="#双流体模型-1" class="headerlink" title="双流体模型"></a>双流体模型</h2><p>如果在上述过程中考虑碰撞项，动量方程（高斯单位制）将变成：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &n_\alpha m_\alpha\left(\frac{\partial \vec{u}_\alpha}{\partial t}+\vec{u}_\alpha \cdot \nabla \vec{u}_\alpha\right)= \\
        &\quad=-\nabla p_\alpha+n_\alpha q_\alpha\left[\vec{E}+\frac{\vec{u}_\alpha \times \vec{B}}{c}\right]-\sum_\beta \nu_{\alpha \beta} n_\alpha m_{\alpha} \vec{u}_{\alpha}
    \end{aligned}
\end{equation}</script><p>动量方程中涉及到的 $\vec{E}$ 和 $\vec{B}$ 需要用控制电磁场的 Maxwell 方程组来进行闭合，根据不同的情况我们需要使用电磁方程组中不同的方程。考虑电磁场的波动时需要 <strong>安培（Ampere）定律</strong>：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\nabla \times \vec{B} = \frac{4 \pi}{c} \vec{J} \left(+ \frac{1}{c} \frac{\partial \vec{E}}{\partial t}\right) = \frac{4 \pi}{c} \sum_\alpha n_\alpha q_\alpha \vec{u}_\alpha \left(+ \frac{1}{c} \frac{\partial \vec{E}}{\partial t}\right)}
    \end{aligned}
\end{equation}</script><p><strong>括号中的位移电流项在低频近似下通常被忽略，但在高频情况时位移电流项是非常重要的</strong>。除此之外，还有对于磁场的 <strong>高斯（Gaussian）定理</strong>：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\nabla \cdot \vec{B} = 0}
    \end{aligned}
\end{equation}</script><p>对于电场来说，如果仅仅研究静电问题则只需要使用 <strong>泊松（Poisson）方程</strong>：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\nabla \cdot \vec{E} = 4\pi \sum_\alpha n_\alpha q_\alpha}
    \end{aligned}
\end{equation}</script><p>对于电磁模式则需要 <strong>法拉第（Fayraday）定律</strong>：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\nabla \times \vec{E} = -\frac{1}{c} \frac{\partial \vec{B}}{\partial t}}
    \end{aligned}
\end{equation}</script><p>以上就是等离子体双流体模型的主要内容，在推倒过程中我们忽略了等离子体的各向异性，但在很多现实的等离子体过程中，各向异性的存在都是极其重要的。</p>
<h1 id="电子磁流体模型"><a href="#电子磁流体模型" class="headerlink" title="电子磁流体模型"></a>电子磁流体模型</h1><p>一般来说，双流体模型同时考察离子和电子的运动情况，但由于两者之间的质量差距（质子质量是电子质量的1836倍）导致两者物理量变化的时间尺度相差也很大，有时候电子完全改变自己的运动状态，但离子基本还没开始动，这在推导德拜长度的过程中也可以窥探一二。由于时间尺度的问题，在计算过程中对时间步长的要求需要很小，这样计算离子的运动就要很长的计算时间，但我们知道随着计算时间的增加计算的误差也在累积，最终导致计算存在很强的数值不稳定性。</p>
<p>在这样的背景下，我们干脆取极限情况下的近似，即 $m_e/m_i \to 0$，并且</p>
<ol>
<li><p><strong>完全忽略掉离子的运动</strong> 从而有：$\vec{J} = -n_e e \vec{u}_e$。同时如果忽略掉位移电流，在这种近似下我们可以推出：</p>
<script type="math/tex; mode=display">
\begin{equation}
 \begin{aligned}
     \nabla \cdot \vec{J} = \nabla \cdot (\nabla \times \vec{B}) = \underbrace{- e \nabla \cdot (n_e \vec{u}_e)  = e \frac{\partial n_e}{\partial t}}_{\text{连续性方程}} = 0
 \end{aligned}
\end{equation}</script><p>即电子的密度近似不随时间改变，若初始时刻电子分布是均匀的，那这种均匀状态将一直持续下去。在此基础上我们进一步假设</p>
</li>
<li><p><strong>电子是“不可压缩”的</strong> ，即：$\nabla \cdot \vec{u}_e = 0$。这对于磁约束等离子体来说是合适的，这一假设直接保证了电子密度是不随空间分布变化的。</p>
</li>
</ol>
<p>再引入哈密顿力学中的 <strong>电子流体正则动量</strong> $\vec{P}_e = m_e \vec{u}_e - e \vec{A}/c$，定义 $\nabla \times \vec{P}_e\equiv \vec{\Omega}_e$ 为“广义涡旋”，对动量方程（式（19））取旋度，加上前面的假设有：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\frac{\partial \vec{\Omega}_e}{\partial t} = \nabla \times (\vec{u}_e \times \vec{\Omega}_e) - \frac{e \nu_{ei}}{c} \rm{d}_e^2 \nabla^2 \vec{B}}
    \end{aligned}
\end{equation}</script><p>其中，$\rm{d}_e$ 为电子“趋肤深度”，且：</p>
<script type="math/tex; mode=display">
\begin{equation*}
    \begin{aligned}
        \vec{\Omega}_e &= -e (1-\rm{d}_e^2 \nabla^2) \vec{B}/c \\[8pt]
        \rm{d}_e &= c/\omega_{pe}
    \end{aligned}
\end{equation*}</script><p>式（25）被称为“电子磁流体方程”。<span class='mohu'>看起来是挺复杂的，我也不知道为什么这么复杂，但</span>如果物理量变化的空间特征尺度远远大于电子的趋肤深度，即 $\rm{d}_e^2 \nabla^2 \ll 1,\ \vec{\Omega}_e \approx -e\vec{B}/c$，并忽略碰撞，上述方程可以被简化为：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial \vec{B}}{\partial t} = \nabla \times (\vec{u}_e \times \vec{B})
    \end{aligned}
\end{equation}</script><p>这种形式就和 <strong>理想磁流体模型</strong> 的欧姆（Ohm）定律很接近了，从形式上来说是一样的。</p>
<p>然而，在空间等离子体的某些情况中，磁场很弱，以至于电子作为流体不可压缩的假设是不成立的。这时就需要考虑原来的双流体方程并作 $m_i \to \infty$ 假设，这一假设不会改变原本的双流体方程 <strong>除动量方程之外</strong> 的其他方程的形式，而对于动量方程我们有：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        n_e m_e \left(\frac{\partial \vec{u}_e}{\partial t}+\vec{u}_e \cdot \nabla\vec{u}_e\right) = -\nabla p_e - e n_e \left[\vec{E}+\frac{\vec{u}_e \times \vec{B}}{c}\right] + \frac{\nu_e m_e}{e} \vec{J}
    \end{aligned}
\end{equation}</script><p>其中 $\vec{J} = -e n_e \vec{u}_e$，这被称为 <strong>广义欧姆定律</strong>，因为它给出了电场和电流之间的关系，将其改成与一般的欧姆定律更像的形式为：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \vec{E} + \frac{\vec{u}_e \times \vec{B}}{c} = - \frac{m_e \left(\frac{\partial}{\partial t}+\vec{u}_e \cdot \nabla\right) (e n_e \vec{u}_e)}{e^2 n_e} - \frac{\nabla p_e}{e n_e} + \frac{\nu_e m_e}{e^2 n_e} \vec{J}
    \end{aligned}
\end{equation}</script><p>将等离子体电子振荡频率 $\omega_{pe} = e^2 n_e/4\pi m_e$ 以及电流 $\vec{J}$ 的表达式代入上式，并定义 $\eta \equiv 4\pi \nu_e/\omega_{pe}^2$，相当于 <strong>电阻</strong>，因此我们可以得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\vec{E} + \frac{\vec{u}_e \times \vec{B}}{c} = \eta \vec{J} - \frac{\nabla p_e}{e n_e} + \frac{4\pi}{\omega_{pe}^2} \left(\frac{\partial}{\partial t} + \vec{u}_e \cdot \nabla \right) \vec{J}}
    \end{aligned}
\end{equation}</script><p>上式中左边第二项为 <strong>霍尔效应项</strong> ，等式右边分别为 <strong>欧姆效应项</strong>，<strong>电子压强梯度项</strong> 以及 <strong>电子惯性项</strong>。再加上之前双流体方程的其他等式（下标 $\alpha$ 全部换成 $e$）即组成完整的 <strong>电子磁流体方程组</strong>。</p>
<h1 id="霍尔磁流体模型"><a href="#霍尔磁流体模型" class="headerlink" title="霍尔磁流体模型"></a>霍尔磁流体模型</h1><p>在上述的双流体计算的困境中，针对时间尺度的不同我们还可以选择主要考虑离子的运动，假设电子的所有运动都是“瞬间完成的”，即对 $m_e/m_i\to 0$ 的近似中取 $m_e = 0$。这样我们通过双流体的电子动量方程得到的广义欧姆定律将没有电子惯性项：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \vec{E} + \frac{\vec{u}_e \times \vec{B}}{c} = -\frac{\nabla p_e}{e n_e} - \eta n_e e \vec{u}_e
    \end{aligned}
\end{equation}</script><p>其中 $\eta$ 可以算是碰撞造成的“等效电阻”，因为电子质量的趋于零按照原本的定义算出来 $\eta$ 也为零，但实际的碰撞却还是存在的。可以发现，如果我们对上式取旋度就能得到式（26），也可以说是这个忽略了电子惯性项的模型显然满足特征尺度远大于电子趋肤深度的假设。</p>
<p>同时，根据 $\vec{J} = e(n_i \vec{u}_i - n_e \vec{u}_e)$ 以及电中性假设 $n_i \approx n_e$，上式我们可以写成：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \vec{E} + \left(\frac{\vec{u}_i \times \vec{B}}{c} - \frac{\vec{J} \times \vec{B}}{e n_e c}\right) = - \frac{\nabla p_e}{e n_e} - (\eta n_e e \vec{u}_i - \eta \vec{J})
    \end{aligned}
\end{equation}</script><p>这就和离子的动量方程建立了联系：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\vec{E} + \frac{\vec{u}_i \times \vec{B}}{c} = \frac{\vec{J} \times \vec{B}}{e n_e c} - \frac{\nabla p_e}{e n_e} + \eta (\vec{J} - n_e e \vec{u}_i)}
    \end{aligned}
\end{equation}</script><p>方程右边的第一项就是电磁学课本中的霍尔效应，因此我们将这个近似模型称为 <strong>霍尔（Hall）磁流体模型</strong>，通过对上式做量纲分析可以知道这个模型适用于离子的“惯性尺度”，即 $\rm{d_i} = c/\omega_{pi}\ (\gg \rm{d_e})$。</p>
<h1 id="理想磁流体模型"><a href="#理想磁流体模型" class="headerlink" title="理想磁流体模型"></a>理想磁流体模型</h1><h2 id="磁流体模型的基本假设"><a href="#磁流体模型的基本假设" class="headerlink" title="磁流体模型的基本假设"></a>磁流体模型的基本假设</h2><p> 我们应当了解，磁流体描述只是对等离子体的一种近似描述，要做这些近似需要很多的前提条件，根据王晓钢老师的书的节奏，这里我们就来讨论一下这些暗含的假设。</p>
<ol>
<li><p>时间尺度的假设：在时间尺度上，要求等离子变化的时间尺度远远大于带电粒子之间“短程”相互作用的时间尺度，即 $\tau_{\alpha \alpha}, \tau_{\alpha \beta} \ll \tau_{\text{H}}$。这意味着需要较高的碰撞频率，也就是说碰撞频繁在磁流体时间尺度内等离子体处于局域热力学平衡，即等离子体压强的各向同性，$p$ 作为一个标量存在（这样才能在二阶矩的地方进行截断）。</p>
</li>
<li><p>空间尺度的假设：由于磁流体的假设考虑的是流体元尺度（介观尺度）下的问题，所以粒子在背景磁场下的回旋运动在这里不会被考虑，因此我们需要假设等离子体的特征空间长度远大于带电粒子的回旋半径，同时在时间上还隐含着磁流体的特征时间远远大于带电粒子的回旋周期，即：</p>
<script type="math/tex; mode=display">
\begin{equation}
 \begin{aligned}
     \rho_{e}/L_{\text{H}} \ll \rho_{i}/L_{\text{H}} \ll 1,\ \omega_{\text{H}} \ll \Omega_{c i} \ll \Omega_{c i}
 \end{aligned}
\end{equation}</script></li>
<li><p>等离子体假设：该假设要求德拜球内含有大量的粒子，等离子体整体呈现电中性，即：</p>
<script type="math/tex; mode=display">
\begin{equation}
 \begin{aligned}
     n^{-1/3} \ll \lambda_{\rm{D}} \ll L_{\text{H}},\ \omega {\text{H}} \ll \omega_{p e},\ \Rightarrow \sum_{\alpha} n_{\alpha} q_{\alpha} \to 0
 \end{aligned}
\end{equation}</script><p>这一假设比较复杂，它实际上是保证等离子体是弱耦合等离子体，但弱耦合等离子体有时也被假设成“无碰撞”等离子体，这时候就和前面的局域热力学平衡假设矛盾，需要进一步讨论，我们这里暂且不表。</p>
</li>
<li><p>非相对论假设：这个比较简单，因为我们考虑的流体假设速度一般比较慢，不满足相对论条件，所以有：</p>
<script type="math/tex; mode=display">
\begin{equation}
 \begin{aligned}
     \omega/k \sim L_{\text{H}}/\tau_{\text{H}} \sim V_{\text{typical}} \ll c \Rightarrow \frac{1}{c} \frac{\partial \vec{E}}{\partial t} \to 0
 \end{aligned}
\end{equation}</script></li>
</ol>
<h2 id="理想磁流体力学方程组"><a href="#理想磁流体力学方程组" class="headerlink" title="理想磁流体力学方程组"></a>理想磁流体力学方程组</h2><p>这里我们将等离子体中的电子、离子成分看成是同一种流体，并利用局域电中性假设 $n_e = n_i = n$ 作出如下的假设：</p>
<ul>
<li><p>等离子体质量密度：</p>
<script type="math/tex; mode=display">
\begin{equation}
  \begin{aligned}
      \rho_{m} \equiv n (m_i + m_e) \approx n m_i
  \end{aligned}
\end{equation}</script></li>
<li><p>等离子体流体速度：</p>
<script type="math/tex; mode=display">
\begin{equation}
  \begin{aligned}
      \vec{u} = \frac{n_i m_i \vec{u}_i + n_e m_e \vec{u}_e}{n_i m_i + n_e m_e} = \vec{u}_i + \frac{m_e}{m_i} \vec{u}_e \approx \vec{u}_i
  \end{aligned}
\end{equation}</script></li>
<li><p>等离子体压强：</p>
<script type="math/tex; mode=display">
\begin{equation}
  \begin{aligned}
      p = n (T_e + T_i)
  \end{aligned}
\end{equation}</script></li>
<li><p>等离子体电流：</p>
<script type="math/tex; mode=display">
\begin{equation}
  \begin{aligned}
      \vec{J} = n e (\vec{u}_i - \vec{u}_e)
  \end{aligned}
\end{equation}</script></li>
</ul>
<p>利用上述四个方程对双流体方程的不同电荷分量进行求和，我们可以得到：</p>
<ul>
<li><p>连续性方程：</p>
<script type="math/tex; mode=display">
\begin{equation}
  \begin{aligned}
      \boxed{\frac{\partial n}{\partial t} + \nabla  \cdot (n \vec{u}) = 0}
  \end{aligned}
\end{equation}</script></li>
<li><p>动量方程：</p>
<script type="math/tex; mode=display">
\begin{equation}
  \begin{aligned}
      \boxed{n m_i \left( \frac{\partial \vec{u}}{\partial t} + \vec{u} \cdot \nabla \vec{u} \right) = \underbrace{- \nabla p + \frac{\vec{J} \times \vec{B}}{c} = - \nabla p + \frac{(\nabla \times \vec{B}) \times \vec{B}}{4 \pi}}_{\text{安培定律}}}
  \end{aligned}
\end{equation}</script></li>
</ul>
<p>同时，类似前面霍尔磁流体方程组的广义欧姆定律的推导我们可以有：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \vec{E} + \frac{\vec{u} \times \vec{B}}{c} = \frac{\vec{J} \times \vec{B}}{e n c} - \frac{\nabla p_e}{n e} + \eta \vec{J} + \frac{4 \pi}{\omega^2_{p e}} \left( \frac{\partial}{\partial t} + \vec{u}_e \cdot \nabla \right) \vec{J} - \frac{\nu_{e} m_e}{e} \vec{u} - \frac{m_e}{e} \left( \frac{\partial}{\partial t} + \vec{u}_e \cdot \nabla \right)  \vec{u}
    \end{aligned}
\end{equation}</script><p>上式已经将 $\vec{u} \approx \vec{u}_i$ 代入，这就是最一般形式的广义欧姆定律，通常认为电流主要是由电子携带的，这样就可以忽略最后两项离子的贡献而得到最常用到的广义欧姆定律：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \vec{E} + \frac{\vec{u} \times \vec{B}}{c} = \frac{\vec{J} \times \vec{B}}{e n c} - \frac{\nabla p_e}{n e} + \eta \vec{J} + \frac{4 \pi}{\omega^2_{p e}} \left( \frac{\partial}{\partial t} + \vec{u}_e \cdot \nabla \right) \vec{J}
    \end{aligned}
\end{equation}</script><p>忽略离子运动并假设电子不可压缩，对该方程取旋度就得到电子磁流体方程；忽略电子质量，即得到霍尔磁流体模型的广义欧姆定律。</p>
<p>所谓理想磁流体模型即在无碰撞近似下忽略方程右边的电阻项（欧姆效应项），同时考虑大尺度流体近似从而忽略右边所有的项得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\vec{E} + \frac{\vec{u} \times \vec{B}}{c} = 0}
    \end{aligned}
\end{equation}</script><p>这就是理想磁流体模型的广义欧姆定律了。代入法拉第电磁定律得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{\partial  \vec{B}}{\partial t} = \nabla \times (\vec{u} \times \vec{B})
    \end{aligned}
\end{equation}</script><p>加上状态方程：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \boxed{\frac{\partial p}{\partial t} + \vec{u} \cdot \nabla p = - \gamma p \nabla \cdot \vec{u}}
    \end{aligned}
\end{equation}</script><p>就得到完整的 <strong>理想磁流体（idea MHD）力学</strong> 方程组了。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>等离子体物理</category>
      </categories>
      <tags>
        <tag>等离子体物理</tag>
        <tag>磁流体力学</tag>
      </tags>
  </entry>
  <entry>
    <title>逃避自由——弗洛姆</title>
    <url>/2022/10/09/escapefromfreedom/</url>
    <content><![CDATA[<p>💡 读这本书的时候最大的感受就好像这不是上个世纪四十年代写的而是最近几年内才写出来的作品，不得不惊呼一个世纪以前的西方社会已经和现代社会如此相似，也许应该换种说法：世界在这将近一百年的时间里文明毫无进步，甚至出现某些畸形的生长……</p>
<p>💡 人或者人类文明在成长过程中通过对世界和自然的不断认识从而与<strong>原始纽带</strong>脱离，成为独立自由的个体。然而当我们完全独自地置于庞大复杂的世界中时，我们愈发感觉到自己的渺小，无能为力，尤其是现代社会垄断资本主义对中下层阶级的碾压之势下，这种感觉愈发强烈。虽然我们每个人都可以通过自己的努力得到财富，得到某种意义上的成功，但仍然存在着一股强大的力量阻拦在我们面前，我们得到的只是一个机会，仅此而已。在绝大多数人的生命中，仍然有一种笼罩整个生命过程的压力，对中国人来说房子，结婚，孩子，年老的父母等等，人们终其一生忙忙碌碌只为了这么寥寥几件事便耗尽毕生精力，卑躬屈膝，任由别人发号施令。经济情况好的时候，我们可以通过财富来麻痹自己，认为自己获得了自己想要的成功，从而避免孤独感，无能为力感。但是近几年疫情，经济肉眼可见的衰退，在这种<strong>经济政治</strong>的大环境下，人们开始倍感虚无，迫切地希望能够找到某种方式消解面对这个看起来复杂可怕社会环境带来的各种焦虑和痛苦。另一方面，现代资本主义对我们的文化带来的另一个及其危害严重的影响是：<strong>在我们无意识中，通过广告，教育，舆论，专家的虚假哄骗等各种方式让我们相信财富、成功、权利；让我们抛弃自己内心深处原本的愿望和想法，放弃自己的判断，利用我们的孤独感制造恐慌，焦虑，以至于被迫趋同，被迫追求权威。</strong>于是大家统一地希望获得更多的财富，权利，每天面带假笑，麻痹，虚伪地过着看似属于自己的日子。一旦社会整体开始出现这种倾向就陷入一种恶性循环，甚至此后的技术也开始加速这个过程（短视频、公众号等碎片化信息，推荐算法等等）。为了暂时性地消除这种日益膨胀的孤独与焦虑，一个世纪前的德国人民选择了<strong>法西斯主义</strong>，如今我们该去往何处不得而知。</p>
<p>💡 豆瓣评论中一部分人说本书只分析了问题所在，却并未给出答案。然而本书的最后一章明确指出了我们长久有效地解决自身孤独感，无能为力感的途径：实现自我的积极主动。对个体自我来说，应当充分发挥自己的能动性，积极主动地生活，遵从自己意愿，而不是被迫趋同。首先是要意识到这一点，本书前面很长的篇幅都在阐述现代社会相当大部分人并未意识到自己所处的状态，或者意识到所处的矛盾却苦于无法找到解脱之法。当我们意识到应当积极主动地寻求自我，通过自发活动将自己与世界联系起来，即<strong>遵循自发性的意识而活动</strong>，肯定自我的独一无二性，摒弃任何凌驾于真实自我之上的权威。有两个问题，每个人都实现这样的状态需要社会的经济政治条件；完全的自我表达和摒弃权威是否会导致无政府主义，导致社会滋生阴暗，暴力犯罪。书中首先解释了第二个问题：人无所谓好坏，人生来的倾向都是为了成长，发展以及表达潜力，只有在人的生命受阻时才会自主地产生破坏欲，同时渴求权利与权威（我们暂且不论这种理论的正确性，根据本书“逃避机制”的说法，至少通过经验和心理分析，这种说法是可以得到验证的）。如果个人的自我得到充分自由的发展，他的<strong>非社会性冲动</strong>的根本原因就不复存在。于是问题的关键回到我们应该如何构建一个个人的独立自由受到全面的保障，同时又能提供给人一种自我的安全感的社会？人类社会在这条道路上已经艰难前进了数百年，这看起来似乎是一个遥不可及的目标，但本书依旧给出了我们能够坚信这样的现实实现的原因，并在宏观上给出了自己的方案——民主社会主义。首先，现代资本主义的发展已经为我们提供了解决经济上维持个人与自我独立自由的可能，我们需要重新构建社会组织，实行计划经济（虽然并非易事）从而保障每一个人的平等权利；同时政治上基于现代民主制度的基础成就进行添砖加瓦。</p>
<p>应该说这个问题如此之复杂，以至于我们没有办法深入细致的讨论具体实行的措施，事实上这是国家机关的事情，政治学家或者社会学家只能给出一个大致方案。管理我们的依旧是一小撮精英组成的官僚机构所代表的国家权威，在通往这个理想的道路上我们还有很多的事情要做，尽管这本书已经写了将近80年，然而如今的社会比之当初的社会又好了多少呢，我们在这条道路上前进抑或是后退都是个问题。或者说如今的社会又有多少人清醒的认识到八十年前就有人指出的自己的困境呢？明白了自己所处的境地，指明了方向也不够，甚至还需要一个智者，一个权威来告诉自己到底应该走哪条路，这不是又回到了最初的权威主义的危墙之下了吗？</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>书评</category>
      </categories>
      <tags>
        <tag>自由</tag>
        <tag>孤独感</tag>
        <tag>社会心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>Kappa 分布简单介绍</title>
    <url>/2022/07/08/KappaDistribution/</url>
    <content><![CDATA[<h1 id="Kappa-分布简单介绍-🍓"><a href="#Kappa-分布简单介绍-🍓" class="headerlink" title="Kappa 分布简单介绍 🍓"></a>Kappa 分布简单介绍 🍓</h1><p>非热平衡分布（Non-thermal distributions）被证明在太阳风和空间等离子体中是非常常见的，相对于 Maxwellian 分布这种分布具有一个超热部分（superthermal tails）。在宇宙中任何低密度（<span style='background: yellow'>意味着碰撞可以忽略不计</span>）等离子体中这种分布都是有可能存在的。前人建立了一个带参数 $\kappa$ 的分布函数族来描述所有的 <span style='background: pink'>Non-thermal distributions</span>：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        f_{i}^{\kappa}(r, v)=\frac{n_{i}}{\left(\pi \kappa \theta_{\kappa i}^{2}\right)^{3 / 2}} \frac{\Gamma(\kappa+1)}{\Gamma(\kappa-1 / 2) \Gamma(3 / 2)}\left(1+\frac{v^{2}}{\kappa \theta_{\kappa i}^{2}}\right)^{-(\kappa+1)}
    \end{aligned}
\end{equation}</script><p>其中，$\theta$ 是在该分布下的热速度，可以通过下式求得：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \theta_{\kappa i} = \sqrt{(2 \kappa-3) \frac{K_B T_i}{\kappa m_i} }
    \end{aligned}
\end{equation}</script><p>要求 $\kappa &gt; \frac{3}{2}$ ，当 $\kappa \to \infty$ 上面的式子就变成 Maxwellian 分布。</p>
<p>我们把这个分布称作 <span style='background: pink'><strong>Kappa 分布</strong> 或者 <strong>广义洛伦兹速度分布</strong> </span> ，Kappa 分布相对 Maxwellian 分布来说在尾部的能量更高，并且粒子的速度呈幂方衰减。</p>
<p><img src="https://pic1.zhimg.com/v2-e4f398f591ffab215af1cf434cd88e78_1440w.jpg" alt="KappaDistribution-20220623170840"></p>
<p><span style='font-weight:bold' id='t1'>Tab 1. </span> Comparison of different analytical expressions for a Maxwellian and a Kappa VDF</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Maxwellian</th>
<th>Kappa</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number density</td>
<td>$n(r) = n_0 \exp{-\frac{R(r)}{\theta^2}}$</td>
<td>$ n(r)=n_{0}\left(1+\frac{R(r)}{\kappa \theta^{2}}\right)^{-\kappa+1 / 2} $</td>
</tr>
<tr>
<td>Temperature</td>
<td>$T(r) = T_0$</td>
<td>$ T(r)=T_{0} \frac{\kappa}{K-3 / 2}\left(1+\frac{R(r)}{\kappa \theta^{2}}\right) $</td>
</tr>
<tr>
<td>Escaping flux</td>
<td>$ F(r)=\frac{n_{0} \theta\left(1+v_{\mathrm{e}}^{2} / \theta^{2}\right)}{2 \pi^{1 / 2}} \exp \left(-\frac{v_{\mathrm{e}}^{2}}{\theta^{2}}\right) $</td>
<td>$ F(r)=\frac{n_{0} A_{\mathrm{k}} \theta\left(1+v_{\mathrm{e}}^{2} / \theta^{2}\right)}{4(\kappa-1) \kappa^{1 / 2}\left[1+v_{\mathrm{e}}^{2} /\left(\kappa \theta^{2}\right)\right]^{\kappa}} $</td>
</tr>
</tbody>
</table>
</div>
<p>在了解这些之后实际上就可以开始关于Kappa分布的相关研究了，我们关注的是这样的速度分布函数的粒子和各种等离子体波相互作用的结果。但是，实际上这种速度分布的形成也与这个相互作用的过程有很大的关系。</p>
<h1 id="空间等离子体-Kappa-分布的形成-🍌"><a href="#空间等离子体-Kappa-分布的形成-🍌" class="headerlink" title="空间等离子体 Kappa 分布的形成 🍌"></a>空间等离子体 Kappa 分布的形成 🍌</h1><p>很多的理论和猜想来说明 Kappa 分布到底是如何产生的，各种理论之间相差可能很远，大家各持自见，以下介绍一些本文主要参考的综述文章中提到的想法，也许能够激发出一些科学的思想。</p>
<p>Scudder 和 Olbert 首次提出了由于太阳风的扩张膨胀引起的不均匀性以及超热（ $E &gt; 7k_B T$ ）电子的库伦碰撞减少，自然地产生了非热（ non-thermal ）分布。</p>
<p>Hasegawa 等人（ 1985 ）展示了等离子体在超热辐射带中会由于光子导致的库仑场涨落引起速度空间扩散的增强，这种增强会产生幂律（ power-law ）分布。</p>
<p>Collier 在速度空间用随机游走的方式产生 Kappa 样式的分布函数，并用 Kappa 分布函数来研究了超热分布的绝热输运。同时他也证明了空间等离子体是能量不固定的动力学系统，因此最大熵的理论不应该对空间等离子体适用。</p>
<p>从理论上来说，类 Kappa 分布可以作为非广延 Tsallis 统计理论的熵推广的结果，<span style='background: pink'>物理上和库伦势、湍流以及间歇现象的长程性质有关</span>（physically related to the long-range nature of the Coulomb potential, turbulence and intermittency）。Kappa 分布与通过最大化 Tsallis 熵得到的 q 分布是等价的，收到长程作用和相关性的影响，系统天然地和非麦克斯韦分布有关（Leubner，2002，2004，2008）。09年 Livadiotis 和 McComas 也同样验证了 Kappa 分布可以天然地从 Tsallis 统计中得到，从而为复杂系统的描述提供了坚实的基础 （<span class='mohu'> McComas 大佬在13年写了一篇名为 _Understanding Kappa Distributions: A Toolbox for Space Science and Astrophysics_ 的综述，也是从非广延统计力学出发的，同样值得一看</span>）。</p>
<p>Vocks 等人说高频哨声波与电子的共振相互作用可以明显地影响速度空间扩散，从而形成在高能量段呈现各向同性的分布，实际上就是电子在准静态背景磁场下可以通过与线性波进行回旋共振或者瞬时阻尼（朗道共振）获得能量，这也可以用来解释地球前激波以及太阳耀斑中的磁流体波加速粒子的情况。</p>
<p>同时有研究证明在低频（不满足回旋共振的条件）大幅（large amplitude）波动存在时，非线性朗道阻尼作用也可以能量化粒子（<span class='mohu'>好家伙，咱就是干这个的O(∩_∩)O哈哈~</span>）。Fisk 和 Gloeckler 发现压缩湍流中的等离子体的随机加热可以产生幂律分布的特征，类似的，碰撞阻尼加热，热流（heat flows）以及温度各向异性的存在都有可能产生超热尾端状（superthermal tails）的速度分布。</p>
<p>本着类似的原则，Summers（1999）以及 Shizgal（2007）等人通过研究准线性波粒相互作用或者库伦碰撞的速度空间扩散系数（与速度（velocitis）超过热速度的粒子速率（speed）成反比）时考虑 Fokker-Plank（FP）方程的稳定解得到了 Kappa 分布。</p>
<p>同样的，一维静电弗拉索夫（Vlasov）模型也被提出来用以产生 Kappa 分布，另外，低频波与双麦克斯韦分布的均匀磁化等离子体不稳定性的相关问题也被作为 Kappa 分布的可能产生机制研究过。</p>
<p>综上所述，产生 Kappa 分布—— <span style='background: yellow'>超热尾端分布特征</span> 的机制可能有很多（也许大家都是正确的），这些都与等离子体的加热、加速或者更加深刻的物理内涵有关系。<strong>但不管怎么样，Kappa 分布都是一种生成我们在空间中所观测到的幂律分布等离子体的非常有用的数学工具，所以对于我们来说更重要的是如何用它来研究更多我们还没有弄清楚的物理过程。</strong></p>
<div class="note success flat"><p>以上这一部分的内容基本上只是将 Pierrard 等人的文章翻译了一遍，并未做太多的整理，原文将会在参考文献中提供。</p>
</div>
<h1 id="在程序中生成服从-Kappa-分布的随机数-🍎"><a href="#在程序中生成服从-Kappa-分布的随机数-🍎" class="headerlink" title="在程序中生成服从 Kappa 分布的随机数 🍎"></a>在程序中生成服从 Kappa 分布的随机数 🍎</h1><p>Kappa 分布的分布函数看起来是如此的复杂，它甚至在做三维的速度空间积分时没办法分解变量化成多个单变量积分的形式（<span class='mohu'>Maxwellian 分布就可以！</span>）。就算是简单的一维的分布，Maxwellian 分布可以直接调用各个语言函数库中的正态分布命令，比如 MATLAB 中的 <code>normrnd()</code> ，而 Kappa 分布却无从下手。不过好在人家本来这些语言中的随机数都是人为产生的，我们当然可以自己写一个生成 Kappa 分布的程序来实现我们的目的。</p>
<p>首先，生成一个任意分布的随机数主要有两种方法：</p>
<ul>
<li>变换法</li>
<li>接受拒绝法</li>
</ul>
<p>简单解释一下变换法就是通过分布函数单调递增的特性，先生成一堆均匀分布（0 ~ 1之间）的随机数（这个命令每个语言必定都有），再利用反函数讲这些随机数转换为按照我们所要求的分布的随机数（也就是反函数的反函数就是原函数的想法）；接受拒绝法要我们先生成一个可以直接生成的近似分布的随机数种群，要求这个近似的分布函数在每一点都要大于原分布函数的函数值，在生成一个0 ~ 1之间的均匀分布的随机数种群，如果均匀分布的随机数种群小于近似分布种群与要求分布之间的误差就接受近似分布种群，否则拒绝，重复多次即可。<span class='mohu'>（<strong>大概就是这样，并不完全准确，具体的还是推荐Google一下</strong>）</span></p>
<p>一般来说，Kappa 分布这样的复杂分布只能是按照接受-拒绝法这种劳神费力的方式来生成，但是呢！有人（Abdul et al. 2014, 2015, 2021）发现 Kappa 分布和统计学中常用的 <span style='background: yellow'>Student t 分布</span> 在本质上是等价的（只需要做个小小的无伤大雅的变换）。</p>
<p>对于一维的 Kappa 分布（均值为0）：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        f\left(v_{x}\right)=\left(\pi \kappa \theta^{2}\right)^{-1 / 2} \frac{\Gamma(\kappa)}{\Gamma(\kappa-1 / 2)}\left(1+\frac{v_{x}^{2}}{\kappa \theta^{2}}\right)^{-\kappa}
    \end{aligned}
\end{equation}</script><p>和一维的 Student t 分布：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        p(t)=\frac{1}{\sqrt{(v \pi)} \sigma} \frac{\Gamma\left(\frac{v+1}{2}\right)}{\Gamma\left(\frac{v}{2}\right)}\left[1+\frac{1}{v}\left(\frac{t-\mu}{\sigma}\right)^{2}\right]^{-\frac{1}{2}(v+1)}
    \end{aligned}
\end{equation}</script><p>通过变换：$\nu  = 2 \kappa - 1$，可以证明两者其实是一致的。</p>
<p>进一步的，方差 $\sigma^2$ 对应的变换为：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \sigma^{2}=\frac{\kappa \theta^{2}}{2 \kappa-1}
    \end{aligned}
\end{equation}</script><p>这样，我们就可以通过生成 Student t 分布来生成 Kappa 分布。非常幸运的是，Student t 分布在统计学中被研究得很深入，我们可以通过两个在 $\left[0,1\right]$ 内均匀分布的两个随机数种群 $a_1, a_2$ 就可以得到我们想要的分布：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        b&=\sqrt{v\left(a_{1}^{-2 / v}-1\right) \cos \left(2 \pi a_{2}\right)} \\
        c_{t}&=\mu+\sigma b
    \end{aligned}
\end{equation}</script><p>其中，均值通常取 0 ，表示整体的静止。</p>
<p>下面贴出根据上述理论写的 MATLAB 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randnumber</span> = <span class="title">rand_kappa</span><span class="params">(vth, kappa, n)</span></span></span><br><span class="line"><span class="comment">% Generate the random number which follow the Kappa distribution</span></span><br><span class="line"><span class="comment">% The kappa velocity loader</span></span><br><span class="line"><span class="comment">% inputs are the initial thermal velocity (vth) and the kappa indicie (kp) </span></span><br><span class="line"><span class="comment">% and the dimension(n) of the velocity data.</span></span><br><span class="line"></span><br><span class="line">mu = <span class="number">0</span>;</span><br><span class="line">nu = (<span class="number">2</span>*kappa) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a1 = <span class="built_in">rand</span>(<span class="number">1</span>,n);</span><br><span class="line">a2 = <span class="built_in">rand</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="comment">% a1 = 1e-10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% sigma = sqrt((kappa - 1.5)/(kappa - 0.5)) * vth;</span></span><br><span class="line">sigma = <span class="built_in">sqrt</span>((kappa)/(<span class="number">2</span>*kappa - <span class="number">1</span>)) * vth;</span><br><span class="line">y = <span class="built_in">sqrt</span>(nu .* (a1.^(<span class="number">-2</span>/nu)<span class="number">-1</span>)).*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>.*a2);</span><br><span class="line">randnumber = mu + sigma.*y;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>该程序生成的随机数统计结果和理论（Kappa 分布函数曲线）符合的很好，同时将其和 Maxwellian 分布作了个对比：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5000000</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">x = <span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">xsam = rand_kappa(<span class="number">5</span>, <span class="number">2</span>, n);</span><br><span class="line">mean_x = <span class="built_in">mean</span>(xsam);</span><br><span class="line"><span class="comment">% x = rand_kappa(1,2,n);</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(xsam)</span><br><span class="line">    <span class="keyword">if</span> xsam(<span class="built_in">i</span>) &gt; <span class="number">-20</span> &amp;&amp; xsam(<span class="built_in">i</span>) &lt; <span class="number">20</span></span><br><span class="line">        count = count+<span class="number">1</span>;</span><br><span class="line">        x(count) = xsam(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x(x==<span class="number">0</span>)=[];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">clf;</span><br><span class="line">histogram(x,<span class="number">40</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">v = <span class="built_in">linspace</span>(<span class="number">-20</span>,<span class="number">20</span>,<span class="number">10000</span>);</span><br><span class="line">k = <span class="number">2</span>;</span><br><span class="line">theta = <span class="number">5</span>;</span><br><span class="line">f = (<span class="built_in">pi</span>*k*theta^<span class="number">2</span>)^(<span class="number">-1</span>/<span class="number">2</span>).*(<span class="built_in">gamma</span>(k)/<span class="built_in">gamma</span>(k<span class="number">-1</span>/<span class="number">2</span>)).*(<span class="number">1</span>+v.^<span class="number">2.</span>/(k*theta^<span class="number">2</span>)).^(-(k));</span><br><span class="line">scale = n;</span><br><span class="line">fp = scale*f;</span><br><span class="line"><span class="built_in">plot</span>(v,fp,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;Kappa distribution&#x27;</span>);</span><br><span class="line">print(gcf,<span class="string">&#x27;4.jpg&#x27;</span>,<span class="string">&#x27;-r600&#x27;</span>,<span class="string">&#x27;-djpeg&#x27;</span>);</span><br><span class="line"><span class="comment">% figure(3);</span></span><br><span class="line"><span class="comment">% plot(v,f,&#x27;r&#x27;,&#x27;LineWidth&#x27;,2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">count2 = <span class="number">0</span>;</span><br><span class="line">x2 = <span class="built_in">zeros</span>(<span class="number">1</span>,n);</span><br><span class="line">xsam2 = normrnd(<span class="number">0</span>,theta,<span class="number">1</span>,n);</span><br><span class="line">mean_x_2 = <span class="built_in">mean</span>(xsam2);</span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">length</span>(xsam2)</span><br><span class="line">    <span class="keyword">if</span> xsam2(ii) &gt; <span class="number">-20</span> &amp;&amp; xsam2(ii) &lt; <span class="number">20</span></span><br><span class="line">        count2 = count2+<span class="number">1</span>;</span><br><span class="line">        x2(count2) = xsam2(ii);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x2(x==<span class="number">0</span>)=[];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">10</span>);</span><br><span class="line">clf;</span><br><span class="line">histogram(x2,<span class="number">40</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">v2 = <span class="built_in">linspace</span>(<span class="number">-20</span>,<span class="number">20</span>,<span class="number">10000</span>);</span><br><span class="line">f2 = (<span class="number">1</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*theta^<span class="number">2</span>))^(<span class="number">1</span>/<span class="number">2</span>).*<span class="built_in">exp</span>(-v2.^<span class="number">2.</span>/(<span class="number">2</span>*theta^<span class="number">2</span>));</span><br><span class="line">scale = n;</span><br><span class="line">fp2 = scale*f2;</span><br><span class="line"><span class="built_in">plot</span>(v2,fp2,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">title(<span class="string">&#x27;Maxwellian distribution&#x27;</span>);</span><br><span class="line">print(gcf,<span class="string">&#x27;3.jpg&#x27;</span>,<span class="string">&#x27;-r600&#x27;</span>,<span class="string">&#x27;-djpeg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">11</span>);</span><br><span class="line">gcf;</span><br><span class="line"><span class="built_in">plot</span>(v2,fp2,v,fp);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Maxwellian&#x27;</span>,<span class="string">&#x27;Kappa&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/v2-adfbaf5168804826c938446da1567999_1440w.jpg" alt="maxwellian"></p>
<p><img src="https://pic1.zhimg.com/v2-f0d928ff6762a3d61c16eb13c4f1eeb2_1440w.jpg" alt="kappa"></p>
<p>三维形式和一维情况类似，这里直接贴出代码，具体的可以在参考文献中找到：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">rand_kappa3</span><span class="params">(vth, kappa, n, dim, v0)</span></span></span><br><span class="line"><span class="comment">% Generate the random number which follow the 3-D Kappa distribution</span></span><br><span class="line"><span class="comment">% The kappa velocity loader</span></span><br><span class="line"><span class="comment">% inputs are the initial thermal velocity (vth), the kappa indicie (kp),</span></span><br><span class="line"><span class="comment">% the dimension(n) of the velocity data</span></span><br><span class="line"><span class="comment">% the dimension(dim) of your velocity space</span></span><br><span class="line"><span class="comment">% and the mean velocity(v0) vector</span></span><br><span class="line"></span><br><span class="line">mu = v0;</span><br><span class="line">nu = (<span class="number">2</span>*kappa) - <span class="number">1</span>; <span class="comment">% the freedom degree of student t distribution</span></span><br><span class="line"></span><br><span class="line">sigma = <span class="built_in">sqrt</span>(kappa/(<span class="number">2</span>*kappa<span class="number">-1</span>))*vth; <span class="comment">% scaling parameter</span></span><br><span class="line"></span><br><span class="line">Z = <span class="built_in">zeros</span>(dim,n);</span><br><span class="line">X = <span class="built_in">zeros</span>(dim,n);</span><br><span class="line">Chi_square = chi2rnd(nu,<span class="number">1</span>,n); <span class="comment">% generate the Chi-squared distribution random number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:dim</span><br><span class="line">    Z(<span class="built_in">i</span>,:) = normrnd(mu(<span class="built_in">i</span>),<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">% three-dimensional standard normal distribution </span></span><br><span class="line">    <span class="comment">% to be constructed, but the &quot;vth&quot; maybe some problem?</span></span><br><span class="line">    X(<span class="built_in">i</span>,:) = mu(<span class="built_in">i</span>) + sigma*<span class="built_in">sqrt</span>((nu./Chi_square)).*Z(<span class="built_in">i</span>,:); <span class="comment">% compute the </span></span><br><span class="line">    <span class="comment">% student t distribution(Kappa distribution) with Chi-squared</span></span><br><span class="line">    <span class="comment">% distribution and standard normal distribution</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="参考文献-🍉"><a href="#参考文献-🍉" class="headerlink" title="参考文献 🍉"></a>参考文献 🍉</h1><div class="note default flat"><p>[1]    L.-N. Hau, W.-Z. Fu. Mathematical and physical aspects of Kappa velocity distribution[J]. Physics of Plasmas, 2007, 14(11): 110702.<br>[2]    G. Livadiotis, D. J. McComas. Understanding Kappa Distributions: A Toolbox for Space Science and Astrophysics[J]. Space Science Reviews, 2013, 175(1): 183–214.<br>[3]    R. F. Abdul, R. L. Mace. One-dimensional particle-in-cell simulations of electrostatic Bernstein waves in plasmas with kappa velocity distributions[J]. Physics of Plasmas, American Institute of Physics, 2015, 22(10): 102107.<br>[4]    R. F. Abdul, R. L. Mace. A method to generate kappa distributed random deviates for particle-in-cell simulations[J]. Computer Physics Communications, 2014, 185(10): 2383–2386.<br>[5]    George Livadiotis. Kappa Distributions: Statistical Physics and Thermodynamics of Space and Astrophysical Plasmas[J]. Universe, 2018, 4(12): 144.<br>[6]    Kappa distributions: theory and applications in plasmas[M]. George Livadiotis. Amsterdam, Netherlands: Elsevier, 2017.<br>[7]    George Livadiotis. Kappa distribution in the presence of a potential energy[J]. Journal of Geophysical Research: Space Physics, 2015, 120(2): 880–903.<br>[8]    F. Nsengiyumva, R. L. Mace, M. A. Hellberg. Ion Bernstein waves in a plasma with a kappa velocity distribution[J]. Physics of Plasmas, American Institute of Physics, 2013, 20(10): 102107.<br>[9]    R. F. Abdul, A. P. Matthews, R. L. Mace. 2D particle-in-cell simulations of the electron temperature anisotropy driven whistler instability in plasmas having kappa velocity distributions[J]. Physics of Plasmas, 2021, 28(6): 062104.<br>[10]    G. Nicolaou, G. Livadiotis, C. J. Owen, 等. Determining the Kappa Distributions of Space Plasmas from Observations in a Limited Energy Range[J]. The Astrophysical Journal, 2018, 864(1): 3.<br>[11]    V. Pierrard, M. Lazar. Kappa Distributions: Theory and Applications in Space Plasmas[J]. Solar Physics, 2010, 267(1): 153–174.<br>[12]    J J Podesta. Plasma Dispersion Function for the Kappa Distribution[J]. 2004: 31.<br>[13]    Reginald Francis Abdul. 1-D Particle-in-cell simulations of plasmas with kappa velocity distributions[D]. University of KwaZulu-Natal, 2013.</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
        <category>等离子体物理</category>
      </categories>
      <tags>
        <tag>等离子体物理</tag>
        <tag>Kappa分布</tag>
        <tag>非热平衡</tag>
        <tag>随机数生成</tag>
      </tags>
  </entry>
  <entry>
    <title>Modeling the global geomagnetic field</title>
    <url>/2022/06/18/globalmagnetic/</url>
    <content><![CDATA[<h1 id="Advanced-Earth-electromagnetism-Homework-3"><a href="#Advanced-Earth-electromagnetism-Homework-3" class="headerlink" title="Advanced Earth electromagnetism Homework-3"></a>Advanced Earth electromagnetism Homework-3</h1><center><span style='font-size: 20px;font-weight:bold'>Build an internal geomagnetic using observatory data</span></center>

<center><div style='height:2mm;'></div><div style='font-family:华文楷体;font-size:14pt;'>Wu Xianshu 12132710</div></center>

<h2 id="Methods-and-data"><a href="#Methods-and-data" class="headerlink" title="Methods and data"></a>Methods and data</h2><p>According to the Gauss Theory of geomagnetism, we can use the spherical harmonic analysis to describe the earth’s main magnetic field. Suppose the magnetic potential of the geomagnetic field obeys Laplace’s equation at the surface of the Earth as well as outside of the Earth, the model can be written as:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        V(r,\theta,\phi)=a \sum_{n=1}^{N} \sum_{m=0}^{n}\left(g_{n}^{m} \cos m \phi+h_{n}^{m} \sin m \phi\right)\left(\frac{a}{r}\right)^{n+1} P_{n}^{m}(\cos \theta)
    \end{aligned}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        X&=\sum_{n=1}^{N} \sum_{m=0}^{n}\left(\frac{a}{r}\right)^{n+2}\left(g_{n}^{m} \cos m \phi+h_{n}^{m} \sin m \phi\right) \frac{d}{d \theta} p_{n}^{m}(\cos \theta) \\
        Y&=\sum_{n=1}^{N} \sum_{m=0}^{n} \frac{-m}{\sin \theta}\left(\frac{a}{r}\right)^{n+2}\left(-g_{n}^{m} \sin m \phi+h_{n}^{m} \cos m \phi\right) p_{m}^{m}(\cos \theta) \\
        Z&=\sum_{n=0}^{N} \sum_{m=0}^{n}-(n+1)\left(\frac{a}{r}\right)^{n+2}\left(g_{n}^{m} \cos m \phi+h_{n}^{m} \sin m \phi\right) p_{n}^{m}(\cos \theta)
    \end{aligned}
\end{equation}</script><p>The only uncertainty in the formula is $g_n^m$ and $h_n^m$, which called Gauss Coefficient, and when we have the model and the data, we can get the parameters value by inversion methods. The problem becomes solving the following system of linear algebraic equations (the observations are taken at a spherical surface of the Earth’s mean radius, $r=a$ ):</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{A}\mathbf{m}=\mathbf{d}
    \end{aligned}
\end{equation}</script><script type="math/tex; mode=display">
\begin{aligned}
    \mathbf{A} = \left[ \begin{array}{c}
        \vdots & \vdots & \vdots & \vdots \\ \cdots & \cos(m\phi_i)\frac{\mathrm{d} P_n^m(\cos\theta_i)}{\mathrm{d}\theta_i} & \sin(m\phi_i)\frac{\mathrm{d} P_n^m(\cos\theta_i)}{\mathrm{d}\theta_i} & \cdots \\
        \cdots & m \sin(m\phi_i)\frac{P_n^m(\cos\theta_i)}{\sin\theta_i} & -m \cos(m\phi_i)\frac{P_n^m(\cos\theta_i)}{\sin\theta_i} & \cdots \\
        \cdots & -\cos(m\phi_i)P_n^m(\cos\theta_i)(n+1) & -\sin(m\phi_i)P_n^m(\cos\theta_i)(n+1) & \cdots \\
        \vdots & \vdots & \vdots & \vdots 
    \end{array} \right];
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
    \mathbf{m} = \left[ \begin{array}{c}
        g_1^0 \\ \vdots \\ g_n^{n-1} \\ g_n^n \\h_n^1 \\ h_n^2 \\ \vdots \\ h_N^N
    \end{array} \right];\ \mathbf{d} = \left[ \begin{array}{c}
        \vdots \\ X_i \\ Y_i \\ Z_i \\ \vdots
    \end{array} \right];\ \frac{\mathrm{d}P_n^m(\cos\theta)}{\mathrm{d}\theta} = \frac{\left(n \cos \theta P_{n}^{m}-R_{n}^{m} P_{n-1}^{m}\right)}{\sin \theta};
\end{aligned}</script><p>The data in $\mathbf{d}$ are download from <strong>INTERMAGNET</strong>, the website is <a href="https://www.intermagnet.org/data-donnee/download-eng.php">https://www.intermagnet.org/data-donnee/download-eng.php</a>. I selected the definitive minute data on 2020-03-05 (Table <a href="#t1">1</a>), all available observation stations are included, Figure <a href="#f1">1</a> is a map showing the observatories I used. the 24-hour data of each station are averaged to obtain the observed values of the day, after eliminating the outliers. I wrote a MATLAB script to implement the above process, and built a model up to spherical harmonic degree 4.</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222202000594.png" alt="globalmagnetic-stations"></p>
<center id='f1'><span style='font-weight:bold'>Fig 1. </span>Map showing the observatories I used </center>

<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p><span style='font-weight:bold' id='t1'>Tab 1. </span>A table of data</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Index</th>
<th>Name</th>
<th>Latitude</th>
<th>Longitude</th>
<th>X</th>
<th>Y</th>
<th>Z</th>
<th>Date</th>
<th>Index</th>
<th>Name</th>
<th>Latitude</th>
<th>Longitude</th>
<th>X</th>
<th>Y</th>
<th>Z</th>
<th>Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>abg</td>
<td>18.62</td>
<td>72.87</td>
<td>38255.32861</td>
<td>290.4123611</td>
<td>20393.29507</td>
<td>20200305</td>
<td>42</td>
<td>kdu</td>
<td>-12.686</td>
<td>132.472</td>
<td>35457.00736</td>
<td>1754.704167</td>
<td>-29582.17056</td>
<td>20200305</td>
</tr>
<tr>
<td>2</td>
<td>abk</td>
<td>68.358</td>
<td>18.823</td>
<td>11263.29438</td>
<td>1862.256042</td>
<td>52149.73104</td>
<td>20200305</td>
<td>43</td>
<td>kep</td>
<td>-54.282</td>
<td>323.507</td>
<td>15328.23479</td>
<td>-1902.493542</td>
<td>-22927.075</td>
<td>20200305</td>
</tr>
<tr>
<td>3</td>
<td>aia</td>
<td>-65.25</td>
<td>295.73</td>
<td>19743.62451</td>
<td>5529.188194</td>
<td>-31781.59625</td>
<td>20200305</td>
<td>44</td>
<td>kmh</td>
<td>-26.541</td>
<td>18.11</td>
<td>10625.24368</td>
<td>-3290.684375</td>
<td>-24317.20576</td>
<td>20200305</td>
</tr>
<tr>
<td>4</td>
<td>asp</td>
<td>-23.761</td>
<td>133.883</td>
<td>30118.9534</td>
<td>2384.582361</td>
<td>-43746.81958</td>
<td>20200305</td>
<td>45</td>
<td>kny</td>
<td>31.424</td>
<td>130.88</td>
<td>32523.31208</td>
<td>-3937.392708</td>
<td>33352.49993</td>
<td>20200305</td>
</tr>
<tr>
<td>5</td>
<td>bdv</td>
<td>49.08</td>
<td>14.015</td>
<td>20408.24278</td>
<td>1476.498472</td>
<td>44384.11257</td>
<td>20200305</td>
<td>46</td>
<td>kou</td>
<td>5.21</td>
<td>307.269</td>
<td>26566.90834</td>
<td>-8649.159903</td>
<td>6534.03419</td>
<td>20200305</td>
</tr>
<tr>
<td>6</td>
<td>bel</td>
<td>51.836</td>
<td>20.789</td>
<td>18910.50938</td>
<td>2155.445069</td>
<td>46753.62417</td>
<td>20200305</td>
<td>47</td>
<td>lrm</td>
<td>-22.222</td>
<td>114.101</td>
<td>30377.57938</td>
<td>113.0718056</td>
<td>-43262.77563</td>
<td>20200305</td>
</tr>
<tr>
<td>7</td>
<td>bfo</td>
<td>48.331</td>
<td>8.325</td>
<td>21000.85431</td>
<td>971.8170139</td>
<td>43518.68674</td>
<td>20200305</td>
<td>48</td>
<td>lyc</td>
<td>64.612</td>
<td>18.748</td>
<td>12954.21903</td>
<td>1788.108194</td>
<td>50824.92569</td>
<td>20200305</td>
</tr>
<tr>
<td>8</td>
<td>bmt</td>
<td>40.3</td>
<td>116.2</td>
<td>27901.35056</td>
<td>-4109.268472</td>
<td>47580.71354</td>
<td>20200305</td>
<td>49</td>
<td>mab</td>
<td>50.298</td>
<td>5.683</td>
<td>20026.52454</td>
<td>676.6008535</td>
<td>44643.7574</td>
<td>20200305</td>
</tr>
<tr>
<td>9</td>
<td>box</td>
<td>58.07</td>
<td>38.23</td>
<td>15149.76771</td>
<td>3423.754653</td>
<td>50605.48924</td>
<td>20200305</td>
<td>50</td>
<td>maw</td>
<td>-67.6</td>
<td>62.88</td>
<td>6637.389861</td>
<td>-17331.47576</td>
<td>-45610.43313</td>
<td>20200305</td>
</tr>
<tr>
<td>10</td>
<td>brd</td>
<td>49.87</td>
<td>260.026</td>
<td>15215.71021</td>
<td>1349.588194</td>
<td>54525.18188</td>
<td>20200305</td>
<td>51</td>
<td>mcq</td>
<td>-54.5</td>
<td>158.95</td>
<td>10702.30986</td>
<td>6865.926042</td>
<td>-62729.04792</td>
<td>20200305</td>
</tr>
<tr>
<td>11</td>
<td>brw</td>
<td>71.32</td>
<td>203.38</td>
<td>8896.940417</td>
<td>2040.051944</td>
<td>56567.42097</td>
<td>20200305</td>
<td>52</td>
<td>mea</td>
<td>54.616</td>
<td>246.653</td>
<td>13676.0725</td>
<td>3502.193194</td>
<td>55141.94083</td>
<td>20200305</td>
</tr>
<tr>
<td>12</td>
<td>bsl</td>
<td>30.35</td>
<td>270.364</td>
<td>23897.89611</td>
<td>-534.3659028</td>
<td>40619.165</td>
<td>20200305</td>
<td>53</td>
<td>mmb</td>
<td>43.91</td>
<td>144.189</td>
<td>25860.92479</td>
<td>-4160.602986</td>
<td>42601.24806</td>
<td>20200305</td>
</tr>
<tr>
<td>13</td>
<td>cbb</td>
<td>69.123</td>
<td>254.969</td>
<td>5052.641181</td>
<td>515.9493056</td>
<td>58112.67063</td>
<td>20200305</td>
<td>54</td>
<td>ngk</td>
<td>52.072</td>
<td>12.675</td>
<td>18870.10889</td>
<td>1331.096806</td>
<td>45797.97604</td>
<td>20200305</td>
</tr>
<tr>
<td>14</td>
<td>cki</td>
<td>-12.187</td>
<td>96.834</td>
<td>34897.57944</td>
<td>-1267.207778</td>
<td>-32411.88188</td>
<td>20200305</td>
<td>55</td>
<td>nur</td>
<td>60.508</td>
<td>24.655</td>
<td>14746.53667</td>
<td>2287.914931</td>
<td>50328.62708</td>
<td>20200305</td>
</tr>
<tr>
<td>15</td>
<td>clf</td>
<td>48.025</td>
<td>2.26</td>
<td>21268.24681</td>
<td>374.1634028</td>
<td>43038.32201</td>
<td>20200305</td>
<td>56</td>
<td>nvs</td>
<td>54.85</td>
<td>83.23</td>
<td>15977.18264</td>
<td>2267.85125</td>
<td>57794.77472</td>
<td>20200305</td>
</tr>
<tr>
<td>16</td>
<td>cmo</td>
<td>64.871</td>
<td>212.139</td>
<td>12071.0441</td>
<td>3662.327361</td>
<td>55060.79042</td>
<td>20200305</td>
<td>57</td>
<td>ott</td>
<td>45.403</td>
<td>284.448</td>
<td>18006.06139</td>
<td>-4293.210347</td>
<td>50757.78646</td>
<td>20200305</td>
</tr>
<tr>
<td>17</td>
<td>cnb</td>
<td>-35.314</td>
<td>149.363</td>
<td>23121.84965</td>
<td>5192.365069</td>
<td>-52948.43965</td>
<td>20200305</td>
<td>58</td>
<td>pag</td>
<td>42.515</td>
<td>24.177</td>
<td>23724.57785</td>
<td>2052.341181</td>
<td>41095.60694</td>
<td>20200305</td>
</tr>
<tr>
<td>18</td>
<td>cpl</td>
<td>17.293</td>
<td>78.92</td>
<td>39453.13201</td>
<td>-510.5802778</td>
<td>17435.07875</td>
<td>20200305</td>
<td>59</td>
<td>pet</td>
<td>52.971</td>
<td>158.248</td>
<td>21521.23347</td>
<td>-2453.807986</td>
<td>47410.99722</td>
<td>20200305</td>
</tr>
<tr>
<td>19</td>
<td>csy</td>
<td>-66.28</td>
<td>110.53</td>
<td>-1183.919167</td>
<td>-8905.680139</td>
<td>-63455.59493</td>
<td>20200305</td>
<td>60</td>
<td>pil</td>
<td>-31.667</td>
<td>296.119</td>
<td>18525.13889</td>
<td>-1971.772847</td>
<td>-12926.00313</td>
<td>20200305</td>
</tr>
<tr>
<td>20</td>
<td>cta</td>
<td>-20.09</td>
<td>146.264</td>
<td>31415.04941</td>
<td>4032.899791</td>
<td>-37523.00592</td>
<td>20200305</td>
<td>61</td>
<td>pst</td>
<td>-51.704</td>
<td>302.107</td>
<td>17998.51828</td>
<td>816.7563025</td>
<td>-21589.41492</td>
<td>20200305</td>
</tr>
<tr>
<td>21</td>
<td>dou</td>
<td>50.1</td>
<td>4.599</td>
<td>20166.69694</td>
<td>564.5751389</td>
<td>44377.19028</td>
<td>20200305</td>
<td>62</td>
<td>res</td>
<td>74.69</td>
<td>265.105</td>
<td>2821.225278</td>
<td>-966.5449306</td>
<td>57412.04722</td>
<td>20200305</td>
</tr>
<tr>
<td>22</td>
<td>dur</td>
<td>41.65</td>
<td>14.467</td>
<td>24664.39583</td>
<td>1661.169444</td>
<td>39635.57229</td>
<td>20200305</td>
<td>63</td>
<td>sba</td>
<td>-77.85</td>
<td>166.762</td>
<td>-10322.08271</td>
<td>5515.313542</td>
<td>-65094.66458</td>
<td>20200305</td>
</tr>
<tr>
<td>23</td>
<td>ebr</td>
<td>40.957</td>
<td>0.333</td>
<td>25322.75201</td>
<td>348.5455556</td>
<td>37632.16313</td>
<td>20200305</td>
<td>64</td>
<td>sbl</td>
<td>43.932</td>
<td>299.991</td>
<td>20099.86778</td>
<td>-6159.527222</td>
<td>45830.59819</td>
<td>20200305</td>
</tr>
<tr>
<td>24</td>
<td>frd</td>
<td>38.201</td>
<td>282.63</td>
<td>21211.1253</td>
<td>-3948.038707</td>
<td>45969.93919</td>
<td>20200305</td>
<td>65</td>
<td>sfs</td>
<td>36.667</td>
<td>354.055</td>
<td>27692.98333</td>
<td>-437.525625</td>
<td>33061.71813</td>
<td>20200305</td>
</tr>
<tr>
<td>25</td>
<td>frn</td>
<td>37.091</td>
<td>240.281</td>
<td>22610.76882</td>
<td>5106.934306</td>
<td>41905.74014</td>
<td>20200305</td>
<td>66</td>
<td>she</td>
<td>-15.961</td>
<td>354.253</td>
<td>16010.89917</td>
<td>-3784.684444</td>
<td>-25849.75875</td>
<td>20200305</td>
</tr>
<tr>
<td>26</td>
<td>fur</td>
<td>48.165</td>
<td>11.277</td>
<td>20993.37243</td>
<td>1266.938681</td>
<td>43689.14313</td>
<td>20200305</td>
<td>67</td>
<td>sit</td>
<td>57.058</td>
<td>224.675</td>
<td>15003.98639</td>
<td>5020.095972</td>
<td>52959.09139</td>
<td>20200305</td>
</tr>
<tr>
<td>27</td>
<td>gan</td>
<td>-0.695</td>
<td>73.154</td>
<td>38064.10701</td>
<td>-2720.955278</td>
<td>-12852.37549</td>
<td>20200305</td>
<td>68</td>
<td>sjg</td>
<td>18.111</td>
<td>293.85</td>
<td>26371.23667</td>
<td>-6125.861667</td>
<td>24778.29694</td>
<td>20200305</td>
</tr>
<tr>
<td>28</td>
<td>gck</td>
<td>44.63</td>
<td>20.77</td>
<td>22705.50861</td>
<td>1968.7925</td>
<td>42322.95653</td>
<td>20200305</td>
<td>69</td>
<td>spg</td>
<td>60.542</td>
<td>29.716</td>
<td>14451.77243</td>
<td>2766.171111</td>
<td>50554.4159</td>
<td>20200305</td>
</tr>
<tr>
<td>29</td>
<td>gng</td>
<td>-31.356</td>
<td>115.715</td>
<td>24154.41201</td>
<td>-695.7534028</td>
<td>-52657.5475</td>
<td>20200305</td>
<td>70</td>
<td>spt</td>
<td>39.547</td>
<td>355.651</td>
<td>26157.41243</td>
<td>-212.2654861</td>
<td>35974.31007</td>
<td>20200305</td>
</tr>
<tr>
<td>30</td>
<td>gui</td>
<td>28.321</td>
<td>343.559</td>
<td>27788.94125</td>
<td>-3297.265486</td>
<td>22532.55771</td>
<td>20200305</td>
<td>71</td>
<td>tam</td>
<td>22.792</td>
<td>5.53</td>
<td>33853.35556</td>
<td>317.1153472</td>
<td>17125.37632</td>
<td>20200305</td>
</tr>
<tr>
<td>31</td>
<td>had</td>
<td>50.995</td>
<td>355.516</td>
<td>19815.59375</td>
<td>-487.1833333</td>
<td>44458.94479</td>
<td>20200305</td>
<td>72</td>
<td>tdc</td>
<td>-37.067</td>
<td>347.684</td>
<td>9158.353472</td>
<td>-3520.939514</td>
<td>-22389.23111</td>
<td>20200305</td>
</tr>
<tr>
<td>32</td>
<td>hbk</td>
<td>-25.883</td>
<td>27.707</td>
<td>12484.80071</td>
<td>-4183.221111</td>
<td>-24963.03222</td>
<td>20200305</td>
<td>73</td>
<td>thl</td>
<td>77.47</td>
<td>290.77</td>
<td>3048.201319</td>
<td>-2836.9075</td>
<td>56138.82771</td>
<td>20200305</td>
</tr>
<tr>
<td>33</td>
<td>her</td>
<td>-34.425</td>
<td>19.225</td>
<td>9607.833819</td>
<td>-4713.809861</td>
<td>-22995.42292</td>
<td>20200305</td>
<td>74</td>
<td>thy</td>
<td>46.9</td>
<td>17.893</td>
<td>21518.14722</td>
<td>1798.217431</td>
<td>43480.7241</td>
<td>20200305</td>
</tr>
<tr>
<td>34</td>
<td>hlp</td>
<td>54.603</td>
<td>18.811</td>
<td>17482.39139</td>
<td>1693.542639</td>
<td>47405.90799</td>
<td>20200305</td>
<td>75</td>
<td>tsu</td>
<td>-19.202</td>
<td>17.584</td>
<td>14031.38007</td>
<td>-2157.920833</td>
<td>-25488.01035</td>
<td>20200305</td>
</tr>
<tr>
<td>35</td>
<td>hrb</td>
<td>47.875</td>
<td>18.19</td>
<td>20998.77708</td>
<td>1814.178403</td>
<td>44071.71535</td>
<td>20200305</td>
<td>76</td>
<td>tuc</td>
<td>32.174</td>
<td>249.266</td>
<td>23874.2234</td>
<td>3757.009861</td>
<td>40291.74611</td>
<td>20200305</td>
</tr>
<tr>
<td>36</td>
<td>hyb</td>
<td>17.42</td>
<td>78.55</td>
<td>39586.70764</td>
<td>-409.4116667</td>
<td>18254.32278</td>
<td>20200305</td>
<td>77</td>
<td>ups</td>
<td>59.903</td>
<td>17.353</td>
<td>15093.9141</td>
<td>1687.224931</td>
<td>49301.94847</td>
<td>20200305</td>
</tr>
<tr>
<td>37</td>
<td>iqa</td>
<td>63.756</td>
<td>291.49</td>
<td>8624.755702</td>
<td>-3943.983658</td>
<td>56107.03804</td>
<td>20200305</td>
<td>78</td>
<td>vic</td>
<td>48.517</td>
<td>236.583</td>
<td>18091.75582</td>
<td>5186.817181</td>
<td>49871.91367</td>
<td>20200305</td>
</tr>
<tr>
<td>38</td>
<td>irt</td>
<td>52.17</td>
<td>104.45</td>
<td>18339.39819</td>
<td>-1321.375208</td>
<td>57631.08368</td>
<td>20200305</td>
<td>79</td>
<td>vna</td>
<td>-70.683</td>
<td>351.718</td>
<td>18066.2466</td>
<td>-4484.883403</td>
<td>-33255.14722</td>
<td>20200305</td>
</tr>
<tr>
<td>39</td>
<td>izn</td>
<td>40.5</td>
<td>29.72</td>
<td>25075.98528</td>
<td>2459.532708</td>
<td>40544.37868</td>
<td>20200305</td>
<td>80</td>
<td>vss</td>
<td>-22.4</td>
<td>316.35</td>
<td>16425.94375</td>
<td>-6916.265278</td>
<td>-14993.05438</td>
<td>20200305</td>
</tr>
<tr>
<td>40</td>
<td>jco</td>
<td>70.356</td>
<td>211.201</td>
<td>8698.91</td>
<td>2596.038472</td>
<td>56590.54382</td>
<td>20200305</td>
<td>81</td>
<td>wic</td>
<td>47.928</td>
<td>15.862</td>
<td>21013.83049</td>
<td>1646.833889</td>
<td>43916.92826</td>
<td>20200305</td>
</tr>
<tr>
<td>41</td>
<td>kak</td>
<td>36.232</td>
<td>140.186</td>
<td>29794.62132</td>
<td>-4036.528194</td>
<td>35869.73299</td>
<td>20200305</td>
<td>82</td>
<td>wng</td>
<td>53.725</td>
<td>9.053</td>
<td>18186.19222</td>
<td>1002.707153</td>
<td>46352.84486</td>
<td>20200305</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>The 24 Gaussian coefficients I have calculated are in Table <a href="#t2">2</a></p>
<p><span style='font-weight:bold' id='t2'>Tab 2. </span>Gauss Coefficients my obtained (using quasi-Schmidt normalization)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Coefficent</th>
<th>Degree(n)</th>
<th>Order(m)</th>
<th>Value</th>
<th>Coefficent</th>
<th>Degree(n)</th>
<th>Order(m)</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>1</td>
<td>0</td>
<td>-29017.523</td>
<td>h</td>
<td>3</td>
<td>1</td>
<td>-42.65915408</td>
</tr>
<tr>
<td>g</td>
<td>1</td>
<td>1</td>
<td>-1858.68841</td>
<td>h</td>
<td>3</td>
<td>2</td>
<td>600.217349</td>
</tr>
<tr>
<td>h</td>
<td>1</td>
<td>1</td>
<td>4903.10927</td>
<td>h</td>
<td>3</td>
<td>3</td>
<td>-633.5583365</td>
</tr>
<tr>
<td>g</td>
<td>2</td>
<td>0</td>
<td>-2497.135416</td>
<td>g</td>
<td>4</td>
<td>0</td>
<td>1132.882537</td>
</tr>
<tr>
<td>g</td>
<td>2</td>
<td>1</td>
<td>2617.981296</td>
<td>g</td>
<td>4</td>
<td>1</td>
<td>1296.172272</td>
</tr>
<tr>
<td>g</td>
<td>2</td>
<td>2</td>
<td>2178.890222</td>
<td>g</td>
<td>4</td>
<td>2</td>
<td>-2.933163263</td>
</tr>
<tr>
<td>h</td>
<td>2</td>
<td>1</td>
<td>-3201.763686</td>
<td>g</td>
<td>4</td>
<td>3</td>
<td>-357.3671095</td>
</tr>
<tr>
<td>h</td>
<td>2</td>
<td>2</td>
<td>-923.4214529</td>
<td>g</td>
<td>4</td>
<td>4</td>
<td>120.6542625</td>
</tr>
<tr>
<td>g</td>
<td>3</td>
<td>0</td>
<td>805.1006385</td>
<td>h</td>
<td>4</td>
<td>1</td>
<td>486.9660327</td>
</tr>
<tr>
<td>g</td>
<td>3</td>
<td>1</td>
<td>-2166.619627</td>
<td>h</td>
<td>4</td>
<td>2</td>
<td>-230.1865231</td>
</tr>
<tr>
<td>g</td>
<td>3</td>
<td>2</td>
<td>1281.757376</td>
<td>h</td>
<td>4</td>
<td>3</td>
<td>195.544086</td>
</tr>
<tr>
<td>g</td>
<td>3</td>
<td>3</td>
<td>90.1221627</td>
<td>h</td>
<td>4</td>
<td>4</td>
<td>-207.4272451</td>
</tr>
</tbody>
</table>
</div>
<p>In order to evaluate the fitting effect of the model on the data, the prediction data on the original observation point were obtained by using $\mathbf{E} = \mathbf{A}\mathbf{m}$, and the error between the observation value and the prediction value was calculated, as shown in Figure <a href="#f2">2</a>, <a href="#f3">3</a>:</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222202032398.png" alt="globalmagnetic-est_obs"></p>
<center id='f2'><span style='font-weight:bold'>Fig 2. </span>Maps of observation value and prediction value</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222202141435.png" alt="globalmagnetic-errors"></p>
<center id='f2'><span style='font-weight:bold'>Fig 3. </span>Maps of errors at each observational stations</center>



<h2 id="Global-model-from-inverse-Gauss-Coefficient"><a href="#Global-model-from-inverse-Gauss-Coefficient" class="headerlink" title="Global model from inverse Gauss Coefficient"></a>Global model from inverse Gauss Coefficient</h2><p>The inverse Gauss coefficient can be used to calculate the global magnetic field distribution, which has been shown in Figure <a href="#f4">4-11</a></p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/f1.jpg" alt="globalmagnetic-F-c"></p>
<center id='f4'><span style='font-weight:bold'>Fig 4. </span>Contour-maps of the total field intensity F</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222203133757.png" alt="globalmagnetic-Br-c"></p>
<center id='f5'><span style='font-weight:bold'>Fig 5. </span>Contour-maps of the radial component Br</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/f2.jpg" alt="globalmagnetic-D-c"></p>
<center id='f6'><span style='font-weight:bold'>Fig 6. </span>Contour-maps of the Declination D</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/f3.jpg" alt="globalmagnetic-I-c"></p>
<center id='f7'><span style='font-weight:bold'>Fig 7. </span>Contour-maps of the Inclination I</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222213119400.png" alt="globalmagnetic-F-p"></p>
<center id='f8'><span style='font-weight:bold'>Fig 8. </span>Contourf-maps of the total field intensity F</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222213219045.png" alt="globalmagnetic-f9"></p>
<center id='f9'><span style='font-weight:bold'>Fig 9. </span>Contourf-maps of the radial component Br</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222214858632.png" alt="globalmagnetic-D-p"></p>
<center id='f10'><span style='font-weight:bold'>Fig 10. </span>Contourf-maps of the Declination D</center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222214949535.png" alt="globalmagnetic-I-p"></p>
<center id='f11'><span style='font-weight:bold'>Fig 11. </span>Contourf-maps of the Inclination I</center>

<p>It is obvious that the South Atlantic magnetic anomaly is consistent with the known characteristics of the geomagnetic field, indicating that our model can reflect the characteristics of the geomagnetic field to a certain extent.</p>
<h2 id="Comparison-with-IGRF-13"><a href="#Comparison-with-IGRF-13" class="headerlink" title="Comparison with IGRF-13"></a>Comparison with IGRF-13</h2><p>Compute the spectrum in SH degree by:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        S(n)=(n+1) \sum_{m=0}^{n}\left(g_{n}^{m}\right)^{2}+\left(h_{n}^{m}\right)^{2}
    \end{aligned}
\end{equation}</script><p>and compare them with the results of IGRF-13 (Figure <a href="#f12">12</a>) shown that the inversed Gauss coefficients are in good agreement with IGRF-13 model. The characteristics of the main earth’s magnetic field are almost the same, except for a small deviation when the degree is high.</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222215838033.png" alt="globalmagnetic-spectrum"></p>
<center id='f12'><span style='font-weight:bold'>Fig 12. </span>A plot comparing the spectra of my model with that of IGRF-13</center>



<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>Through the inversion of the observed data, I got 24 Gauss coefficients, and used them to establish the global magnetic field model, draw the magnetic field distribution on the surface of earth. Compared with the IGRF-13 model, it has good consistency, but there are still subtle differences. The reason is that when we sift through the data, the distribution of observation stations is not  well-distributed enough, and we can not achieve uniform distribution on a global scale. Therefore, the inversed model is greatly affected by the local data, even if we increase the degree of the  spherical harmonic coefficient will not help, there will be even greater difference. If our model is to be more accurate, it will need to include satellite data that can orbit the Earth around, which will also take into account the effects of external fields on the geomagnetic field, making the model more accurate.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>The code can be attained at <a href="https://github.com/tabris-trees/GMFM">my github repository</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]  聂琳娟, 许智铭. 利用SWARM星群磁测数据反演地球主磁场模型WHU-MM01[J]. 测绘地理信息, 2020, 45(05): 16–19.</p>
<p>[2]  徐文耀, 区加明, 杜爱民. 地磁场全球建模和局域建模[J]. 地球物理学进展, 地球物理学进展, 2011, 26(2): 398–415.</p>
<p>[3]  Monika Korte, Catherine Constable. Continuous global geomagnetic field models for the past 3000 years[J]. Physics of the Earth and Planetary Interiors, 2003, 140(1): 73–89.</p>
<p>[4]  N. W. Peddie. USGS model coefficients for continental U.S. and Hawaii (1985)[J]. Planetary and Space Science, 1992, 40(4): 561.</p>
<p>[5]  An Homage to Gauss and His Model of the Earth’s Magnetic Field[J]. CMS Notes, .</p>
<p>[6]  Davis J. Mathematical Modeling of Earth’s Magnetic Field[J]. .</p>
<p>[7]  白春华, 徐文耀, 康国发. 地球主磁场模型[J]. 地球物理学进展, 2008(4): 1045–1057.</p>
<p>[8]  冯春. Matlab实现IGRF国际地磁参考场模型的计算[J]. 内蒙古石油化工, 2014, 40(12): 43–46.</p>
<p>[9]  安振昌. 地磁场区域模型与全球模型的比较和讨论[J]. 物探与化探, 1991(04): 248–254.</p>
<p>[10] 刘元元, 王仕成, 张金生, 等. 最新国际地磁参考场模型IGRF11研究[J]. 地震学报, 2013, 35(1): 125-131+133-134+138.</p>
<p>[11] International Geomagnetic Reference Field (IGRF-13)[EB/OL]. /2022-05-28. <a href="https://wdc.kugi.kyoto-u.ac.jp/igrf/index.html">https://wdc.kugi.kyoto-u.ac.jp/igrf/index.html</a>.</p>
<p>[12] Alken P, Thébault E, Beggan C D, 等. International Geomagnetic Reference Field: the thirteenth generation[J]. Earth, Planets and Space, 2021, 73(1): 49.</p>
<p>[13]  Finlay C C, Kloss C, Olsen N, 等. The CHAOS-7 geomagnetic field model and observed changes in the South Atlantic Anomaly[J]. Earth, Planets and Space, 2020, 72(1): 156.</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>地球磁场</category>
      </categories>
      <tags>
        <tag>地球磁场</tag>
        <tag>反演</tag>
        <tag>南大西洋磁异常</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性动力学-概论</title>
    <url>/2022/04/30/nonlineardynamics1/</url>
    <content><![CDATA[<div class="note primary flat"><p><strong>动力学</strong>——一门研究系统随时间演化的学科，它告诉我们所考虑的系统是稳定到平衡点，做重复的周期运动还是做更复杂的随机运动。<span class='heimu'>世界的规律是简单的，但世界却是复杂的。越是深入的了解我们身处的这个世界，我们就越深刻的认识到世界的复杂性，并且这些出乎意料的复杂性往往来源于我们所熟知的某些简单的规律。也许，有时候从简单到复杂之间的规律才是对我们来说至关重要的东西。</span></p>
</div>
<h1 id="动力学简史"><a href="#动力学简史" class="headerlink" title="动力学简史"></a>动力学简史</h1><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>科学家</th>
<th>贡献</th>
</tr>
</thead>
<tbody>
<tr>
<td>1666年</td>
<td>牛顿</td>
<td>发明微积分, 解释行星运动(微分方程的起源)</td>
</tr>
<tr>
<td>18世纪初</td>
<td></td>
<td>微积分与经典力学的繁荣</td>
</tr>
<tr>
<td>19世纪初</td>
<td></td>
<td>行星运动的分析研究(三体问题)</td>
</tr>
<tr>
<td>19世纪90年代</td>
<td>庞加莱</td>
<td>几何方法, 混沌存在的可能</td>
</tr>
<tr>
<td>1920-1960年</td>
<td>Birkhoff</td>
<td>Hamiltonian 力学复杂行为</td>
</tr>
<tr>
<td>Kolmogorov</td>
</tr>
<tr>
<td>Arnol’d</td>
</tr>
<tr>
<td>Moser</td>
</tr>
<tr>
<td>1963年</td>
<td>洛伦兹</td>
<td>简单对流模型的奇怪吸引子</td>
</tr>
<tr>
<td>20世纪70年代</td>
<td>Ruelle、Takens</td>
<td>湍流与混沌</td>
</tr>
<tr>
<td>May</td>
<td>Logistic 映射中的混沌</td>
</tr>
<tr>
<td>Feigenbaum</td>
<td>一般性与重整化、混沌与相变的联系，混沌的实验研究</td>
</tr>
<tr>
<td>Winfree</td>
<td>生物学中的非线性振子</td>
</tr>
<tr>
<td>Mandelbrot</td>
<td>分形</td>
</tr>
<tr>
<td>20世纪80年代</td>
<td></td>
<td>混沌、分形、振子及其应用的广泛研究</td>
</tr>
</tbody>
</table>
</div>
<h1 id="非线性的重要性"><a href="#非线性的重要性" class="headerlink" title="非线性的重要性"></a>非线性的重要性</h1><p>我们将动力学系统分为主要的两类：</p>
<ul>
<li>微分方程</li>
<li>迭代映射(差分方程)</li>
</ul>
<p>微分方程描述了系统在连续时间中的演化，而迭代映射则是离散时间的过程，两者在本质上都是描述系统如何随着时间变化。无论如何，现在我们将视角放到微分方程之上，<span class='heimu'>毕竟我们的世界本身还是一个连续的世界</span>。</p>
<p>现在考虑受迫简谐振子的方程：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        m \frac{\mathrm{d}^2 x}{\mathrm{d} t^2}+b \frac{\mathrm{d} x}{\mathrm{d} t}+kx=0
    \end{aligned}
\end{equation}</script><p>很明显，这是一个常微分方程，它只有一个自变量——时间 $t$。对于这样一个系统，我们有更一般的形式：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}\begin{array}{c}
        \dot{x_1} = f_1(x_1,x_2,\cdots,x_n) \\
        \vdots \\
        \dot{x_n} = f_n(x_1,x_2,\cdots,x_n)
    \end{array}
    \end{aligned}
\end{equation}</script><p>即将 $x_1$ 取为 $x$，$x_2$ 取为 $\mathrm{d} x/\mathrm{d} t$:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\dot{x_1} = x_2 \\
        &\dot{x_2} = -\frac{b}{m} x_2-\frac{k}{m} x_1
    \end{aligned}
\end{equation}</script><p>由于右端所有的 $x_i$ 都是一次项，我们称这个系统是线性的。与线性系统对立的是非线性系统，它表示那些右边的 $x_i$ 存在非一次项的情况，例如 $x_1 x_2,\ x_1^3,\ \cos{x_2} $ 之类的。对于钟摆运动的方程：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \ddot{x}+\frac{g}{L} \sin x=0
    \end{aligned}
\end{equation}</script><p>我们可以将其改写成：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\dot{x}_{1}=x_{2} \\
        &\dot{x}_{2}=-\frac{g}{L} \sin x_{1}
    \end{aligned}
\end{equation}</script><p>右边出现了 $\sin x_1$ 项，所以这是一个非线性系统。对于这样的方程我们很难利用解析解求解，通常采用小角度逼近的做法近似求解，对于 $x \ll 1$，有 $\sin x \approx x$。如此一来问题就简化成了容易求解的线性问题。但是这种情况我们的物理被舍弃太多，对于大的 $x$（钟摆转到顶端的情况）我们就没办法这么去研究。</p>
<p>但实际上，钟摆的运动在我们看来是如此的简单，应该会有更简单的方法来解析求解这个问题。因此我们引入一种几何方法来解决这个问题，大概的意思就是：以方程一般形式中的两个自变量 $x_1$ 和 $x_2$ 为坐标轴构建出抽象空间，当确定一个初始位置（初始解）之后，我们所寻求的方程的解应该是在这个空间中沿曲线移动的点。</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222194407158.png" alt="nonlineardynamics1-1.2.1"></p>
<p>如同图1.2.1所示，我们将曲线称为<span style='background: yellow'><strong>轨迹</strong></span>，空间称为<span style='background: yellow'><strong>相空间</strong></span>，由于每一个点都有可能是初始条件，因此系统的轨迹应该是完全填满相空间的。</p>
<p>我们要做的事情是将上述过程反过来考虑，给定一个系统，我们画出轨迹，并从中提取出关于解的信息。很多情况下，几何推理有助于我们画出轨迹而无须对系统求解。</p>
<p>另外，我们把写成一般形式之后具有n个自变量的系统称为<strong>n-维系统</strong>或者<strong>n-阶系统</strong>，n代表了相空间的维数。</p>
<h2 id="非自洽系统"><a href="#非自洽系统" class="headerlink" title="非自洽系统"></a>非自洽系统</h2><p>所谓非自洽系统指的是在描述系统的方程中出现了对时间的依赖（函数中显含时间），例如受迫简谐振子方程 $m \ddot{x}+b\dot{x}+kx = F\cos{t}$ 如同之前一样，令 $x_1 = x$ 与 $x_2 = \dot{x}$ 以及 $x_3 = t$。那么原来的方程可以写成是：</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\dot{x}_{1}=x_{2} \\
        &\dot{x}_{2}=\frac{1}{m}\left(-k x_{1}-b x_{2}+F \cos x_{3}\right) \\
        &\dot{x}_{3}=1
    \end{aligned}
\end{equation}</script><p>这样做相当于是将原本在二维相空间中运动的简谐振子转换到三维相空间中，如果不考虑时间的维度，我们画出来的相空间轨迹将会呈现出一直晃动的特征，不利于我们从中提取信息，所以我们通过对系统增加额外的维数来消除了其对时间的依赖性。在物理上，受迫简谐振子运动的<strong>状态</strong>实际上也是三维的，给定当前的状态，我们只需要知道三个量，$x$、$\dot{x}$ 以及 $t$ 就可以预测中未来时刻的状态，因此以上的做法对于我们利用几何方法研究系统是很自然的。</p>
<h2 id="为什么非线性系统这么困难"><a href="#为什么非线性系统这么困难" class="headerlink" title="为什么非线性系统这么困难"></a>为什么非线性系统这么困难</h2><p>在数学上，我们研究复杂问题（函数）时通常采用将其分解成一系列线性问题（函数）的叠加去近似原问题的方法，诸如我们所熟知的泰勒展开、傅里叶变换等都是这种思想的体现。各部分线性问题的求解通常是简单的，再将这些解重新整合成复杂问题的解，这样操作后，线性系统等于其各部分的精确和。</p>
<p>但在自然界中的事物存在各部分之间的相互影响、合作或者竞争，出现很多非线性作用。<span class='heimu'>在数学上，我们通常会要求展开的基函数是正交的，这样保证了展开后的各部分相互之间不存在影响，但自然界中的事物并不都是数学的理想造物，日常生活中的全部几乎都是非线性的，于是叠加原理出人意料的失效了。</span>想象你同时听到两首非常喜欢的歌，但是你的快乐却不会因此翻倍。我们可以放心大胆地说：“我们的世界是非线性的！”，也许这正是人类无法完全掌握我们所身处世界的原因所在。</p>
<h1 id="世界的动力学视角"><a href="#世界的动力学视角" class="headerlink" title="世界的动力学视角"></a>世界的动力学视角</h1><p>在旧世界的地图上，某些区域被标识着“此处有龙”以表示这些区域在地球上还尚未被探索。在现代科学中，非线性科学就是这样的一块区域，这些主题还有很多区域未被涉足，他们处于研究的极限地带，通常是那些我们现实生活中所需要面对的各种复杂现象，它将成为我们未来很重要的一个挑战。</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222194209807.png" alt="nonlineardynamics1-1.3.1"></p>
<p>我们可以所在的这个世界上的现象按照系统的维度和线性与否作如上图所示的划分，如同旧时代的新大陆探索者，我们要做的事情就是去那些还未被开垦过的土地深耕，寻找那些可能存在的规律，解开世界最深的谜底……</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>非线性物理学</category>
      </categories>
      <tags>
        <tag>非线性动力学</tag>
        <tag>Nonlinear</tag>
        <tag>混沌</tag>
        <tag>复杂性</tag>
      </tags>
  </entry>
  <entry>
    <title>理想磁流体力学与霍尔磁流体力学下平行传播电磁波的色散关系推导</title>
    <url>/2022/04/15/plasmahomework3/</url>
    <content><![CDATA[<h1 id="1-Derive-the-dispersion-relation-for-low-frequency-plasma-waves-at-parallel-propagation-in-ideal-MHD"><a href="#1-Derive-the-dispersion-relation-for-low-frequency-plasma-waves-at-parallel-propagation-in-ideal-MHD" class="headerlink" title="1.Derive the dispersion relation for low frequency plasma waves at parallel propagation in ideal MHD."></a>1.Derive the dispersion relation for low frequency plasma waves at parallel propagation in ideal MHD.</h1><p>We assume $\mathbf{k} = k_\parallel \hat{z}$, and $\mathbf{B}_0 = B_0 \hat{z}$. Give the  linearization of ideal MHD that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \omega \rho_1 &= \rho_0(\mathbf{k} \cdot \mathbf{u_1}), \\
        \omega \rho_0 \mathbf{u_1} &= i \mathbf{J}_1 \times \mathbf{B_0} + p_1 \mathbf{k}, \\
        \mu_0 \omega \mathbf{J_1} &= -i \mathbf{k} \times [\mathbf{k} \times (\mathbf{u_1} \times \mathbf{B_0})], \\
        \omega \mathbf{B_1} &= - \mathbf{k} \times (\mathbf{u_1} \times \mathbf{B_0}), \\
        \omega p_1 &= \gamma p_0 (\mathbf{k} \cdot \mathbf{u_1}).
    \end{aligned}
\end{equation}</script><p>that we have:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{u_1} \times \mathbf{B_0} &= u_{1y} B_0 \hat{x} - u_{1x} B_0 \hat{y}, \\
        \mathbf{k} \times (\mathbf{u}_{1} \times \mathbf{B}_{0})&= k_{\parallel} u_{1 x} B_{0} \hat{x}+k_{\|} u_{1 y} B_{0} \hat{y}, \\
        \mathbf{k} \times [\mathbf{k} \times (\mathbf{u_1} \times \mathbf{B_0})] &= k_{\parallel}^2 u_{1x} B_0 \hat{y} - k_{\parallel}^2 u_{1y} B_0 \hat{x}.
    \end{aligned}
\end{equation}</script><p>then we can obtain that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{J_1} &= \frac{-i}{\mu_0 \omega} \mathbf{k} \times [\mathbf{k} \times (\mathbf{u_1} \times \mathbf{B_0})] \\
        &= \frac{-i}{\mu_0 \omega} (k_{\parallel}^2 u_{1x} B_0 \hat{y} - k_{\parallel}^2 u_{1y} B_0 \hat{x}) \\
        \Rightarrow i \mathbf{J_1} \times \mathbf{B_0} &= \frac{1}{\mu_0 \omega} ((k_{\parallel}^2 u_{1x} B_0^2 \hat{y} - k_{\parallel}^2 u_{1y} B_0^2 \hat{x}))
    \end{aligned}
\end{equation}</script><p>and:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        p_1 &= \frac{\gamma p_0 ( \mathbf{k} \cdot \mathbf{u_1})}{\omega} \\
        &= \frac{\gamma p_0 k_{\parallel} u_{1z}}{\omega}
    \end{aligned}
\end{equation}</script><p>combine the formula (3) and (4), we can get:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \omega \rho_0 \mathbf{u_1} &= i \mathbf{J}_1 \times \mathbf{B_0} + p_1 \mathbf{k} \\
        &= \frac{-k_{\parallel}^2 u_{1y} B_0^2}{\mu_0 \omega} \hat{x} + \frac{k_{\parallel}^2 u_{1x} B_0^2}{\mu_0 \omega} \hat{y} + \frac{k_{\parallel}^2 \gamma p_0 u_{1z}}{\omega} \hat{z} \\
    \end{aligned}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \Rightarrow &\left\{\begin{array}{cc}
            \omega \rho_0 u_{1x} &= \frac{-k_{\parallel}^2 u_{1y} B_0^2}{\mu_0 \omega} \\
            \omega \rho_0 u_{1y} &= \frac{k_{\parallel}^2 u_{1x} B_0^2}{\mu_0 \omega} \\
            \omega \rho_0 u_{1z} &= \frac{k_{\parallel}^2 \gamma p_0 u_{1z}}{\omega}
        \end{array}\right.
    \end{aligned}
\end{equation}</script><p>we can get tow solutions, one is from the z component that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \omega \rho_0 u_{1z} &= \frac{\gamma k_{\parallel}^2 p_0 u_{1z}}{\omega} \\
        \Rightarrow \frac{\omega}{k_{\parallel}} &= \sqrt{\frac{\gamma p_0}{\rho_0}} = C_s
    \end{aligned}
\end{equation}</script><p>and another one is:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \omega \rho_0 u_{1x} &= \frac{-k_{\parallel}^2 u_{1y} B_0^2}{\mu_0 \omega} \\
        \Rightarrow u_{1x} &= \frac{-k_{\parallel}^2 u_{1y} B_0^2}{\mu_0 \omega^2 \rho_0} \\
        \Rightarrow \omega \rho_0 u_{1y} &= \frac{k_{\parallel}^2 u_{1x} B_0^2}{\mu_0 \omega} \\
        &= \frac{-k_{\parallel}^4 u_{1y} B_0^4}{u_0^2 \omega^3 \rho_0} \\
        \Rightarrow \frac{\omega}{k_{\parallel}} &= \sqrt{\frac{B_0^2}{\mu_0 \rho_0}} = V_{A}
    \end{aligned}
\end{equation}</script><h1 id="2-Redo-the-above-analysis-by-keeping-the-Hall-term-in-the-generalized-Ohm’s-law"><a href="#2-Redo-the-above-analysis-by-keeping-the-Hall-term-in-the-generalized-Ohm’s-law" class="headerlink" title="2.Redo the above analysis by keeping the Hall term in the generalized Ohm’s law."></a>2.Redo the above analysis by keeping the Hall term in the generalized Ohm’s law.</h1><p>Like the procedure of Ideal-MHD, from the Maxwell equations we can obtain that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{k} \times (\mathbf{k} \times \mathbf{E_1}) = -i \omega \mu_0 \mathbf{J_1}
    \end{aligned}
\end{equation}</script><p>and Generalized Ohm’s law:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{E_1} = \frac{1}{n_0 e} \mathbf{J_1} \times \mathbf{B_0}-\mathbf{u_1} \times \mathbf{B_0}
    \end{aligned}
\end{equation}</script><p>so that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{k} \times (\mathbf{k} \times (\frac{1}{n_0 e} \mathbf{J_1} \times \mathbf{B_0}-\mathbf{u_1} \times \mathbf{B_0})) = -i \omega \mu_0 \mathbf{J_1}
    \end{aligned}
\end{equation}</script><p>with:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\mathbf{k} = k_{\parallel} \hat{z} \\
        &\mathbf{B_0} = B_0 \hat{z} \\
        &\mathbf{u_1} = u_{1x} \hat{x} + u_{1y} \hat{y} + u_{1z} \hat{z} \\
    \end{aligned}
\end{equation}</script><p>to get the $\mathbf{J_1}$:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \mathbf{J_1} &= -\frac{e n_0 (B_0^2 k_{\parallel}^4 u_{1 x}-i B_0 e k_{\parallel}^2 \mu_0 n_0 \omega u_{1 y})}{- B_0^2 k_{\parallel}^4 + e^2 \mu_0^2 n_0^2 \omega^2} \hat{x} \\
        &+\frac{B_0 k_{\parallel}^2 (i e^2 \mu_0 n_0^2 \omega u_{1x} + B_0 e k_{\parallel}^2 n_0 u_{1y})}{B_0^2 k_{\parallel}^4 - e^2 \mu_0^2 n_0^2 \omega^2} \hat{y}
    \end{aligned}
\end{equation}</script><p>put it into the momentum equation that: $\omega \rho_0 \mathbf{u_1} = i \mathbf{J}_1 \times \mathbf{B_0} + p_1 \mathbf{k}$, we have:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
    \left \{ \begin{array}{cl}
        -i \omega \rho_0 u_{1x} &= \frac{B_0^2 k_{\parallel}^2 (i e^2 \mu_0 n_0^2 \omega u_{1x} + B_0 e k_{\parallel}^2 n_0 u_{1y})}{B_0^2 k_{\parallel}^4 - e^2 \mu_0^2 n_0^2 \omega^2} \\
        -i \omega \rho_0 u_{1y} &= \frac{B_0^2 e k_{\parallel}^2 n_0 (-B_0 k_{\parallel}^2 u_{1x} + i e \mu_0 n_0 \omega u_{1y})}{B_0^2 k_{\parallel}^4 - e^2 \mu_0^2 n_0^2 \omega^2} \\
        -i \omega \rho_0 u_{1z} &= - \frac{i k_{\parallel}^2 p_0 u_{1z} \gamma}{\omega}
    \end{array} \right. 
    \end{aligned}
\end{equation}</script><p>with the $\rho_0 = n_0 (m_i+m_e) \approx n_0 m_i$ and $p_0 = n_0 k_B T$, the z component demonstrate that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \omega^2 = k_{\parallel} \frac{\gamma k_B T}{m_i}
    \end{aligned}
\end{equation}</script><p>rewrite the x, y component into the form of below:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}\left \{\begin{array}{cl}
        u_{1x} -\frac{i B_0^3 e k_{\parallel}^4 n_0}{\omega (-B_0^2 e^2 k_{\parallel}^2 \mu_0 n_0^2 - B_0^2 k_{\parallel}^4 \rho_0 + e^2 \mu_0^2 n_0^2 \omega^2 \rho_0)} u_{1y} &= 0\\
        \frac{i B_0^3 e k_{\parallel}^4 n_0}{\omega (-B_0^2 e^2 k_{\parallel}^2 \mu_0 n_0^2 - B_0^2 k_{\parallel}^4 \rho_0 + e^2 \mu_0^2 n_0^2 \omega^2 \rho_0)} u_{1x} - u_{1y} &= 0
    \end{array}\right.\end{aligned}
\end{equation}</script><p>to have a solution, the coefficient determinant must be zero, it means that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        &\frac{B_0^6 e^2 k_{\parallel}^8 n_0^2}{(-B_0^2 k_{\parallel}^2 (k{\parallel}^2 m_i n_0 + e^2 n_0^2 \mu_0) \omega + e^2 m_i n_0^3 \mu_0^2 \omega^3)^2} = 1 \\
        \Rightarrow &\pm B_0^3 e k_{\parallel}^4 n_0 - B_0^2 k_{\parallel}^2 (k{\parallel}^2 m_i n_0 + e^2 n_0^2 \mu_0) \omega + e^2 m_i n_0^3 \mu_0^2 \omega^3 = 0 \\
        \Rightarrow &\frac{m_i^2 e^2 m_i n_0^3 \mu_0^2 \omega^3}{e^5 B_0^3 \mu_0^2 n_0^3} - \frac{m_i^2 B_0^2 k_{\parallel}^2 \omega}{e^5 B_0^3 \mu_0^2 n_0^3} (k{\parallel}^2 m_i n_0 + e^2 n_0^2 \mu_0) \pm \frac{m_i^2 B_0^3 e k_{\parallel}^4 n_0}{e^5 B_0^3 \mu_0^2 n_0^3} = 0 \\
        \Rightarrow &\frac{m_i^3 \omega^3}{e^3 B_0^3} - \frac{m_i^2 k_{\parallel}^2 \omega}{e^5 B_0 \mu_0^2 n_0^3} (k{\parallel}^2 m_i n_0 + e^2 n_0^2 \mu_0) \pm \frac{m_i^2 k_{\parallel}^4}{e^4 \mu_0^2 n_0^2} = 0
    \end{aligned}
\end{equation}</script><p>with the $\Omega_i = \frac{e B_0}{m_i}$, $\lambda_i = \sqrt{\frac{m_i}{\mu_0 n_0 e^2}}$, we can derive that:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        (\frac{\omega}{\Omega_i})^3 - k_{\parallel}^2 \lambda_i^2 (1 + k_{\parallel}^2 \lambda_i^2)(\frac{\omega}{\Omega_i}) \pm k_{\parallel}^4 \lambda_i^4 = 0
    \end{aligned}
\end{equation}</script><p>it can be reduced to a simpler form by consider the factorization of the trem that can’t be zero.</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        k^2\lambda^2 \frac{\omega}{\Omega}-k^2 \lambda^2 + \frac{\omega^2}{\Omega^2} = 0
    \end{aligned}
\end{equation}</script><h1 id="3-Solve-the-dispersion-relation-s-obtained-in-Problem-2-numerically-Plot-the-dispersion-relations-and-discuss-the-difference-between-the-ideal-and-Hall-MHD-dispersion-relations"><a href="#3-Solve-the-dispersion-relation-s-obtained-in-Problem-2-numerically-Plot-the-dispersion-relations-and-discuss-the-difference-between-the-ideal-and-Hall-MHD-dispersion-relations" class="headerlink" title="3.Solve the dispersion relation s obtained in Problem 2 numerically. Plot the dispersion relations and discuss the difference between the ideal and Hall MHD dispersion relations."></a>3.Solve the dispersion relation s obtained in Problem 2 numerically. Plot the dispersion relations and discuss the difference between the ideal and Hall MHD dispersion relations.</h1><p>the figure of the dispersion is:</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222193827442.png" alt="plasmahomework3-dispersion"></p>
<p><span style='background: yellow'>the difference between the ideal MHD and Hall MHD dispersion relations is the x, y component contribute a Fast Magnetic wave which is coincident with the Alfven wave at the low frequency but the Ideal MHD has only the Alfven wave term.</span> It has three positive solution roots for the dispersion equations that we can draw three curve to illustrate it. Besides this, we can also find a resonant phenomenon when the $\mathbf{k}$ is sufficient large. <span style='background: pink'>The Red dotted line</span> is the false root because of the general division operation in solving process.</p>
<p>the code to plot the dispersion has been presented below:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line">n0=<span class="number">1</span>*<span class="number">10</span>^<span class="number">8</span>;</span><br><span class="line">mi=<span class="number">1.67</span>*<span class="number">10</span>^(<span class="number">-27</span>);</span><br><span class="line">e = <span class="number">1.6</span>*<span class="number">10</span>^(<span class="number">-16</span>); B = <span class="number">5</span>*<span class="number">10</span>^<span class="number">4</span>*<span class="number">10</span>^<span class="number">-9</span>; Epsilon0 = <span class="number">8.85</span>*<span class="number">10</span>^(<span class="number">-12</span>); c = <span class="number">3</span>*<span class="number">10</span>^<span class="number">8</span>;mu0=<span class="number">4</span>*<span class="built_in">pi</span>*<span class="number">10</span>^(<span class="number">-7</span>);</span><br><span class="line"><span class="built_in">gamma</span> = <span class="number">1</span>;kBT = <span class="number">1</span>*e;</span><br><span class="line"><span class="comment">% wpei2 = (ni*e^2)./(Epsilon0*mi);</span></span><br><span class="line">Omegai = (e*B)/mi;</span><br><span class="line">lambdai = <span class="built_in">sqrt</span>(mi/(e^<span class="number">2</span>*mu0*n0));</span><br><span class="line"><span class="comment">% kk=0:1e-2:100;</span></span><br><span class="line">kk = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">100</span>,<span class="number">10000</span>);</span><br><span class="line">w=[];</span><br><span class="line">w2=[];</span><br><span class="line">w3=[];</span><br><span class="line">line=[];</span><br><span class="line"><span class="keyword">for</span> k=kk</span><br><span class="line">    p=[<span class="number">1</span>/Omegai^<span class="number">3</span>,<span class="number">0</span>,-(k^<span class="number">2</span>*lambdai^<span class="number">2</span>*(<span class="number">1</span>+k^<span class="number">2</span>*lambdai^<span class="number">2</span>))/Omegai,k^<span class="number">4</span>*lambdai^<span class="number">4</span>];</span><br><span class="line">    p2=[<span class="number">1</span>/Omegai^<span class="number">3</span>,<span class="number">0</span>,-(k^<span class="number">2</span>*lambdai^<span class="number">2</span>*(<span class="number">1</span>+k^<span class="number">2</span>*lambdai^<span class="number">2</span>))/Omegai,-k^<span class="number">4</span>*lambdai^<span class="number">4</span>];</span><br><span class="line">    p3=[<span class="number">1</span>,<span class="number">0</span>,-k^<span class="number">2</span>*(<span class="built_in">gamma</span>*kBT)/mi];</span><br><span class="line">    omg=roots(p); w=[w,omg];</span><br><span class="line">    omg2=roots(p2); w2=[w2,omg2];</span><br><span class="line">    omg3=roots(p3); w3=[w3,omg3];</span><br><span class="line">    line=[line,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">w11=w(<span class="number">1</span>,:)./Omegai;</span><br><span class="line">w12=w(<span class="number">2</span>,:)./Omegai;</span><br><span class="line">w13=w(<span class="number">3</span>,:)./Omegai;</span><br><span class="line">w21=w2(<span class="number">1</span>,:)./Omegai;</span><br><span class="line">w22=w2(<span class="number">2</span>,:)./Omegai;</span><br><span class="line">w23=w2(<span class="number">3</span>,:)./Omegai;</span><br><span class="line">w31=w3(<span class="number">1</span>,:)./Omegai;</span><br><span class="line">w32=w3(<span class="number">2</span>,:)./Omegai;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">clf;</span><br><span class="line"><span class="comment">% set(gca,&#x27;LineWidth&#x27;,2);</span></span><br><span class="line"><span class="comment">% w11, w22, w23, w32 为负根，舍弃</span></span><br><span class="line">loglog(kk,w12,kk,w13,kk,w21,kk,w31,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="comment">% legend(&#x27;11&#x27;,&#x27;12&#x27;,&#x27;13&#x27;,&#x27;21&#x27;,&#x27;22&#x27;,&#x27;23&#x27;,&#x27;31&#x27;,&#x27;32&#x27;);</span></span><br><span class="line">p1=loglog(kk,line,<span class="string">&#x27;k--&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">legend</span>(p1,<span class="string">&#x27;\Omega_i&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;\omega/\Omega_&#123;i&#125;&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Dispersion Relationship&#x27;</span>);</span><br><span class="line"></span><br><span class="line">saveas(gca, <span class="string">&#x27;3.png&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>等离子体物理</category>
      </categories>
      <tags>
        <tag>等离子体</tag>
        <tag>空间物理</tag>
        <tag>色散关系</tag>
        <tag>Alfven wave</tag>
        <tag>等离子体波动</tag>
      </tags>
  </entry>
  <entry>
    <title>Alfven 波 Kappa 离子非共振加热各向异性研究</title>
    <url>/2022/03/18/wpinteraction/</url>
    <content><![CDATA[<div class="note primary flat"><p>本文基于<a href="https://iopscience.iop.org/article/10.3847/0004-637X/829/1/36">Hai-Feng Liu et al 2016 ApJ 829 36</a>的研究工作总结而成，算是对该文章的阅读笔记</p>
</div>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>很早以前人们就意识到波粒相互作用在日冕加热以及太阳风加速过程中的重要性，大量的研究从九十年代开始到现在一直没有停止过. 此外，</p>
<ol>
<li>1987年, McChesney等人展示了在低频阿尔芬波与粒子相互作用时, 离子位移和垂直方向的波长相当时会发生离子加热;</li>
<li>2001年, Chen等人证明离子在大振幅(<span style='background: yellow;'>sufficiently large amplitude</span>)阿尔芬波作用下可以在分数倍回旋频率下被加热(<span style='background: yellow;'>stochastic heating</span>) <span class='heimu'>离子的轨迹在这个时候会因为电磁场的大幅涨落而变得随机</span> ;</li>
<li><span style='background: pink;'>2010年时, Chandran等人预测随机加热不会太有效, 因为阿尔芬波的涨落在质子参考系中远离太阳, 这和数据观测(K13)的结果是一致的;</span></li>
<li>两千年左右, 原位观测发现存在两种不同的温度各向异性：<ol>
<li>一种在同种离子中存在($T_{i \perp} \gg T_{i \parallel}$), 同时重离子会比质子快大约一个局地阿尔芬速度( $V_i \leqslant V_p + v_A$ );</li>
<li>还有一种不同离子之间的温度各向异性, 暗示了一种在 0.3-1 au 之间的波的活动性和的离子体积特性之间的关系.</li>
</ol>
</li>
<li>最近的观测发现地球附近的氦离子是质子温度的七倍. 什么导致了这样的温度各向异性依旧是一个开放的问题. </li>
</ol>
<p>$\kappa$ 分布在描述非热平衡的空间和天体物理等离子体过程时是非常有效的, 在该分布的表达式中我们可以通过将 $\kappa \rightarrow \infty$ 得到麦克斯韦分布的形式:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        f_{\kappa}(v)=& \frac{N}{\left[(\kappa-3 / 2) \pi \theta^{2}\right]^{3 / 2}} \frac{\Gamma(\kappa+1)}{\Gamma(\kappa-1 / 2)} \\
        & \times\left(1+\frac{v^{2}}{(\kappa-3 / 2) \theta^{2}}\right)^{-(\kappa+1)}
    \end{aligned}
\end{equation}</script><p>其中, $\theta$ 表示最可能的粒子速度( <span style='background: yellow;'>the most probable particle speed</span> ) <span class='heimu'>貌似可以理解为粒子的热速度…</span>. $\kappa$ 作为一个指数存在, 在低 $\kappa$ 等离子体中, 当涨落增强时, 电磁和静电场的色散关系展现出对谱指标( <span style='background: yellow;'>spectral index</span> ) $\kappa$ 强烈的依赖关系. $\kappa$ 分布被成功的应用于描述大量空间等离子体群, 比如内日球层, 太阳风, 行星磁层以及内外日鞘层.</p>
<p>下面我们来看看 $\kappa$ 分布的离子在阿尔芬波非共振相互作用下的离子加热, 温度各向异性以及差异流动等现象.</p>
<h1 id="Analytic-Theory"><a href="#Analytic-Theory" class="headerlink" title="Analytic Theory"></a>Analytic Theory</h1><p>现在考虑 $\beta = 0.01$ 的等离子体在沿背景磁场传播的左手极化单支阿尔芬波的作用下的加热现象. 波的电磁场可以被认为是满足固定变化的( Test Particle Simulation ), 离子的运动方程可以被概括为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \frac{d (\vec{v_0} + \vec{v_1})}{d t} = \frac{d \vec{v}}{d t} = \frac{q_i}{m_i} [v_1 \times (\vec{B_0} + \delta \vec{B_w}) + \delta \vec{E_w}]
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \frac{d \vec{r}}{d t} = v
\end{equation}</script><p>电磁场可以被以下的方程概括:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \delta \vec{B_w} = B_k [\cos{\phi_k - \mathrm{i} \sin{\phi_k}}]
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \delta \vec{E_w} = - v_A \vec{i_z} \times \delta \vec{B_w}
\end{equation}</script><p>为了更好的应用准线性理论, 我们将上式中出现的矢量分解到垂直磁场和平行磁场的两个方向上, 也就是: $\vec{u_{\perp}} = (v_x + \mathrm{i} v_y) \hat{\perp}$ 以及 $\vec{v_{\parallel}} = v_z \hat{\parallel}$ , 这样的话对 $(2)$ 式中左边我们得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \frac{d \vec{v}}{d t} = \frac{d (v_x \hat{x} + v_y \hat{y} + v_z \hat{z})}{d t} = \frac{d u_\perp}{d t} \hat{\perp} + \frac{d v_\parallel}{d t} \hat{\parallel}
\end{equation}</script><p>对 $(2)$ 式中右边第一项得到:</p>
<script type="math/tex; mode=display">
\begin{equation}\begin{aligned}
    \frac{q_i}{m_i} &[\vec{v_1} \times (\vec{B_0} + \delta \vec{B_w})] = \frac{q_i}{m_i} \left | \begin{matrix}
        \hat{x} & \hat{y} & \hat{z} \\
        v_x & v_y & v_z \\
        B_k \cos{\phi_k} & - B_k \sin{\phi_k} & B_0
    \end{matrix}\right | \\
    = &\frac{q_i}{m_i} [(B_0 v_y + B_k v_z \sin{\phi_k}) \hat{x} + (-B_0 v_x + B_k v_z \cos{\phi_k}) \hat{y} \\
    &- B_k (v_x \sin{\phi_k} + v_y \cos{\phi_k}) \hat{z}] \\
    = &\frac{q_i B_0}{m_i} (v_y \hat{x} - v_x \hat{y}) + \frac{q_i B_k v_z}{m_i} (\sin{\phi_k} \hat{x} + \cos{\phi_k} \hat{y}) \\
    &- \frac{q_i B_k}{m_i} (v_x \sin{\phi_k} + v_y \cos{\phi_k}) \hat{z} \\
    = &\{\frac{q_i B_0}{m_i} (v_y - \mathrm{i} v_x) + \frac{q_i B_k v_z}{m_i} (\sin{\phi_k} + \mathrm{i} \cos{\phi_k})\} \hat{\perp} \\
    &- \frac{q_i B_k}{m_i} (v_x \sin{\phi_k} + v_y \cos{\phi_k}) \hat{\parallel} \\
    = &\{- \mathrm{i} \Omega^i_0 u_{\perp} + \mathrm{i} \Omega^i_k v_{\parallel} \mathrm{e}^{-\mathrm{i} \phi_k}\} \hat{\perp} - \mathrm{Im}(u_{\perp} \Omega^i_k \mathrm{e}^{\mathrm{i} \phi_k}) \hat{\parallel}
\end{aligned}\end{equation}</script><p>其中, $\hat{}$ 表示取单位矢量; $\Omega$ 表示相应粒子在相应磁场中的回旋频率.</p>
<p>对 $(2)$ 式中右边第二项我们可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \begin{aligned}
        \frac{q_i}{m_i} \delta \vec{E_w} = &\frac{q_i}{m_i} (- \vec{v_A} \times \delta \vec{B_w}) \\
        = & \left | \begin{matrix}
            \hat{x} & \hat{y} & \hat{z} \\
            0 & 0 & -v_A \\
            B_k \cos{\phi_k} & - B_k \sin{\phi_k} & 0 
        \end{matrix} \right | \\
        = &- \frac{q_i v_A B_k}{m_i} (\sin{\phi_k} \hat{x} - \cos{\phi_k} \hat{y}) \\
        = &- \frac{q_i v_A B_k}{m_i} (\sin{\phi_k} - \mathrm{i}\cos{\phi_k}) \hat{\perp} \\
        = &-\mathrm{i} \Omega^i_k v_A \mathrm{e}^{- \mathrm{i} \phi_k} \hat{\perp}
    \end{aligned}
\end{equation}</script><p>如此一来, 联立 $(2), (6), (7)$ 以及 $(8)$ 式, 可以得到如下的在<span style='background: yellow'>guiding center</span>参考系中的运动方程:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \frac{d u_{\perp}}{d t} + \mathrm{i} \Omega^i_0 u_{\perp} = \mathrm{i} \Omega^i_k (v_{\parallel} - v_A) \mathrm{e}^{- \mathrm{i} \phi_k}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \frac{d v_{\parallel}}{d t} = - \mathrm{Im}(u_{\perp} \Omega^i_k \mathrm{e}^{\mathrm{i} \phi_k})
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \frac{d z}{d t} = v_{\parallel}
\end{equation}</script><p>根据之前的研究, 我们知道由于离子被波拾起( <span style='background: yellow'>pick up</span> ), 离子的速度最终会逐渐趋向于一个固定的渐进值. 也就是说, $\frac{d \vec{v}}{d t} = 0$ , 这样公式 $(9), (10)$ 可以被写成:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \mathrm{i} \Omega^i_0 u_{\perp} = \mathrm{i} (v_{\parallel} - v_A) \Omega^i_k \mathrm{e}^{- \mathrm{i} \phi_k}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \mathrm{Im}(u_{\perp} \Omega^i_k \mathrm{e}^{\mathrm{i} \phi_k}) = 0
\end{equation}</script><p>考虑公式 $(12)$ 的矢量方向, 左右两边可以变个形:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \vec{u_{\perp}} = \frac{\Omega^i_k \mathrm{e}^{- \mathrm{i} \phi_k}}{\mathrm{i} \Omega^i_0} \mathrm{i} (v_{\parallel} - v_A) \vec{\perp} = \frac{\delta \vec{B_w}}{\vec{B_0}} (\vec{v_{\parallel}} - \vec{v_A})
\end{equation}</script><p>平方之后就可以得到:</p>
<script type="math/tex; mode=display">
\begin{equation}
    |\vec{u_{\perp}}|^2 = \frac{\delta \vec{B_w}^2}{\vec{B_0}^2} (\vec{v_{\parallel}} - \vec{v_A})^2
\end{equation}</script><details class="toggle" ><summary class="toggle-button" style="">一段不知道正确与否的推导，对文章整体没有影响</summary><div class="toggle-content"><p>因为 $u_{\perp}, \Omega^i_k$ 都是实数, 根据 $(13)$ , 有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathrm{Im}(u_{\perp} \Omega^i_k \mathrm{e}^{\mathrm{i} \phi_k}) &= \mathrm{Im}(u_{\perp} \Omega^i_k \cos{\phi_k} + \mathrm{i} u_{\perp} \Omega^i_k \sin{\phi_k}) = 0 \\
    \Rightarrow &\sin{\phi_k} = 0 \\
    \Rightarrow &\phi_k = n \pi \\
    \Rightarrow &\cos^2{\phi_k} = 1
\end{aligned}</script></div></details>
<p>假设 $\frac{B_k^2}{B_0^2}$ 足够小, 并且 $v_{\parallel} \ll v_A$ 是合理的, 那么 $(15)$ 变成:</p>
<script type="math/tex; mode=display">
\begin{equation}
    |\vec{u_{\perp}}|^2 = \frac{\vec{B_w}^2 \vec{v_A^2}}{\vec{B_0}^2}
\end{equation}</script><p>对于 $\kappa$ 分布的离子来说, 其初始温度可以被表示为: $T_{\kappa i}=\left[2 \kappa_{i} \theta_{i}^{2} /\left(2 \kappa_{i}-3\right)\right]\left(m_{i} / 2 k_{B}\right)$ , 这样相应的离子垂直方向上的温度为:</p>
<script type="math/tex; mode=display">
\begin{equation}
T_{\perp i}=T_{\kappa i}\left(1+\frac{2 \kappa_{i}-3}{2 \kappa_{i}} \frac{B_{k}^{2}}{\beta_{i} B_{0}^{2}}\right)
\end{equation}</script><p>其中, $\beta_i = (\theta_i/v_A)^2$. 可以肯定的是对于非色散的电磁波来说, 存在这样一个参考系, 其中波速是稳定的,每个粒子的能量守恒. 当这些条件考虑到其中时, 到达渐进状态的平行方向的离子温度可以被写成:</p>
<script type="math/tex; mode=display">
\begin{equation}
T_{\parallel i}=T_{\kappa i}\left(1+\frac{2 \kappa_{i} - 3}{2 \kappa_{i}} \frac{B_{k}^{4}}{\beta_{i} B_{0}^{4}}\right)
\end{equation}</script><p>那么, 到渐进状态两个方向上的各向异性就可以被表示为:</p>
<script type="math/tex; mode=display">
\begin{equation}
    \frac{T_{\perp i}}{T_{\parallel i}}=\frac{1+\frac{2 \kappa_{i}-3}{2 \kappa_{i}} \frac{B_{k}^{2}}{\beta_{i} B_{0}^{2}}}{1+\frac{2 \kappa_{i}-3}{2 \kappa_{i}} \frac{B_{k}^{4}}{\beta_{i} B_{0}^{4}}}
\end{equation}</script><p>Alpha 离子($\mathrm{H^{+2}_e}$)和质子($\mathrm{H^+}$)之间的垂直温度各向异性(<span class='mohu'>两种离子之间的垂直温度之比</span>)为:</p>
<script type="math/tex; mode=display">
\frac{T_{\perp \alpha}}{T_{\perp p}}=\frac{T_{\kappa \alpha}\left(1+\frac{2 \kappa_{\alpha}-3}{2 \kappa_{\alpha}} \frac{B_{k}^{2}}{\beta_{\alpha} B_{0}^{2}}\right)}{T_{\kappa p}\left(1+\frac{2 \kappa_{p}-3}{2 \kappa_{p}} \frac{B_{k}^{2}}{\beta_{p} B_{0}^{2}}\right)}</script><p>这样, 我们就从理论上推导出了在低频阿尔芬波对离子流进行加热时相同离子内的温度各向异性以及不同离子之间的垂直温度差异性.</p>
<p>这与模拟得到的结果以及在探测器数据中分析出来的结果基本上是吻合的</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>等离子体物理</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>等离子体</tag>
        <tag>波粒相互作用</tag>
      </tags>
  </entry>
  <entry>
    <title>木卫二内部结构研究与建模——课程作业报告</title>
    <url>/2022/02/12/Eorupainternalstructure/</url>
    <content><![CDATA[<center><font size = '6'>木卫二内部结构研究与建模</font></center>



<p>​        <font size="3"><strong>摘要</strong></font>    木卫二（Europa），木星的天然卫星之一，是四颗伽利略卫星中最小的一颗。目前的观测推测其主要由硅酸盐岩石构成，并具有水-冰地壳，和一个可能是铁-镍组成的核心。为了更进一步的研究木卫二的内部结构，我们根据行星内部物理参数的控制微分方程以及物质的状态方程建立了可靠的模型求解系统，采用数值方法对整个系统进行了由外向内求解，要求输入各层的质量分数得到每一层的厚度、质量压力以及密度随半径的变化情况。将该模型应用到地球的双层模型以及木卫二的三层模型中，与现有的观测资料以及前人的研究工作对了比较，均得到了比较好的吻合。最后根据最新的研究资料确定了水冰层的质量分数为 7.5% ，由此代入模型推断出核和幔的质量分数分别为 3.6%、88.9%，中心压力为 49 $\rm{kbar}$（4.9 $\rm{GPa}$）。</p>
<p>​        <font size="3"><strong>关键词</strong></font>    木卫二， 内部模型， 核幔边界</p>
<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p>​        木卫二，木星的四颗伽利略卫星中最小的一颗，一直以来，木卫二因其具有的液态海洋为地外生命的探索提供了新的素材而备受关注。其平均半径为1565.0±8.0 km，质量4.80 $\times$ 1022(~ 0.245 $M_⊕$)，平均密度(2989±46) $\rm{kg/m^3}$。归一化到$MR^2$的木卫二的主轴转动惯量为: $C/MR^2 = 0.347 \pm 0.014$. 伽利略卫星发现木卫二有一个很弱的由木星磁场变化引起的磁场.</p>
<p>​        基于多普勒探测器的观测资料,  Anderson 等人在1998年研究了木卫二的内部结构,  他们假设是一个具有金属内核、岩石地幔以及水冰混合外壳的三层圈层结构。在三层结构中，内核由$\rm{Fe}$或者$\rm{Fe-FeS}$组成，大约占到木卫二半径的$0\%$到$50\%$; 外部的水冰层大约有80到170 $\rm{km}$厚；中部的岩石层则由硅酸盐或者硅酸盐与金属的混合物组成。Anderson 等人的研究中同样给出了三个圈层大致的密度：金属核的密度超过4000$\rm{kg/m^3}$，地幔密度约为3000 ~ 3500$\rm{kg /m^3}$，水冰壳约900 - 1300$\rm{kg /m^3}$。</p>
<p>​        2011年时，中国科学院紫金山天文台的 Sheng JIN 等人按照研究系外行星的方法，先假定每个圈层可能的物质组成模型，通过一系列的自洽方程由内向外积分计算出模型对应的星球质量和半径，与实测数据进行进行对比，以此判断模型的准确度，其模型结果见表一所示：</p>
<center><font size="2">表一 Sheng Jin 等人的研究模型及其结果</font></center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222230357313.png" alt="image-20220113161028705"></p>
<p>​        近年来，伴随着朱诺探测器对木星的深入研究，Luis等人对伽利略探测器的射电跟踪数据进行了再分析，重新探讨了木卫二的引力场数据和内部结构，结果如表二所示：</p>
<center><font size="2">表二 Luis 等人的研究与前人研究的对比</font></center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222231401929.png" style="zoom: 100%;" /></p>
<p>​        本文将按照 JIN 等人使用的方法对木卫二的内部结构进行进一步的探讨，根据已有的研究以及观测数据对木卫二的内部结构给出更为合理的假设，并对该假设进行建模，将模型得到的结果与 Luis 等人对射电数据再分析的结果进行比对，判断假设的适用性。</p>
<h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><p>​        行星内部的物理参数可以被如下的方程表示：<br>球壳质量方程：</p>
<script type="math/tex; mode=display">
\frac{\mathrm{d} m(r)}{\mathrm{d} r}=4 \pi r^{2} \rho(r) \tag{1}</script><p>静水压力平衡方程：</p>
<script type="math/tex; mode=display">
\frac{\mathrm{d} P(r)}{\mathrm{d} r}=\frac{-G m(r) \rho(r)}{r^{2}} \tag{2}</script><p>以及状态方程：</p>
<script type="math/tex; mode=display">
\rho(r0) = \rho_0 (1+\frac{K^\prime P(r0)}{K_0})^{\frac{1}{K^\prime}} \tag{3}</script><p>或：</p>
<script type="math/tex; mode=display">
P=\frac{3}{2} K_{0}\left[\eta^{\frac{7}{3}}-\eta^{\frac{5}{3}}\right]\left\{1+\frac{3}{4}\left(K_{0}^{\prime}-4\right)\left[\eta^{\frac{2}{3}}-1\right]\right\} \tag{4}</script><p>其中，$\eta = \frac{\rho(r)}{\rho_0}$, $K_0$和$K^\prime_0$是等温体积模量以及其在标准状态下的一阶微分。</p>
<p>​        首先，对于三层模型，我们指定最外层的质量分数、核的初始质量分数以及其误差范围，系统的迭代从木卫二表面$(r = R_{\rm{planet}})$开始，当质量达到期望的质量分数时，自动从一层切换到下一层。当质量$M(r)$达到欧罗巴实际质量时或者半径迭代到零时，程序停止计算，判断质量或者半径的剩余是否满足计算精度要求，利用二分法自动调整自动调整核的质量分数，重新代入迭代方案进行求解，直到剩余满足模型的自洽条件（要求半径和质量同时迭代到零）。因此，我们可以通过确定壳层的质量分数得到一个合理的三层模型和相应的半径$R_P$，以及核、幔的特定质量比。模型考虑将星球内部结构分割成微分球壳，采用步长为500米的4阶 Runge-Kutta 算法进行计算。 </p>
<p>​        模型迭代方式所式（5）所示，在计算压力时将壳、幔和核分开，避免半径过小时质量的剩余引起压力、密度的异常增长：</p>
<script type="math/tex; mode=display">
m_{i+1}=m_i−4\pi 𝑅_{i}^2 \rho_i \\
\\
𝑃_{i+1}^{壳、幔}=𝑃_i+\frac{𝐺 m_i \rho_i}{𝑅_i^2} \tag{5} \\
\\
𝑃_{i+1}^{核}=𝑃_i+4\pi𝐺𝑅_i \rho_i^2</script><p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222233408888.png" alt="迭代模式"></p>
<center><font size="2">图一 模型迭代过程示意图</font></center>

<h2 id="2-结果"><a href="#2-结果" class="headerlink" title="2 结果"></a>2 结果</h2><h3 id="2-1-模型验证"><a href="#2-1-模型验证" class="headerlink" title="2.1 模型验证"></a>2.1 模型验证</h3><p>​        在开始将我们的模型应用到木卫二之前，我们先利用已知信息较多的地球来简单检验一下模型的正确性。我们首先将地球简化成由橄榄石（$\rm{(Mg,Fe)_2SiO_4}$）地幔和铁核（$\rm{Fe}$）组成的两层模型，讨论两层模型时不需要指定壳层的质量分数，二分法可以直接找到满足约束条件的合适的质量分数，模型中给定的各种物质组成的热力学参数见下表：</p>
<center><font size="2">表三 行星内部物质的热力学参数</font></center>

<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222233718849.png" alt=""></p>
<p>​        图二给出了模型计算的地球双层模型质量、压力以及密度随半径的变化。从图中可以看到模型计算出来的核幔边界在 3555 $\rm{km}$ 处，中心压力大致为370 $\rm{GPa}$，这两个结果与地球的实际情况（核幔边界 3470 $\rm{km}$，中心压力 379 $\rm{GPa}$）都可以较好地吻合。由此判断该模型结果比较可靠，可以用来对木卫二进行内部结构建模。</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222234008430.png" alt="地球质量压力"></p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222234053580.png" alt="地球密度"></p>
<center><font size="2">图二 地球双层模型的计算结果</font></center>

<h3 id="2-2-木卫二模型计算结果"><a href="#2-2-木卫二模型计算结果" class="headerlink" title="2.2 木卫二模型计算结果"></a>2.2 木卫二模型计算结果</h3><p>​        在验证模型的准确性之后，开始对木卫二内部结构的建模，假设木卫二深部具有与地球类似的物质组成：即整体由水冰壳（$\rm{H_2O}$）、硅酸盐地幔( $\rm{(Mg,Fe)_2SiO_4}$)以及铁核（$\rm{Fe}$）组成，其各自的热力学参数在地球双层模型中已经给出；同时为了准确的研究木卫二的内部结构，假设表面的水冰层的质量分数是固定的（表面比较容易测量，本文中确定为 10% ），用二分法求解内部的核、幔厚度以及其各自的质量分数。模型结果见图三：</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222234236919.png" alt="木卫二质量压力"></p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222234327078.png" alt="木卫二密度"></p>
<center><font size="2">图三 木卫二三层模型在水冰层质量分数为 10% 时的计算结果</font></center>

<p>​        模型计算出来木卫二的壳幔边界在1398.5 $\rm{km}$处，幔占总质量的 76% ；核幔边界在597 $\rm{km}$处，核占总质量的 14%；木卫二中心压力大致为6.6 $\rm{GPa}$，与Sheng Jin等人在2012年用从内向外积分的模型结果非常接近。另外 luis 等人在 2021 年对木卫二表面的射电数据进行了贝叶斯反演，得到木卫二的水冰层占木卫二质量的 7.5% 左右，我们将该质量分数代入到模型中计算出其内部结构为 380 $\rm{km}$处为核幔边界，1442 $\rm{km}$处为壳幔边界，其中核占总质量的 3.6% ，幔占质量的 88.9% 左右，中心压力 4.9 $\rm{GPa}$，与张鸿等在2002年采用的双层模型的结果基本一致。</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222234414368.png" alt="木卫二质量压力2"></p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222234520178.png" alt="木卫二密度2"></p>
<center><font size="2">图四 木卫二三层模型在水冰层质量分数为 7.5% 时的计算结果</font></center>

<h2 id="3-总结与讨论"><a href="#3-总结与讨论" class="headerlink" title="3 总结与讨论"></a>3 总结与讨论</h2><p>​        本文根据行星内部结构的控制微分方程以及物质的状态方程建立了求解行星内部结构的迭代方法，利用该方法建立了双层地球模型以及多层木卫二内部模型，结果与目前已有的观测以及前人的研究结果可以很好的吻合。</p>
<p>​        该方法由外向内迭代，由于行星表面的参数获取相对内部容易，模型初始条件可以比较容易获得，相比由内向外迭代的方法少了行星中心压力的假设以及模型的自洽耦合过程（该方法对内部模型求解和使内部模型自洽是同一过程），更简单，易理解；但该方法没有考虑温度以及压力本身对状态方程的影响，计算精度较低，近似假设较多，同时由外向内迭代会出现前述密度、压力突然增加（该方法中已经采用近似方法解决，但有待改进）的情况，另外采用二分法固定冰层的质量分数来求解剩余的质量分数效率低下，作用有限。</p>
<p>​        在此基础上，可以增加温度和压力对状态方程的影响，并且采用蒙特卡洛方法同时求解所有层的质量分数（需要增加新的约束）。</p>
<p>​        总的来说，经过不断的失败，最终还算是得到了较为可靠的模型（方法），但确实改进空间还非常大！</p>
<div class="note primary flat"><p>研究所使用到的代码全部放在Github上供大家参考，地址为：<br><a href="https://github.com/tabris-trees/IMPC">https://github.com/tabris-trees/IMPC</a></p>
<p>另外提供最终汇报时所用到的PPT下载链接：<a href="https://njtecheducn-my.sharepoint.com/:p:/g/personal/2858795004_njtech_edu_cn/EeuJt5jPjv5NiwH6xCmPNnwBfaY5PdcNytpELsw_vgWF6A?e=AGdEDe">https://njtecheducn-my.sharepoint.com/:p:/g/personal/2858795004_njtech_edu_cn/EeuJt5jPjv5NiwH6xCmPNnwBfaY5PdcNytpELsw_vgWF6A?e=AGdEDe</a></p>
</div>
<h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h2><ol>
<li>龚盛夏 &amp; 黄乘利. 太阳系内类地行星内部结构模型研究进展. 天文学进展 31, 391–410 (2013).</li>
<li>张鸿 &amp; 张承志. 木卫二的内部结构模型和海洋层——伽利略探测的最新研究进展. 天文学进展 223–233 (2002).</li>
<li>Zeng, L. &amp; Seager, S. A Computational Tool to Interpret the Bulk Composition of Solid Exoplanets based on Mass and Radius Measurements. Publ. Astron. Soc. Pac. 120, 983–991 (2008).</li>
<li>Nicole A. Spaun &amp; James W. Head. A model of Europa’s crustal structure: Recent Galileo results and implications for an ocean. J. Geophys. Res. Planets 106, 7567–7576 (2001).</li>
<li>Brugger, B., Mousis, O., Deleuil, M. &amp; Deschamps, F. Constraints on Super-Earths Interiors from Stellar Abundances. Astrophys. J. 850, 93 (2017).</li>
<li>Pappalardo, R. T., McKinnon, W. B. &amp; Khurana, K. Europa. (University of Arizona Press, 2009).</li>
<li>Anderson, J. D. et al. Europa’s Differentiated Internal Structure: Inferences from Four Galileo Encounters. Science (1998) doi:10/b3qmg9.</li>
<li>Ransford, G. A., Finnerty, A. A. &amp; Collerson, K. D. Europa’s petrological thermal history. Nature 289, 21–24 (1981).</li>
<li>Marusiak, A. G. et al. Exploration of Icy Ocean Worlds Using Geophysical Approaches. Planet. Sci. J. 2, 150 (2021).</li>
<li>F. Sohl, T. Spohn, D. Breuer, &amp; K. Nagel. Implications from Galileo Observations on the Interior Structure and Chemistry of the Galilean Satellites. Icarus 157, 104–119 (2002).</li>
<li>G Schubert, J D Anderson, T Spohn, &amp; W B McKinnon. Interior Composition, Structure and Dynamics of the Galilean Satellites. in 27.</li>
<li>Wagner, F. W., Sohl, F., Hussmann, H., Grott, M. &amp; Rauer, H. Interior structure models of solid exoplanets using material laws in the infinite pressure limit. Icarus 214, 366–376 (2011).</li>
<li>O. L. Kuskov &amp; V. A. Kronrod. Internal structure of Europa and Callisto. Icarus 177, 550–569 (2005).</li>
<li>Valencia, D., O’Connell, R. J. &amp; Sasselov, D. Internal structure of massive terrestrial planets. Icarus 181, 545–554 (2006).</li>
<li>Finnerty, A. A., Ransford, G. A., Pieri, D. C. &amp; Collerson, K. D. Is Europa surface cracking due to thermal evolution? Nature 289, 24–27 (1981).</li>
<li>F. Cammarano, V. Lekic, M. Manga, M. Panning, &amp; B. Romanowicz. Long-period seismology on Europa: 1. Physically consistent interior models: LONG-PERIOD EUROPA SEISMOLOGY, 1. J. Geophys. Res. Planets 111, n/a-n/a (2006).</li>
<li>Seager, S., Kuchner, M., Hier‐Majumder, C. A. &amp; Militzer, B. Mass‐Radius Relationships for Solid Exoplanets. Astrophys. J. 669, 1279–1297 (2007).</li>
<li>Sotin, C., Grasset, O. &amp; Mocquet, A. Mass–radius curve for extrasolar Earth-like planets and ocean planets. Icarus 191, 337–351 (2007).</li>
<li>Baraffe, I., Chabrier, G., Fortney, J. &amp; Sotin, C. Planetary Internal Structures. in Protostars and Planets VI (University of Arizona Press, 2014). doi:10.2458/azu_uapress_9780816531240-ch033.</li>
<li>Biersteker, J. B. et al. Revealing the Internal Structure of Europa with a Bayesian Approach to Magnetic Induction Studies. in 2654 (2021).</li>
<li>Sotin, C., Jackson, J. M. &amp; Seager, S. Terrestrial Planet Interiors. Exoplanets 375–395 (2010).</li>
<li>Ghail, R. C. The composition and structure of Europa. Lunar Planet. Sci. 28, 407–408 (1997).</li>
<li>Sheng Jin &amp; JiangHui Ji. The internal structure models of Europa. Sci. China Phys. Mech. Astron. 55, 156–161 (2012).</li>
<li>Luis Gomez Casajus et al. Updated Europa gravity field and interior structure from a reanalysis of Galileo tracking data. Icarus 358, 114187 (2021).</li>
</ol>
]]></content>
      <categories>
        <category>科研</category>
        <category>行星内部结构</category>
      </categories>
      <tags>
        <tag>木卫二</tag>
        <tag>行星内部结构</tag>
        <tag>行星科学</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran语言学习——文件</title>
    <url>/2021/09/28/fortran-file/</url>
    <content><![CDATA[<div class="note primary flat"><p>计算机有两项功能，一项是计算、处理数据；一项是保存数据。前面的内容都是在讨论如何处理数据，现在来讨论如何保存数据。</p>
<p>数据的保存主要是依赖于文件，程序将数据写入文件，就可以将这些数据长久的保存，直到文件被更改或者销毁。</p>
</div>
<h1 id="文件读取的概念🍉"><a href="#文件读取的概念🍉" class="headerlink" title="文件读取的概念🍉"></a>文件读取的概念🍉</h1><p>Fortran中文件读取有“顺序读取”和“直接读取”两种：</p>
<ol>
<li>顺序读取：指的是读取文件时按照文件中数据的顺序从头开始，依次往下读取，如同听录音带一样。这是最简单的方法，足以应付绝大多数情况；</li>
<li>直接读取：指读取文件时可以任意跳到文件的任何一个位置开始读写，类似于DVD，可以直接欣赏某一个部分。</li>
</ol>
<p>保存文件同样可以有两种方法：</p>
<ol>
<li>文本文件：所有的数据都是容易阅读的字符或者符号，可以使用文本编辑器打开；</li>
<li>二进制文件：数据被保存为二进制代码（全是数字0和1组成），需要专门的软件打开。</li>
</ol>
<p>相对来说，二进制的文件读取速度更快，它的保存格式与数据在内存中的格式是一致的，不像文本格式需要经过转换；其次，二进制的文件更加省空间，很简单，计算机底层的结构就是二进制，自然具有各方面的优势。</p>
<hr>
<h1 id="文件的操作🍈"><a href="#文件的操作🍈" class="headerlink" title="文件的操作🍈"></a>文件的操作🍈</h1><div class="note primary flat"><p>该部分的内容很多，只需要记住常见命令即可，很多命令基本不会用到。</p>
</div>
<h2 id="OPEN的使用"><a href="#OPEN的使用" class="headerlink" title="OPEN的使用"></a><code>OPEN</code>的使用</h2><p><code>open</code>的使用与<code>write(*,*)</code>以及<code>read(*,*)</code>中的第一个*号（输入\输出的位置，默认是键盘\屏幕）有关：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=<span class="number">10</span>,<span class="keyword">file</span>=<span class="string">&#x27;hello.txt&#x27;</span>)</span><br><span class="line"><span class="comment">! unit=N用来给后面的文件指定一个代码（N），file则表示打开的文件</span></span><br><span class="line"><span class="comment">! 文件不存在时则创建一个新文件</span></span><br><span class="line"><span class="built_in">write</span>(<span class="number">10</span>,*) <span class="string">&quot;hello,World!&quot;</span></span><br><span class="line"><span class="comment">! 如此一来，&quot;hello,World!&quot;这个字符串就被保存到文件hello.txt中了</span></span><br></pre></td></tr></table></figure>
<p><code>open</code>的详细参数非常之多，这里列出比较常见的：</p>
<ol>
<li>unit=number，number必须是一个正整数，可以是变量，尽量不要用1，2，5，6（<span style='background: yellow;'>1，5是默认输入的位置，即键盘；2，6是默认输出的位置，即屏幕</span>）；</li>
<li>file=’filename’，很简单，文件名，注意要符合操作系统的文件命名习惯；</li>
<li>form=’formatted’（ <strong>‘文本格式’</strong> 保存）\’unformatted’（ <strong>‘二进制格式’</strong> 保存）,默认’<strong>文本格式</strong>‘；</li>
<li>status=’new’（打开新文件）\’old’（打开旧文件）\’replace’（文件若已经存在，则替换原文件，不存在则新建）\’scratch’（暂时文件，此时不用指定文件名，程序结束文件会被自动删除）\’unkown’（由编译器自定义，一般相当于’replace’），默认’unkown’；</li>
<li>access=’sequential’（ <strong>‘顺序读取’</strong> 文件）\’direct’（ <strong>‘直接读取’</strong> 文件），默认 <strong>‘顺序读取’</strong> ；</li>
<li>err=label，文件打开错误时，程序会跳转到label所指的行代码继续执行；</li>
<li><p>iostat=var，将文件打开的状态赋值给var变量（这意味着要对其进行声明）：</p>
<ul>
<li>var &gt; 0 : 读取操作发生错误；</li>
<li>var &lt; 0 : 文件终了；</li>
<li>var = 0 : 文件读取正常。</li>
</ul>
</li>
<li><p>action=’read’（<strong>只读</strong>）\’write’（<strong>只写</strong>）\’readwrite’（<strong>读写皆可</strong>，默认）。</p>
</li>
</ol>
<h2 id="WRITE，READ的使用"><a href="#WRITE，READ的使用" class="headerlink" title="WRITE，READ的使用"></a><code>WRITE</code>，<code>READ</code>的使用</h2><p><code>read</code>和<code>write</code>的详细是类似的，所以放到一起介绍：</p>
<ol>
<li>unit=number，和<code>open</code>的<code>unit</code>联系起来，用来指定输出\输入的位置；</li>
<li>fmt=format，指定输入输出的格式；</li>
<li>nml=namelist，指定读写某个namelist的内容（namelist的含义需要到后面介绍）；</li>
<li>rec=record，在直接读取文件中，设置索要读写的文件模块的位置；</li>
<li>iostat\err\end，用法和<code>open</code>一样；</li>
<li>advance=yes（默认状态，每读写一次会向下移动一行）\no（暂停自动换行）。</li>
</ol>
<h2 id="查询文件的状态INQUIRE"><a href="#查询文件的状态INQUIRE" class="headerlink" title="查询文件的状态INQUIRE"></a>查询文件的状态<code>INQUIRE</code></h2><p><code>inquire</code>命令主要用来查询文件此时的状态，其同样支持很多参数：</p>
<ol>
<li>UNIT=number，文件代号；</li>
<li>FILE=filename，文件名；</li>
<li><p>IOSTAT=stat，查询文件读取情况，会设置一个整数给后面的变量：</p>
<ul>
<li>stat&gt;0   文件读取操作错误</li>
<li>stat=0   文件读取操作正常</li>
<li>stat&lt;0   文件终了</li>
</ul>
</li>
<li><p>ERR=errlabel，发生错误时会转移到复制的代码行继续执行程序；</p>
</li>
<li>EXIST=exist，检查文件是否存在，返回布尔变量，真表示存在，假值表示不存在；</li>
<li>OPEND=opened，检查文件是否用已经用open打开，返回布尔变量，真表示已经打开，假表示尚未打开；</li>
<li>NUMBER=number，用文件名来查询这个文件所给定的代码；</li>
<li>NAMED=named，查询文件是否取了名字，也就是检查文件是否为临时保存盘，返回值为逻辑数；</li>
<li>ACCESS=access，检查文件的读取格式，返回一个字符串；</li>
<li>SEQUENTIAL=sequential，查看文件是否使用顺序格式，会返回一个字符串；</li>
<li>DIRECT＝direct，查看文件是否使用直接格式，会返回一个字符串；</li>
<li>FORM=form，查看文件的保存方法，返回字符串；</li>
<li>FORMATTED=fmt，查看文件是否是文本文件，返回字符串；</li>
<li>UNFORMATTED=fmt，查看文件是否是二进制文件，返回字符串；</li>
<li>RECL=length，返回open文件时recl栏的设置值</li>
<li>NEXTREC=nr，返回下一次文件读写的位置；</li>
<li>BLANK=blank，返回值是字符串，用来查看open文件时的blank参数所给定的字符串值；</li>
</ol>
<p><strong>以下是fortran 90的添加功能：</strong></p>
<ol>
<li>POSITION=position，返回打开文件时position字段所给定的字符串, 可能是’REWIND’,’APPEND’,’ASIS’, ‘UNDEFINED’</li>
<li>ACTION=action，返回打开文件时action 字段所赋值的字符串，可能是’READ’, ‘WRITE’,’READWRITE’。</li>
<li>READ=read,返回字符串，检查文件是否为只读文件；</li>
<li>WRITE=write，返回一个字符串，检查文件是否可写入；</li>
<li>READWRITE=readwrite 返回一个字符串，检查文件是否可以同时读及写；</li>
<li>DELIM=delim，返回打开文件时，DELIM字段所设置的字符串，返回值可以是：’APOSTROPHE’, ‘QUOTE’, ‘NONE’, ‘UNDEFINED’；</li>
<li>PAD=pad，返回打开文件时PAD字段所设置的字符串，返回值可以是：’YES’, ‘NO’。</li>
</ol>
<p><strong>其他文件运行命令：</strong></p>
<ol>
<li>BACKSPACE(UNIT=number, ERR=errlabel, IOSTAT=iostat)，把文件读写位置退回一步；</li>
<li>ENDFILE(UNNIT=number, ERR=errlabel, IOSTAT=iostat)，使用这个命令会把目前文件的读写位置变成文件的结尾；</li>
<li>REWIND(UNIT=number, ERR=errlabel, IOSTAT=iostat)，把文件的读写位置倒回到文件开头；</li>
<li><p>CLOSE(UNIT=number, STATUS=string, ERR=errlabel, IOSTAT=)，把文件关闭，不要进行读写操作；</p>
<ul>
<li>STAT=’KEEP’      会在文件关闭后，保留这个文件。是默认状态。</li>
<li>STAT=’DELETE’    在文件关闭后，消除这个文件。</li>
</ul>
</li>
</ol>
<div class="note danger flat"><ul>
<li>程序结束时候会自动关闭文件，不过最好要养成自己关闭文件的习惯。</li>
<li>在读文件的时候要懂得略掉一些没有必要的数据，如文件中的注释行。</li>
<li>自由格式的数据文件读取（可以先读入前面的判断字符，结合select case或其他方法判断读入的数据）在open,read,write时使用不同的unit值，就可以打开多个文件。最好不要同时打开很多个文件。</li>
</ul>
</div>
<hr>
<h1 id="读取文件方式的操作🍇"><a href="#读取文件方式的操作🍇" class="headerlink" title="读取文件方式的操作🍇"></a>读取文件方式的操作🍇</h1><p>顺序文件在读写时，只能从头开始一步一步向下进行。改变文件读写位置时，只能一步一步地进退，或者直接移回文件开头。</p>
<p>直接读取文件的意思是把文件的空间、内容事先分区成好几个同样大小的小模块，这些模块会自动按照顺序编号，读取文件时，要先赋值文件读写位置在第几个模块（<code>read</code>命令中的<code>rec</code>参数）</p>
<hr>
<h1 id="二进制文件的操作🍒"><a href="#二进制文件的操作🍒" class="headerlink" title="二进制文件的操作🍒"></a>二进制文件的操作🍒</h1><p>二进制文件由于是按照计算机内存保存数据的方式对数据进行保存的，所以会存在和文本文件字符数不一致的问题：也就是<code>open</code>命令中<code>recl</code>（表示输出长度）所设置的整数 n 的值所代表的大小会因为编辑器的不同而不同，不过都是可以经过设置而改变的。</p>
<p>另外，二进制文件通常是一串紧密的数字，也就没有必要为了增加可读性而在数据之间使用区分符号，因为二进制文件没有可读性可言。</p>
<div class="note success flat"><p>二进制文件相对于文本文件来说不会存在数据损失的情况（主要是在保存数字时），所以当需要存放“<strong>精确</strong>”且“<strong>大量</strong>”的数据时建议使用二进制进行保存</p>
</div>
<hr>
<h1 id="Internal-File（内部文件）🥥"><a href="#Internal-File（内部文件）🥥" class="headerlink" title="Internal File（内部文件）🥥"></a>Internal File（内部文件）🥥</h1><p>所谓内部文件就是<span style='background: yellow;'>使用写入文件的方法，把数据写到一个字符串变量中</span>。举个栗子🌰：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="number">2</span></span><br><span class="line">b=<span class="number">3</span></span><br><span class="line"><span class="keyword">character</span> (len=<span class="number">20</span>) :: string</span><br><span class="line"><span class="built_in">write</span> (<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>=<span class="string">&quot;(I2,&#x27;+&#x27;,I2,&#x27;=&#x27;,I2)&quot;</span>) a, b, a+b <span class="comment">!把字符串变量当作输出的目的。</span></span><br><span class="line"><span class="built_in">write</span>(*, *) string</span><br></pre></td></tr></table></figure>
<p>结果是: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2+ 3= 5</span><br></pre></td></tr></table></figure>
<p>还可以经过<code>read</code>命令从字符串读入数据：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a</span><br><span class="line"><span class="keyword">character</span> (len=<span class="number">20</span>) :: string=<span class="string">&quot;123&quot;</span></span><br><span class="line">read(string, *) a</span><br><span class="line"><span class="built_in">write</span>(*, *) a</span><br></pre></td></tr></table></figure>
<p>在某些情况下使用内部文件来设置数据有十分必要的好处：</p>
<p>使用<code>read</code>命令从键盘输入数据时，如果用户输入错误的数据，会导致死机。比如如需要输入整数时却输入英文字母，就可能会死机。比较好的处理办法是，程序先暂时把数据当作字符串读入，检查字符串中是否含有不合理的字符，如果字符串中都是0～9的数字字符，就把字符串转成整数，不然就请用户在输入一次。</p>
<p>另外，内部文件还可应用在动态改变输出格式，输出格式可以事先存放在字符串中，程序进行时，动态改变字符串内容就可以改变输出格式。</p>
<hr>
<h1 id="NAMELIST🍓"><a href="#NAMELIST🍓" class="headerlink" title="NAMELIST🍓"></a><code>NAMELIST</code>🍓</h1><p><code>NAMELIST</code>是一种特殊的输入输出方法，可以把一组相关变量封装到一起，输入/输出变量时是需要在<code>read</code>/<code>write</code>的<code>nml</code>字段中设置需要使用哪一个 namelist 即可。其使用方法类似于变量，需要做声明：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namelist</span> /nl_name/ var1,var2,...</span><br><span class="line"><span class="comment">! 使用namelist必须要对其取一个名字</span></span><br><span class="line"><span class="built_in">write</span>(*,<span class="keyword">nml</span>=nl_name) <span class="comment">! 输出nl_name这个 namelist</span></span><br></pre></td></tr></table></figure>
<p>输出 namelist 时不能带有格式，因为其格式在编译器中已经设置好了，由编译器决定，一般来说是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;nl_name （&amp;符号 + namelist的名字）</span><br><span class="line">A       =           1,  （输出变量的名称、等号、内容）</span><br><span class="line">B       =           2,  （变量之间用逗号或者空格进行分隔）</span><br><span class="line">C       =           3</span><br><span class="line">/  （最后用除号结束）</span><br></pre></td></tr></table></figure>
<p>输入时也要按照类似的格式进行输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;nl_name a=1 b=2 c=3 /</span><br></pre></td></tr></table></figure>
<p>输入时可以不输入所有的变量，也可以不按照顺序输入变量，甚至可以重复输入变量的值（以最后一次输入的值为准）。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran语言学习——函数</title>
    <url>/2021/09/13/fortran-function/</url>
    <content><![CDATA[<div class="note primary flat"><p>程序中在不同地方常常需要重复使用某一个功能或者某一段程序代码，这个需求可以利用“函数”来实现。函数是“自定义函数”和“子程序”的统称。</p>
</div>
<h1 id="子程序🎃"><a href="#子程序🎃" class="headerlink" title="子程序🎃"></a>子程序🎃</h1><h2 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h2><p>子程序可以用来独立出某一段需要重复使用的代码，供其他地方调用。通常使用关键字<code>CALL</code>来进行调用。通常采用以下的结构写子程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    ...</span><br><span class="line">    ... <span class="comment">! 主程序代码</span></span><br><span class="line">    <span class="keyword">call</span> sub1() <span class="comment">! 调用子程序1</span></span><br><span class="line">    <span class="keyword">call</span> sub2() <span class="comment">! 调用子程序2</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    ...</span><br><span class="line">    ... <span class="comment">! 子程序1代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">! return代表子程序的运行停止，类似于主程序的stop，可以省略</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    ...</span><br><span class="line">    ... <span class="comment">! 子程序2代码</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>子程序可以在任何地方被调用，甚至是自己调用自己，这就是所谓的<strong>递归</strong>。</p>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>变量对于一个程序来说尤为重要，在Fortran中，变量的使用相对于Python这样的新高级语言显得十分的麻烦，所以需要专门花时间讲清楚变量在子程序中的使用。</p>
<p>基本的结构可以按照以下的形式来进行操作：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">integer</span> :: a,b <span class="comment">! 主程序中作变量声明</span></span><br><span class="line">    <span class="keyword">call</span> sub(a,b) <span class="comment">! 传递参数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(first,second) <span class="comment">! 设置参数</span></span><br><span class="line">    <span class="keyword">integer</span> :: first,second <span class="comment">! 子程序中作变量声明</span></span><br><span class="line">    ... <span class="comment">! 子程序操作代码</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub</span><br></pre></td></tr></table></figure>
<p>可以看到这个用法和Python有着很大程度的不同，这是因为主程序与子程序之间传递参数的方式在不同的程序语言之间是不同的：Fortran中使用的是<em>传址调用</em>，C语言中使用<em>传值调用</em>，Python中使用的是混合方法，即对于可变对象使用传址调用，对不可变对象使用传值调用。</p>
<p>我们这里主要关注传址调用，意思是说经过传递的变量之间会使用同一处内存地址，所以我们可以利用传递在子程序中改变主程序的变量（<strong>这个改变在主程序中也会得到反应</strong>）。<span style='background: yellow;'>但是，值得注意的是，子程序和主程序中没有经过调用的变量之间一定是独立的，相互之间改变值是不会有影响的（除非是使用<em>全局变量</em>的形式）。</span></p>
<hr>
<h1 id="自定义函数🍉"><a href="#自定义函数🍉" class="headerlink" title="自定义函数🍉"></a>自定义函数🍉</h1><p>自定义函数和子程序大体上是相同的，除了以下两点：</p>
<ul>
<li>调用自定义函数前需要先声明</li>
<li>自定义函数执行后会返回一个值（这一点在子程序中是不一定的，<span calss="heimu">也许我们可以说，Python的函数结构是将这两者合二为一来使用了</span>）</li>
</ul>
<p>其主要的结构可以按照如下的形式来使用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">real</span> :: a,b</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> func1 <span class="comment">! external是为了声明func1作为一个函数存在</span></span><br><span class="line">    <span class="comment">! 意思是自定义函数要返回一个数值，我们将这个数值的类型声明为某种特殊的变量</span></span><br><span class="line">    ... func1(a,b) ... <span class="comment">! 调用函数的代码部分</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> func1(first,second)</span><br><span class="line">    <span class="keyword">real</span> :: first,second</span><br><span class="line">    <span class="keyword">real</span> :: func1_result <span class="comment">! 这里是声明函数返回的数值的类型</span></span><br><span class="line">    ... <span class="comment">! 函数的内部代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>
<div class="note success flat"><p>上述过程中已经包括了如何在函数中使用变量。同时还有一个不成文的“规定”：“传递给函数的变量，我们只需要使用或者读取它的数值就好了，不要去改变它的数据。”根据数学上函数的定义，我们传入的是“自变量”，输出的是“应变量”，自变量自然不可以随便改写值的大小。</p>
</div>
<hr>
<h1 id="全局变量（COMMON）🍎"><a href="#全局变量（COMMON）🍎" class="headerlink" title="全局变量（COMMON）🍎"></a>全局变量（COMMON）🍎</h1><p><code>COMMON</code>是Fortran 77中使用“全局变量”的办法，用来定义一块共享的内存空间，其一般的结构如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b,c,d,e,f</span><br><span class="line">    <span class="keyword">common</span> a,b,c,d,e,f <span class="comment">! 将变量放入common空间中，以下类似</span></span><br><span class="line">    <span class="keyword">common</span> /group1/ first <span class="comment">! 对全局变量进行分组 分组1</span></span><br><span class="line">    <span class="keyword">common</span> /group2/ second <span class="comment">! 对全局变量进行分组 分组2</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> n1,n2,n3,n4,n5,n6</span><br><span class="line">    <span class="keyword">common</span> n1,n2,n3,n4,n5,n6 <span class="comment">! 按照顺序分别共享a,b,c,d,e,f的内存地址</span></span><br><span class="line">    <span class="comment">! 这样会有类似于只需要取用第六个变量f的地址，但仍然要在f前设置五个用不着的变量来占位</span></span><br><span class="line">    <span class="comment">! 为了避免上述问题，可以对全局变量进行分组</span></span><br><span class="line">    <span class="keyword">common</span> /group1/ num1 <span class="comment">! 取用group1中的first进行共享地址</span></span><br><span class="line">    <span class="keyword">common</span> /group2/ num2 <span class="comment">! 取用group2中的second进行共享地址</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub</span><br><span class="line"></span><br><span class="line"><span class="keyword">block</span> <span class="keyword">data</span> <span class="keyword">name</span> <span class="comment">! name可以省略</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span> <span class="comment">! 最好不要省略这一行</span></span><br><span class="line">    <span class="keyword">integer</span> ... <span class="comment">! 声明变量</span></span><br><span class="line">    <span class="keyword">real</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">common</span> ... <span class="comment">! 将变量放入common空间中，并进行赋值</span></span><br><span class="line">    <span class="keyword">common</span> /group1/ ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> var1,var2... <span class="comment">! 赋予初始值</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">block</span> <span class="keyword">data</span> <span class="keyword">name</span> <span class="comment">! 和此前一样，可以只写end或者end block data</span></span><br></pre></td></tr></table></figure>
<div class="note danger flat"><p>需要注意的是：COMMON变量不能在主程序或者子程序中使用<code>DATA</code>来进行初始值的赋予，而是在<code>BLOCK DATA</code>中使用<code>DATA</code>命令来进行。另外全局变量不能声明常量，因此不能出现<code>PARAMETER</code>命令。</p>
<p>当然，任何时候都不要忘记变量的类型相互之间是否匹配！！！</p>
</div>
<hr>
<h1 id="函数中的变量🍑"><a href="#函数中的变量🍑" class="headerlink" title="函数中的变量🍑"></a>函数中的变量🍑</h1><p>这里的函数包括了自定义函数和子程序两种类似的结构，这一节主要是参数传递过程中的注意事项和部分特殊的参数传递过程。所谓注意事项，最重要的一点无非是要注意“<span style="background: yellow;">参数类型是否正确</span>”</p>
<h2 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h2><p><a href="https://www.tabirstrees.top/2021/09/03/fortran-array/">数组</a>中我们提到，数组类型的变量在内存中占用的是一整块连续空间，但在参数的传递时，实际传递时数组中某一个参数的内存地址，因此我们会有一些比较特殊的用法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0816</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">  <span class="keyword">call</span> ShowOne(a)   <span class="comment">! 传入a, 也就是传入数组a第1个元素的内存地址</span></span><br><span class="line">  <span class="keyword">call</span> ShowArray5(a)  </span><br><span class="line">  <span class="keyword">call</span> ShowArray3(a)  </span><br><span class="line">  <span class="keyword">call</span> ShowArray3( a(<span class="number">2</span>) ) <span class="comment">! 传入a(2), 也就是传入数组a第2个元素的内存地址</span></span><br><span class="line">  <span class="keyword">call</span> ShowArray2X2(a)  </span><br><span class="line">  <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowOne(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: num(<span class="number">1</span>) <span class="comment">! 只取出参数地址中的第1个数字</span></span><br><span class="line">  <span class="built_in">write</span>(*,*) num</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray5(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: num(<span class="number">5</span>) <span class="comment">! 取出参数地址中的前5个数字,当成数组来使用</span></span><br><span class="line">  <span class="built_in">write</span>(*,*) num</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: num(<span class="number">3</span>) <span class="comment">! 取出参数地址中的前3个数字,当成数组来使用</span></span><br><span class="line">  <span class="built_in">write</span>(*,*) num</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray2X2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: num(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">! 取出参数地址中的前4个数字,当成2X2数组来使用</span></span><br><span class="line">  <span class="built_in">write</span>(*,*) num(<span class="number">2</span>,<span class="number">1</span>), num(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">2           3           4</span><br><span class="line">2           4</span><br></pre></td></tr></table></figure>
<p>以上，自行体会。</p>
<p>另外，我们也有提到，数组变量在声明时需要指定其大小（使用一个常数），但是在函数中，如果数组是用来接收的参数时可以用变量来进行指定，甚至是不指定（用通配符<code>*</code>代替）。<span class="heimu">实际上，我们用来传递的变量早在数组进入子程序之前就已经分配好了内存空间了，因为使用<em>传址调用</em>时，在主程序中我们也需要定义一个使用同一个内存地址的变量。在函数中赋值数组的大小只是方便检查，不会去重新分配内存，所以可以省略。</span>同样的道理，对于任何需要指定大小或者长度的变量都有类似的情况存在。</p>
<h2 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h2><p>函数中的变量只能在函数中存在（与主程序是独立的，且不包含所输入的参数），因此，通常情况下他们所能够存在的时间只有在这个子程序被执行的这一段时间。子程序结束后，他们就“死亡”了，所保存的数据也会跟着被释放掉。</p>
<p>在声明中加入<code>save</code>命令可以拯救这些变量、增加变量的生存周期、保留数据：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">save</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><p>函数的参数在传递时，除了可以出传送数字、字符等等数据外，还可以直接传递一个函数名称。这里涉及到前面提到的某个关键字<code>external</code>以及一个新的关键字<code>intrinsic</code>。只有在函数的声明中出现这两个关键字时才能将函数当作参数进行传递：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: func <span class="comment">! 声明一个外接（自定义）函数，一般情况下external可以省略</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">! 声明一个Fortran内置的函数，一般情况下这一行都可以省略</span></span><br><span class="line">    <span class="keyword">external</span> :: sub <span class="comment">! 声明一个子程序，一般情况可省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span> Execfunc(func) <span class="comment">! 传递一个external函数作为参数</span></span><br><span class="line">    <span class="keyword">call</span> Execfunc(<span class="built_in">sin</span>) <span class="comment">! 传递一个intrinsic函数作为参数</span></span><br><span class="line">    <span class="keyword">call</span> Execfunc(sub) <span class="comment">! 传递一个子程序</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Execfunc(f)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: f <span class="comment">! 声明f是一个函数(或子程序)</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(var1)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: var1 <span class="comment">! 正常的参数</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> func(var2)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: var2 <span class="comment">! 正常的参数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="参数的特殊使用方法🍇"><a href="#参数的特殊使用方法🍇" class="headerlink" title="参数的特殊使用方法🍇"></a>参数的特殊使用方法🍇</h1><h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><p>某些时候，我们希望我们传递进来的参数可以只读，它的值不能在函数中改变；或者某个参数一定要在函数中被重新设置数值。这种时候我们可以设置参数的属性，如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(var1,var2)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: var1 <span class="comment">! 声明（指定）var1参数是只读的</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">out</span>) :: var2 <span class="comment">! 声明var2参数是需要被重写的</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="函数的使用接口（INTERFACE）"><a href="#函数的使用接口（INTERFACE）" class="headerlink" title="函数的使用接口（INTERFACE）"></a>函数的使用接口（INTERFACE）</h2><p>INTERFACE是主程序中的一段程序模块，用来清除说明函数所要调用以及返回的参数类型的“使用接口”。一般情况是不需要使用的，但在以下几种情况中是必要的：</p>
<ul>
<li>函数返回值是数组时</li>
<li>指定参数位置来传递参数时</li>
<li>所调用的函数参数数目不固定时</li>
<li>输入指标参数时</li>
<li>函数返回值是指针时</li>
</ul>
<p>之后会陆续讲到这几种情况的具体内容，先来看看你<code>INTERFACE</code>模块的基本结构：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Interface</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> func_name</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: ...</span><br><span class="line">        <span class="keyword">integer</span> :: ... <span class="comment">! 该处只能说明参数和返回值的类型</span></span><br><span class="line">    <span class="keyword">end</span> [<span class="function"><span class="keyword">function</span></span> [func_name]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> sub_name</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: ... <span class="comment">! 说明参数类型</span></span><br><span class="line">    <span class="keyword">end</span> [<span class="function"><span class="keyword">subroutine</span></span> [sub_name]]</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">interface</span>]</span><br></pre></td></tr></table></figure>
<p>使用函数的“使用接口”是一件很麻烦的事情，如果需要使用的函数很多，整个代码看起来非常烦杂。此外你需要在每一个你会使用到相关函数（涉及到以上五种情况）的子程序或者主程序中写清楚该函数的<code>interface</code>才可以。下一节将会介绍module的使用，其可以较少这个麻烦。</p>
<h2 id="不定个数的参数传递"><a href="#不定个数的参数传递" class="headerlink" title="不定个数的参数传递"></a>不定个数的参数传递</h2><p>一般来说，函数参数的个数都是由固定数目的，但在Fortran 90中可以使用<code>OPTIONAL</code>命令使某些参数变成可以“省略”的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">optional</span> :: var</span><br><span class="line"><span class="comment">! 在子程序（函数）以及主程序的interface模块中使用</span></span><br><span class="line"><span class="comment">! optional命令进行声明表示参数var可以省略不传入</span></span><br></pre></td></tr></table></figure>
<h2 id="改变参数传递位置的方法"><a href="#改变参数传递位置的方法" class="headerlink" title="改变参数传递位置的方法"></a>改变参数传递位置的方法</h2><p>这一点类似Python，当你按照变量的名称进行传递参数时，是可以不按照相应位置进行传入的：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(var1,var2,var3)</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 在调用该子程序时,按照变量名称传递参数</span></span><br><span class="line"><span class="keyword">call</span> sub(var3=<span class="number">3</span>,var2=<span class="number">2</span>,var1=<span class="number">1</span>)</span><br><span class="line"><span class="comment">! 其等价于：</span></span><br><span class="line"><span class="keyword">call</span> sub(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<div class="note seccess flat"><p>也许有时候我们需要设置函数参数的默认值，在Fortran中似乎没有什么好用的命令，但是通过在子程序中设置<code>if</code>结构依然可以做到相关的要求。即：做一个有无输入的逻辑判断，没有外界输入时就程序内部赋予一个默认值。</p>
</div>
<hr>
<h1 id="特殊的函数类型🍌"><a href="#特殊的函数类型🍌" class="headerlink" title="特殊的函数类型🍌"></a>特殊的函数类型🍌</h1><div class="note primary flat"><p>Fortran 90中，除了一般使用的正常函数之外，还可以特别指定成<code>RECURSIVE</code>、<code>PURE</code>、<code>ELEMENTAL</code>三种类型之一。<code>RECURSIVE</code>是让函数自己调用自己，也就是“递归”；后两者是用来做并行处理以及设置数组时使用的。</p>
</div>
<h2 id="递归（RECURSIVE）"><a href="#递归（RECURSIVE）" class="headerlink" title="递归（RECURSIVE）"></a>递归（<code>RECURSIVE</code>）</h2><p>能够递归的函数需要有一个必要条件，<span style='background: yellow;'>递归函数每次被调用执行时，函数中所声明的局部变量（非传递进来的参数或者没有做<code>save</code>的变量）都会使用不同的内存地址</span>。简单的说就是每次调用函数时变量都是独立存在的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> func(var) result(ans)</span><br><span class="line"><span class="comment">! 用recursive表示该函数可以递归</span></span><br><span class="line"><span class="comment">! result（ans）表示该函数的返回值用ans变量代替原来的fact</span></span><br><span class="line"><span class="comment">! result对于每一个自定义函数都可以使用，但是递归函数必须要有！</span></span><br></pre></td></tr></table></figure>
<p>在不设置<code>recursive</code>的时候，也可以用一种“间接递归”的方法来完成递归，也就是现在函数中调用另外一个函数，再在这另一个函数中调用自己，但是这种方法在某些编译器环境下会出现错误，因为它会把每次调用函数的局部变量放在同一个内存地址。</p>
<h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>Fortran 90可以定义某些函数只能在特定的函数中被调用，其基本结构为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main \ <span class="function"><span class="keyword">subroutine</span></span> sub \ <span class="function"><span class="keyword">function</span></span> func</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">contains</span> <span class="comment">! contains后面开始写局部函数</span></span><br><span class="line">        <span class="function"><span class="keyword">subroutine</span></span> localsub <span class="comment">! 这里的函数只能在包含它的函数中被调用</span></span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> localfunc <span class="comment">! 同样只能在包含它的函数中被调用</span></span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="PURE函数"><a href="#PURE函数" class="headerlink" title="PURE函数"></a><code>PURE</code>函数</h2><p>在函数声明前加上<code>pure</code>代码即可，但是使用pure函数有诸多限制：</p>
<ul>
<li>pure函数的参数必须都是只读<code>intent(in)</code>属性；</li>
<li>pure子程序的每一个参数都要赋予属性；</li>
<li>pure函数不能使用<code>save</code>；</li>
<li>pure函数中所包含的内部函数也必须全都是pure函数</li>
<li>pure函数中不能使用<code>stop</code> \ <code>print</code>及跟输入输出相关的命令（<code>read</code> \ <code>write</code> \ <code>open</code> \ <code>close</code> \ <code>backspace</code> \ <code>endfile</code> \ <code>rewind</code> \ <code>inquire</code>等等）</li>
<li>pure函数只能读取不能改变全部变量的值</li>
</ul>
<p>上面的这些限制，全部都是为防止在并行计算时出现一些奇怪的结果。比如说，同时执行A、B函数，两者都有在屏幕上输出信息的功能，这个时候就可能出现两个函数的结果混合在一起的错误结果。</p>
<h2 id="ELEMENTAL函数"><a href="#ELEMENTAL函数" class="headerlink" title="ELEMENTAL函数"></a><code>ELEMENTAL</code>函数</h2><p>使用方法和pure函数相同，也可以用来做并行计算，限制也与pure函数相同，除此之外它还多了一个功能，对数组进行设置（同时也多了一个限制：<span style='background: yellow;'>参数不能是数组</span>。），下面举个栗子🌰：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">10</span>)</span><br><span class="line">a=func(a)</span><br><span class="line"><span class="comment">! 如果func是一个elemental函数，这段程序与下面的循环等价：</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    a(i) = func(a(i))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="MODULE🍒"><a href="#MODULE🍒" class="headerlink" title="MODULE🍒"></a>MODULE🍒</h1><h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p><code>module</code>可以用来封装程序模块，通常用来把程序中具备相关功能的函数和变量封装到一起。其语法如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name <span class="comment">! 对模块的定义必须放到最前面</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">module</span> [module_name]]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> module_name <span class="comment">! 使用前面定义的模块</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub</span><br><span class="line">    <span class="keyword">use</span> module_name</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面的结构是在同一个文件中使用module模块，一般来说我们都是在一个代码文件中定义好所需要使用的函数和子程序，再在另一个文件中使用，这就类似于Python中的<code>import</code>模块的使用，这会在后面讲到。</p>
<h2 id="MODULE中的函数"><a href="#MODULE中的函数" class="headerlink" title="MODULE中的函数"></a>MODULE中的函数</h2><p>在MODULE中编写函数，其结构如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">    ... <span class="comment">! 先写声明相关程序代码</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">contains</span> <span class="comment">! contains 后开始写函数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> sub_name</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> [sub_name] <span class="comment">! subroutine 不能省</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> func_name</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> [func_name] <span class="comment">! function 不能省</span></span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">module</span>]</span><br></pre></td></tr></table></figure>
<p>还有一个比较方便的一点是：在同一个MODULE中，函数可以直接使用其他地方所声明的变量：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tool</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a <span class="comment">! 此处声明了a变量</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> add()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        a = a+<span class="number">1</span></span><br><span class="line">    ...</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<h2 id="一些不太常见的功能"><a href="#一些不太常见的功能" class="headerlink" title="一些不太常见的功能"></a>一些不太常见的功能</h2><h3 id="ENTRY"><a href="#ENTRY" class="headerlink" title="ENTRY"></a><code>ENTRY</code></h3><p><code>ENTRY</code>：为函数提供一个新的入口，举个栗子🌰:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span> sub</span><br><span class="line">    <span class="keyword">call</span> mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;hello.&quot;</span></span><br><span class="line">    <span class="built_in">entry</span> mid() <span class="comment">! 提供另一个入口</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Good morning!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.</span><br><span class="line">Good morning!</span><br><span class="line">Good morning!</span><br></pre></td></tr></table></figure>
<h3 id="RETURN"><a href="#RETURN" class="headerlink" title="RETURN"></a><code>RETURN</code></h3><p>特殊的<code>RETURN</code>：提供额外的折返点，举个栗子🌰：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> num</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*,*)<span class="string">&quot;please input a number：&quot;</span></span><br><span class="line">    read(*,*)num</span><br><span class="line">    <span class="keyword">call</span> sub_return(num,*<span class="number">1</span>,*<span class="number">2</span>) <span class="comment">! 具体的折返点输入形式：‘*’ + 行代码</span></span><br><span class="line">    <span class="built_in">write</span>(*,*)<span class="string">&quot;Default return&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">1</span> <span class="built_in">write</span>(*,*)<span class="string">&quot;Return 1&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">2</span> <span class="built_in">write</span>(*,*)<span class="string">&quot;Return 2&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub_return(num,*,*) <span class="comment">! 后面的‘*’号表示输入的折返点参数，几个‘*’表示几个折返点</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*)<span class="string">&quot;&gt;=0&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">! 返回到默认的折返点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; -<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;&lt;-1&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">! 返回到特定的第一个折返点（行代码为1的位置）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;-1&lt;=num&lt;0&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">! 返回到特定的第二个折返点（行代码为2的位置）</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>分别运行三次，输入不同的值，其运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"> please input a number：</span><br><span class="line">2</span><br><span class="line"> &gt;=0</span><br><span class="line"> Default return</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"> please input a number：</span><br><span class="line">-3</span><br><span class="line"> &lt;-1</span><br><span class="line"> Return 1</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"> please input a number：</span><br><span class="line">-0.5</span><br><span class="line"> -1&lt;=num&lt;0</span><br><span class="line"> Return 2</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="使用多个文件🥝"><a href="#使用多个文件🥝" class="headerlink" title="使用多个文件🥝"></a>使用多个文件🥝</h1><div class="note primary flat"><p>通常情况下，我们会把具有相关功能的函数编写到不同的文件中，这样做有以下几个好处：</p>
<ul>
<li>独立文件中的函数，可以拿给其他的程序使用；</li>
<li>减少单个程序中的代码（此时与<code>MODULE</code>类似）；</li>
<li>可以加快编译速度，修改其中一个文件时，编译器只需要重新编译这一个文件就好了（这一点要和编译器的使用结合起来）。</li>
</ul>
</div>
<h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a><code>INCLUDE</code></h2><p><code>INCLUDE</code>命令可以在程序代码中插入另一个文件中的内容。现在假如我有两个文件：“mian.f90”以及“sub.f90”，后者中含有前者所需要使用的子程序代码，我们只需要在前者的代码中（<strong>任何位置</strong>）加入：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">&#x27;sub.f90&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这样结果就相当于两个文件中的代码是写在同一个文件中的。</p>
<h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><p>具有特殊功能的一组函数，可以编译成”<em>.LIB”来给其他人使用。这样的文件经过编译，没有办法读出里面的初始程序代码，但可以通过`use </em>.LIB`的方法来使用其中的各种函数（与Python的函数库类似）。</p>
<hr>
<h1 id="写在最后🍈"><a href="#写在最后🍈" class="headerlink" title="写在最后🍈"></a>写在最后🍈</h1><div class="note seccess flat"><p>五百多行，四天时间，这大概是我写的最多的一次了</p>
<!-- ![我顶得住](https://file.tabirstrees.top/blogfile/EMO-wodingdezhu.jpg) --></div>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>编程</tag>
        <tag>函数语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran语言学习——数组</title>
    <url>/2021/09/03/fortran-array/</url>
    <content><![CDATA[<h1 id="1-基本使用🎃"><a href="#1-基本使用🎃" class="headerlink" title="1 基本使用🎃"></a>1 基本使用🎃</h1><h2 id="1-1-一维数组"><a href="#1-1-一维数组" class="headerlink" title="1.1 一维数组"></a>1.1 一维数组</h2><p>所谓数组，实际上是一种使用数据类型的方法，通常用于配合循环使用用以处理大量的数据。简单来说，数组可以一次性申明出一长串的相同数据类型的变量。</p>
<p>数组的声明方式如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Datatype    <span class="keyword">name</span> (<span class="built_in">size</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">! Datatype表示数组的类型,除了4种常用的类型(integer,real,complex,logical)以外,也可以用type自定义出新的类型</span></span><br><span class="line"><span class="comment">! name表示数组变量的名字</span></span><br><span class="line"><span class="comment">! size表示数组变量的大小</span></span><br></pre></td></tr></table></figure>
<p><em>注意: 在声明数组时,数组的大小只能使用常数来赋值, 包括直接填入数字或者使用声明为parameter的常数变量</em></p>
<p>数组所能够保存的数据大小由<code>size</code>决定, 对于<code>integer :: student(5)</code>这个数组来说, 可以保存5个整数, 取用这5个整数只需要用数组名加上括号内的索引值即可, 如:<code>student(1) = 89</code>的意思是将89赋予<code>student</code>这个数组变量的第一个元素. 数组的索引值不一定要使用常数, 也可以使用一般的变量. </p>
<div class="note danger flat"><p>使用数组时超出范围是很危险的事情, 在程序编译过程中不会检查数组的使用是否超出了范围, 所以要充分的杜绝这种情况的发生. </p>
</div>
<p>下面演示如何使用type函数自定义数组类型:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span> :: person</span><br><span class="line">    <span class="keyword">real</span> :: height,weight</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Type</span>(person) :: a(<span class="number">10</span>) <span class="comment">! 使用新定义的person变量做数组声明</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">! 同样在变量后加上&quot;%&quot;来使用person类型的相关属性</span></span><br><span class="line">a(<span class="number">2</span>)%height = <span class="number">180.0</span></span><br><span class="line">a(<span class="number">2</span>)%weight = <span class="number">70.0</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-二维数组与多维数组"><a href="#1-2-二维数组与多维数组" class="headerlink" title="1.2 二维数组与多维数组"></a>1.2 二维数组与多维数组</h2><p>很多时候涉及到数据的维度会多于一维, 在Fortran中声明数组大小的时候使用多个数字进行声明即可得到一个多维数组变量, 使用该变量则需要给出相应数量的索引值. 以二维数组举例:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>) <span class="comment">! 创建一个3×3的数组(类似于矩阵)</span></span><br><span class="line">a(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">3</span> <span class="comment">! 将3赋值到数组a的某一个元素</span></span><br></pre></td></tr></table></figure>
<div class="note danger flat"><p>同样注意不能超出数值所声明的范围!另外, Fortran中最多可以声明7维的数组,使用维度越高的数组, 程序执行时读取数据的速度也就越慢, 这并不意味着不要在程序中使用多维数组, 而是说使用多维数组时需要格外小心. </p>
</div>
<h2 id="1-3-数组声明的奇怪用法"><a href="#1-3-数组声明的奇怪用法" class="headerlink" title="1.3 数组声明的奇怪用法"></a>1.3 数组声明的奇怪用法</h2><p>在Fortran的数组中, 没有特别声明时, 数组的索引总是从1开始的:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="comment">! 这个数组能使用的元素包括a(1),a(2),a(3),a(4),a(5)</span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用一种奇怪的方法改变数组起始的索引值, 即在声明数组变量的大小时指定索引的范围:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>,<span class="number">0</span>:<span class="number">5</span>) <span class="comment">! a(1~5,0~5)是可以使用的元素</span></span><br><span class="line"><span class="keyword">integer</span> b(<span class="number">2</span>:<span class="number">3</span>,-<span class="number">1</span>:<span class="number">3</span>) <span class="comment">! b(2~3,-1~3)是可以使用的元素</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="2-数组内容的设置🎯"><a href="#2-数组内容的设置🎯" class="headerlink" title="2 数组内容的设置🎯"></a>2 数组内容的设置🎯</h1><h2 id="2-1-赋予初始值"><a href="#2-1-赋予初始值" class="headerlink" title="2.1 赋予初始值"></a>2.1 赋予初始值</h2><p>数组可以类似于一般变量利用<code>DATA</code>来设置数组的初始值:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>),b(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span>    a   /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>/</span><br><span class="line"><span class="comment">! 这样做数组的初始值设置为:a(1)=1,a(2)=2,a(3)=3,a(4)=4,a(5)=5</span></span><br><span class="line"><span class="keyword">data</span>    b   /<span class="number">3</span>*<span class="number">5</span>/</span><br><span class="line"><span class="comment">! &quot;*&quot;表示重复, 以上就是3重复五遍, 将数组的初始值全部设置为3</span></span><br></pre></td></tr></table></figure></p>
<p>另外有一种带有”隐含式”循环的初始值赋予方式:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> A(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> I</span><br><span class="line"><span class="keyword">DATA</span>(A(I), I=<span class="number">2</span>, <span class="number">4</span>)/<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>/</span><br><span class="line"><span class="comment">! 上面这行代码隐含着一个循环, I会从2增加到4, 并依照顺序取后面&quot;//&quot;中的数字, 也就是A(2)=2, A(3)=3, A(4)=4, A(5)和A(1)没有设置.</span></span><br></pre></td></tr></table></figure></p>
<div class="note primary flat"><p>上述的隐含式循环实际上是Fortran语言的一个特色，你可以在程序中正常的使用：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) (a(i),i=<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">! 显示a(2),a(3),a(4)的值</span></span><br></pre></td></tr></table></figure><br>后面再多加一个数字，可以改变计数器的累加数值，默认情况下为1：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(A(I), I=<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">! 循环执行5次，分别执行到I=2，4，6，8，10</span></span><br></pre></td></tr></table></figure><br>当然，隐含式的循环同样支持嵌套使用：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INTEGER</span> A(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">INTEGER</span> I,J</span><br><span class="line"><span class="keyword">DATA</span>((A(I,J), I=<span class="number">1</span>,<span class="number">2</span>), J=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="comment">! 其结果为A(1,1)=1, A(2,1)=2, A(1,2)=3, A(2,2)=4，括号内的循环会先执行</span></span><br></pre></td></tr></table></figure><br>Fortran 90中，DATA可以被省略：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line"><span class="comment">! 注意“/”与括号间不能留有空格</span></span><br><span class="line"><span class="comment">! 省略DATA时必须要给每一个元素都设置初始值，不能像有DATA时那样用隐含式循环只设置部分元素的初始值。</span></span><br></pre></td></tr></table></figure>
<p>Fortran 90的隐含式循环十分强大，它可以做到其他语言做不到的东西：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> ::Ｉ</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>)=(/(I,I=<span class="number">1</span>,<span class="number">5</span>)/)</span><br><span class="line"><span class="comment">! 其运行结果为a(n) = n, n=1,2,3,4,5</span></span><br></pre></td></tr></table></figure></div>
<h2 id="2-2-对整个数组的操作"><a href="#2-2-对整个数组的操作" class="headerlink" title="2.2 对整个数组的操作"></a>2.2 对整个数组的操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a=5</td>
<td style="text-align:center">a中所有元素全部赋值为5</td>
</tr>
<tr>
<td style="text-align:center">a=(/1, 2, 3/)</td>
<td style="text-align:center">a(1)=1, a(2)=2, a(3)=3</td>
</tr>
<tr>
<td style="text-align:center">a=b</td>
<td style="text-align:center">将a变成和b一样的数组，前提是a,b是维数、大小一样的数组</td>
</tr>
<tr>
<td style="text-align:center">a=b+c</td>
<td style="text-align:center">a, b, c是三个维数、大小一样的数组，a中某个位置的元素是b，c中相应位置的元素的和</td>
</tr>
<tr>
<td style="text-align:center">a=b-c</td>
<td style="text-align:center">类似上一条，只不过变成了b，c对应元素的差</td>
</tr>
<tr>
<td style="text-align:center">a=b*c</td>
<td style="text-align:center">类似，b，c的乘积</td>
</tr>
<tr>
<td style="text-align:center">a=b/c</td>
<td style="text-align:center">类似，b，c的商</td>
</tr>
<tr>
<td style="text-align:center">a=sin(b)</td>
<td style="text-align:center">a(i)=sin(b(i))，只要是内部的函数都可以这么用</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p>上述方法都是对整个数组进行操作的，并且涉及到两个元素之间的操作都是对应元素之间进行的，可以结合相应的矩阵运算进行理解。</p>
<h2 id="2-3-对部分数组的操作"><a href="#2-3-对部分数组的操作" class="headerlink" title="2.3 对部分数组的操作"></a>2.3 对部分数组的操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a(3:5)=(/3,4,5/)</td>
<td style="text-align:center">a(3)=3, a(4)=4, a(5)=5</td>
</tr>
<tr>
<td style="text-align:center">a(1:5:2)=3</td>
<td style="text-align:center">a(1)=3, a(3)=3, a(5)=3</td>
</tr>
<tr>
<td style="text-align:center">a(3:)=5</td>
<td style="text-align:center">a(3)以及之后的所有元素赋值为5</td>
</tr>
<tr>
<td style="text-align:center">a(1:3)=b(4:6)</td>
<td style="text-align:center">类似于这种的要求左右数组元素个数相同</td>
</tr>
<tr>
<td style="text-align:center">a(:)=b(:,2)</td>
<td style="text-align:center">a(1)=b(1,2), a(2)=b(2,2)，以此类推</td>
</tr>
</tbody>
</table>
</div>
<p>以上相当于利用索引值对数组进行切片，然后赋值，都是比较基础的用法。</p>
<h2 id="2-4-WHERE"><a href="#2-4-WHERE" class="headerlink" title="2.4 WHERE"></a>2.4 WHERE</h2><p><code>WHERE</code>也是对部分数组的操作，但将上节中的由坐标索引变成了逻辑判断来去除我们需要使用的元素<span class='heimu'>有点像<code>if</code>结构</span>：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>)</span><br><span class="line">    b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="comment">! 这里的where描述会把数组中数值小于3的元素找出来，并把这些元素的值设置给数组b同样位置的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 也可以省略‘end where&#x27;，写成：</span></span><br><span class="line"><span class="keyword">where</span> (a&lt;<span class="number">3</span>) b=a</span><br></pre></td></tr></table></figure></p>
<div class="note danger flat"><p>注意：<code>where</code>是用来设置数组的值的，所以它的程序模块中必须出现与设置数组相关的命令，并且在他的整个程序模块中出现的数组的大小和维度必须是一样的。同时类似于<code>if...else if...</code>，你也可以使用<code>ELSEWHERE</code>来处理逻辑处理中的其他情况，同时where语句也是可以支持嵌套使用的，基本上和if语句大同小异。</p>
</div>
<h2 id="2-5-FORALL"><a href="#2-5-FORALL" class="headerlink" title="2.5 FORALL"></a>2.5 FORALL</h2><p>FORALL也可以看成是一种隐含式循环来使用数组的方法：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">forall</span> (i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i)=i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="comment">! a(1)=1, a(2)=2, a(3)=3, a(4)=4, a(5)=5</span></span><br><span class="line"><span class="comment">! 其详细语法为：</span></span><br><span class="line"><span class="keyword">forall</span> (triplet1[, triplet2[, triplet3[, ...]]], mask)</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="comment">! tripletn指代数组的坐标索引范围，FORALL中可以赋值好几个triplet，这主要取决于数组的维度。</span></span><br><span class="line"><span class="comment">! mask指代条件判断语句，类似于if语句</span></span><br><span class="line"><span class="comment">! 下面举个例子：</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">forall</span> (I=<span class="number">2</span>:<span class="number">10</span>:<span class="number">2</span>,J=<span class="number">1</span>:<span class="number">5</span>，a(I,J)&lt;<span class="number">10</span>) <span class="comment">! 二维数组，只处理数组中范围内值小于10的元素</span></span><br><span class="line">    a(I,J)=I+J</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="comment">! 和if语句与where语句的情况一样，&#x27;end forall&#x27;也是可以省略的：</span></span><br><span class="line"><span class="keyword">forall</span>(I=<span class="number">1</span>:<span class="number">5</span>,J=<span class="number">1</span>:<span class="number">5</span>,a(I,J)/=<span class="number">0</span>) a(I,J)=<span class="number">1</span>/a(I,J)</span><br></pre></td></tr></table></figure></p>
<h1 id="3-数组的保存规则💾"><a href="#3-数组的保存规则💾" class="headerlink" title="3 数组的保存规则💾"></a>3 数组的保存规则💾</h1><p>在Fortran中，数组数据的保存是按照一定规则的，我们可以根据这个规则优化代码，编写出效率较高的程序。</p>
<p>拿一个二维数组举例：</p>
<blockquote>
<p>A(1,1)=&gt;A(2,1)=&gt;A(3,1)=&gt;A(1,2)=&gt;A(2,2)=&gt;A(3,2)=&gt;A(1,3)=&gt;A(2,3)=&gt;A(3,3)</p>
</blockquote>
<p>简单来说，最左边的元素会被最先填进内存。在写代码时可以充分利用这一点来提升代码的运行速度，尽量连续的读取数据，避免CPU跳跃式地在内存中读取数据。</p>
<h1 id="4-可变大小的数组🦐"><a href="#4-可变大小的数组🦐" class="headerlink" title="4 可变大小的数组🦐"></a>4 可变大小的数组🦐</h1><p>在Fortran 90中，提供了一种可以在程序执行后根据实际需求改变数组大小的功能：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> <span class="keyword">allocatable</span> :: a(:) <span class="comment">! 声明一个可变大小的数组</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: error</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students?&quot;</span></span><br><span class="line">read(*,*)students</span><br><span class="line"><span class="built_in">allocate</span>(a(students)，stat = error) <span class="comment">! 配置内存空间，stat用来查看配置内存是否成功：0-&gt;成功，其他-&gt;失败。</span></span><br><span class="line">deallocatable(a) <span class="comment">! 释放a的内存，结合上述代码可以重新定义数组的大小</span></span><br><span class="line"><span class="keyword">if</span> (.not. <span class="built_in">allocated</span>(a)) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">allocate</span>(a(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">! 检查数组a是否有配置内存，没有就请求5个元素的内存</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran语言学习——循环</title>
    <url>/2021/08/12/fortran-cycle/</url>
    <content><![CDATA[<!-- ![logo-fortran](https://file.tabirstrees.top/blogfile/logo-fortran.png) -->
<h1 id="🎉DO结构"><a href="#🎉DO结构" class="headerlink" title="🎉DO结构"></a>🎉DO结构</h1><!-- ![DO结构](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210710211357.png) -->
<p>在我们的程序编写过程中，经常会遇到需要将一部分代码重复很多遍的情况，为了使得代码简单提高可读性，可以用循环结构来进行处理，在Fortran中最常见的循环结构就是如上图所示的DO循环.</p>
<p>DO循环由计数器（用来决定执行循环次数的变量）的初值，终值以及增量三个部分组成（Fortran 90之后），每进行一次循环，计数器就会累加上前面设置的增量，当计数器超过终值时循环就会结束.</p>
<p>计数器的各项设定既可以用常量也可以用变量指定.下面是使用DO循环的一个例子（计算2+4+6+8+10）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0602</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> : : limit=<span class="number">10</span> <span class="comment">!计数器的上限</span></span><br><span class="line">    <span class="keyword">integer</span> counter <span class="comment">!计数器</span></span><br><span class="line">    <span class="keyword">integer</span> :: ans = <span class="number">0</span> <span class="comment">!拿来累加使用</span></span><br><span class="line">    <span class="keyword">do</span> counter=<span class="number">2</span>, limit ,<span class="number">2</span></span><br><span class="line">        ans = ans + counter</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>对于Fortran 77及以前版本的代码来说，没有直接使用<code>end do</code>来结束循环的说法（但是仍然有人在使用），而必须要在DO后面写清楚循环到哪一行结束.即<code>do 结束的行代码, 计数器变量初值, 终值, 增量</code>，同时在循环结束的那一行设置好行代码（通常来说这一行的代码不需要可执行的意义，正好可以用我们前一节学习的<code>continue</code>命令.）.</p>
<p>当结构中的<strong>增量</strong>使用<strong>负数</strong>时，终值需要比初值小，并且终止条件会变成计数器的值比终值小时就会结束循环.</p>
<p>同时，结构中初值，终值，增量等如果使用变量指定时，只会在循环开始时进行一次读取，在循环过程中改变变量的值对循环是不会产生影响的，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">s=<span class="number">1</span></span><br><span class="line">e=<span class="number">10</span></span><br><span class="line">inc=<span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> i=s, e, inc</span><br><span class="line">    s=<span class="number">5</span></span><br><span class="line">    e=<span class="number">1</span></span><br><span class="line">    inc=-<span class="number">1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<h1 id="🎉DO-WHILE-结构"><a href="#🎉DO-WHILE-结构" class="headerlink" title="🎉DO WHILE 结构"></a>🎉DO WHILE 结构</h1><p>某些时候我们会遇到更加复杂的情况，循环变量的增加可能不是线性的，或者需要在循环过程中根据情况特别指定增加方式，这个时候我们可以使用一个逻辑判断来进行循环的指定（当该判断的逻辑值为1时则循环，逻辑值为0时停止循环，即直到不满足条件为止一直循环下去）：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> whilw (逻辑运算) <span class="comment">! 逻辑运算成立时,会一直重复执行该循环</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> <span class="comment">! 结束循环的命令</span></span><br></pre></td></tr></table></figure>
<p>相对于<code>DO</code>结构的循环而言,该结构最大的优势就是可以在循环过程中改变循环变量的值,这样就适应了更加复杂的情况.</p>
<h1 id="🎊循环的流程控制"><a href="#🎊循环的流程控制" class="headerlink" title="🎊循环的流程控制"></a>🎊循环的流程控制</h1><p>主要是介绍两个与循环有关的命令:<code>CYCLE</code>,<code>EXIT</code>,类似于Python中的<code>continue</code>以及<code>break</code>.</p>
<h2 id="🎨CYCLE"><a href="#🎨CYCLE" class="headerlink" title="🎨CYCLE"></a>🎨CYCLE</h2><p><code>CYCLE</code>命令可以直接跳过循环的某一个部分,也就是说<code>CYCLE</code>后面的代码将会不被执行而直接跳入到下一个循环中.比如:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="built_in">floor</span>=<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">floor</span> = <span class="number">4</span>) <span class="keyword">cycle</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">floor</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>执行结构将会列出从1到9的数字(除了4以外),因为当<strong>floor=4</strong>时被<code>cycle</code>语句跳过执行<code>write(*,*) floor</code>.</p>
<h2 id="🎨EXIT"><a href="#🎨EXIT" class="headerlink" title="🎨EXIT"></a>🎨EXIT</h2><p>使用<code>EXIT</code>命令将跳出整个循环,也就是说当出现<code>EXIT</code>后循环将不再执行,通常出现在你并不知道需要执行多少次循环,于是设置为永久循环的情况:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>( .true. ) <span class="comment">! 如果没有exit命令程序将永远执行下去</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;weight:&#x27;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess-weight) &lt; error ) <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> <span class="comment">!前面已经预先声明好了以上出现的三个变量.</span></span><br></pre></td></tr></table></figure>
<p>以上,当<code>guess</code>与<code>weight</code>的值相差在误差范围内时,循环结束.</p>
<hr>
<div class="note success flat"><p>在Fortran中还可以为循环署名,这样可以明确最后的<code>end do</code>命令是对哪一个循环执行的:<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">outter: <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="comment">! 该循环署名为outter</span></span><br><span class="line">    inner: <span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="comment">! 该循环署名为inner</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> inner <span class="comment">! 结束内循环inner</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> outter <span class="comment">! 结束外循环outter</span></span><br></pre></td></tr></table></figure></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>编程</tag>
        <tag>循环语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran语言学习——流程控制与逻辑运算</title>
    <url>/2021/07/07/fortran-logic-compute/</url>
    <content><![CDATA[<!-- ![Fortran](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210707235432.png) -->
<div class="note primary flat"><p>我们假设大家都有一定的编程基础，至少知道编程过程中流程控制是什么意思（<span class="heimu">其实也没啥意思，就是条件语句之类的</span>）。另外把实际的例子的代码省去，这样更加精简的作为字典或者文档查询更加方便。</p>
</div>
<h1 id="1-IF语句"><a href="#1-IF语句" class="headerlink" title="1.IF语句"></a>1.IF语句</h1><p>首先第一个我们需要接触的就是if条件语句，在Fortran语言中一般这样写：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (逻辑判断式) <span class="keyword">then</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>举个书上的例子，我们写一个速度超过一百就会发出警报的简单程序：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(speed&gt;<span class="number">100</span>)<span class="keyword">then</span></span><br><span class="line">    <span class="comment">! speed &gt; 100时才会执行下面的语句</span></span><br><span class="line">    <span class="built_in">write</span>(*,*)<span class="string">&quot;Slow down.&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">stop</span></span><br></pre></td></tr></table></figure><br>注意该程序知识一部分而已，前面变量的申明还是要照样做的。另外除此之外还可以简写成如下的形式：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (speed&gt;<span class="number">100</span>) <span class="built_in">write</span>(*,*) <span class="string">&quot;Slow down.&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><p>除此之外呢，我们可能还需要设置不满足条件时应该执行的语句，或者是有其他很多种情况的分支，这个时候就需要这么写：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) <span class="keyword">then</span> <span class="comment">! 情况1</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) <span class="keyword">then</span> <span class="comment">! 情况2</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">3</span>) <span class="keyword">then</span> <span class="comment">! 情况3</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="comment">! 以上情况都不满足的情况</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑判断符号以及集合判断符号"><a href="#逻辑判断符号以及集合判断符号" class="headerlink" title="逻辑判断符号以及集合判断符号"></a>逻辑判断符号以及集合判断符号</h2><p>另外补充以下在Fortran中表示逻辑判断以及集合判断的方式:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">表示含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">相等</td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center"><code>.and.</code></td>
<td style="text-align:center">交集</td>
</tr>
<tr>
<td style="text-align:center"><code>.or.</code></td>
<td style="text-align:center">并集</td>
</tr>
<tr>
<td style="text-align:center"><code>.not.</code></td>
<td style="text-align:center">不成立</td>
</tr>
<tr>
<td style="text-align:center"><code>.eqv.</code></td>
<td style="text-align:center">逻辑运算相等</td>
</tr>
<tr>
<td style="text-align:center"><code>.neqv.</code></td>
<td style="text-align:center">逻辑运算不相等</td>
</tr>
</tbody>
</table>
</div>
<p>以上，逻辑判断的运算等级高于集合运算的等级，同时出现时先执行逻辑判断（大于小于等于之类的）的语句。</p>
<h2 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h2><p>当存在if语句的嵌套使用时，可以这样：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) <span class="keyword">then</span> <span class="comment">! 第一层</span></span><br><span class="line">	<span class="keyword">if</span> (...) <span class="keyword">then</span> <span class="comment">! 第二层</span></span><br><span class="line">		<span class="keyword">if</span> (...) <span class="keyword">then</span> <span class="comment">! 第三层主条件</span></span><br><span class="line">			...</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (...) <span class="keyword">then</span> <span class="comment">! 第三层次条件</span></span><br><span class="line">			...</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">! 第三层其余情况</span></span><br><span class="line">			...</span><br><span class="line">		<span class="keyword">end</span> <span class="keyword">if</span> <span class="comment">! 第三层结束</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span> <span class="comment">! 第二层结束</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> <span class="comment">! 第一层结束</span></span><br></pre></td></tr></table></figure>
<h1 id="2-浮点数以及字符的逻辑运算"><a href="#2-浮点数以及字符的逻辑运算" class="headerlink" title="2.浮点数以及字符的逻辑运算"></a>2.浮点数以及字符的逻辑运算</h1><h2 id="浮点数的逻辑判断"><a href="#浮点数的逻辑判断" class="headerlink" title="浮点数的逻辑判断"></a>浮点数的逻辑判断</h2><p>我们知道，由于计算机运行方式以及内存情况的限制，当我们进行浮点数之间的计算时通常是带有误差的，比如：$a=\sqrt{b}^2-b = 0$在实际的运算过程中可能会出现$a$不等于0的情况，这是因为计算机在计算浮点数时的有效位数的问题造成的。举个例子，$\sqrt{3}$在计算时只能采用有限的位数来保存，这个时候就会出现误差，再将这个存在误差的数字作幂次运算，等到的结果必然不会是3，而是一个接近3的数字。</p>
<p>如果我们需要对类似这样的情况作出判断，（判断$\sqrt{b}^2-b$是否等于0），就需要对我们的结果预留出一些误差的空间。这样，我们可以把上面的过程写成如下的形式：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> example</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">real</span> :: b = <span class="number">4.0</span></span><br><span class="line">	<span class="keyword">real</span> :: a</span><br><span class="line">	<span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.0001</span> <span class="comment">! 表示误差的范围</span></span><br><span class="line">	a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span>-b</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">abs</span>(a-<span class="number">0.0</span>) &lt;= e) <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">write</span>(*,*) <span class="string">&quot;a等于0！&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0！&quot;</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="字符的逻辑判断"><a href="#字符的逻辑判断" class="headerlink" title="字符的逻辑判断"></a>字符的逻辑判断</h2><p>和Python一样，字符甚至字符串之间也是可以用来做逻辑判断的，这实际上使用的字符转换成ASCII码之后的数值进行的逻辑判断。比如说判断<code>&#39;A&#39; &lt; &#39;a&#39;</code>为<code>true</code>是因为a的ASCII码为97，A的ASCII码为65。</p>
<p>需要注意的是，当字符串作比较时，实际上比较的是第一个字符的ASCII码，如果第一个字符相同就比较第二个字符，依此类推。</p>
<h1 id="SELECT-CASE语句"><a href="#SELECT-CASE语句" class="headerlink" title="SELECT CASE语句"></a>SELECT CASE语句</h1><p>实际上，在我们需要使用多重判断时，有一种可以代替<code>IF ... ELSE IF ...</code>的语句，那就是SELECT　CASE语句，下面是该语句的用法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(变量) <span class="comment">!　这里的变量是指需要进行判断的变量</span></span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">1</span>)</span><br><span class="line">...... <span class="comment">! 当变量的数值等于数值1时，就执行该语句</span></span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">2</span>)</span><br><span class="line">...... <span class="comment">! 变量等于数值2时，执行该语句</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">...... <span class="comment">! 默认情况下，即变量不等于任何数值时，执行该语句</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br></pre></td></tr></table></figure>
<p><code>slecet default</code>模块不是必要的，在<code>case</code>里面的数值设置可以设置成范围，即类似<code>2：5</code>表示2~5的数值范围，同时也支持类似<code>1，3，5</code>表示变量值等于三者中的任何一个时都会执行其所属的语句。</p>
<p>值得注意的是，使用<code>select case</code>语句会有一些限制：</p>
<ol>
<li>只能使用整数、字符、以及逻辑变量类型的变量，对于浮点数和复数就只能用<code>if ... else if</code>的结构；</li>
<li>每一个case中所使用的数值必须是固定的常量，而不能是变量。</li>
</ol>
<h1 id="其他控制流程"><a href="#其他控制流程" class="headerlink" title="其他控制流程"></a>其他控制流程</h1><h2 id="GOTO命令"><a href="#GOTO命令" class="headerlink" title="GOTO命令"></a>GOTO命令</h2><p>实际上，GOTO语法是Fortran 77时代；留下来的“旧时代”的语法，一般不建议使用，因为它会破坏代码的结构，导致代码的阅读变得比较困难，但是某些上世纪写的程序中还会留有这样的结构，所以仍然需要了解。</p>
<p>在Fortran语言中，可以给每一行代码赋予一个特定的编号，利用GOTO命令就可以提供给程序员一个可以使程序任意跳跃到所赋值编号的那一行程序所在位置来执行的能力。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">	  <span class="function"><span class="keyword">PROGRAM</span></span> ex0514</span><br><span class="line">	  <span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">	  <span class="keyword">REAL</span> height <span class="comment">! 记录身高</span></span><br><span class="line">	  <span class="keyword">REAL</span> weight <span class="comment">! 记录体重</span></span><br><span class="line"></span><br><span class="line">	  <span class="built_in">WRITE</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">	  READ (*,*)	height <span class="comment">! 读入身高</span></span><br><span class="line">	  <span class="built_in">WRITE</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">	  READ (*,*)	weight <span class="comment">! 读入体重</span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">IF</span> ( weight &gt; height-<span class="number">100</span> ) <span class="keyword">GOTO</span> <span class="number">200</span></span><br><span class="line">	  <span class="comment">! 上面不成立，没有跳到200才会执行这里</span></span><br><span class="line"><span class="number">100</span>   <span class="built_in">WRITE</span>(*,*) <span class="string">&quot;Under control.&quot;</span></span><br><span class="line">	  <span class="keyword">GOTO</span> <span class="number">300</span> <span class="comment">! 下一行不能执行所以要跳到300 .</span></span><br><span class="line"><span class="number">200</span>	  <span class="built_in">WRITE</span>(*,*) <span class="string">&quot;Too fat!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">300</span>   <span class="keyword">STOP</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>如果GOTO结构可以用得比较巧妙，这样的话可以利用<code>IF</code>+<code>GOTO</code>结构来写一个类似循环的过程，或者利用类似<code>GOTO(10,20,30) a</code>（其中a表示变量，用以指代前面括号中的列表的序列切片，即1表示10，2表示20，3表示30）的结构进行有选择的跳转。<span class = "heimu">看不懂也没关系，反正就是不建议使用就对了</span></p>
<div class="note danger flat"><p>最后再强调一遍，虽然GOTO结构看起来很强大，但是并不建议使用，因为这会使得代码的结构混乱，不便于阅读和维护。</p>
</div>
<h2 id="PAUSE-CONTINUE-STOP"><a href="#PAUSE-CONTINUE-STOP" class="headerlink" title="PAUSE, CONTINUE, STOP"></a>PAUSE, CONTINUE, STOP</h2><p>PAUSE 暂停，表示程序执行到该代码之后会暂停，知道用户按下Enter键之后程序才会继续执行。可以应用到程序需要做很多页的输出时，在每一页设置暂停，直到用户看完每一页的内容之后再按Enter键进行翻页。</p>
<p>CONTINUE 继续，没什么用，Fortran 90之后就不怎么使用了，基本上可以不管，因为它没有什么实际意义，只是为了方便阅读而已。</p>
<p>STOP 停止，很明显，执行完该代码程序就停止了，可以用来作为程序得到不合理的输入时将程序终止。</p>
<hr>
<!-- 研究生通知书到了，趁这里没人，独自高兴一波hahaha！
![1625667151163](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/1625667151163.jpg) -->]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>Fortran</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Description of Approaches in T-PROGS</title>
    <url>/2021/05/19/fangfamiaoshu-of-T-PROGS/</url>
    <content><![CDATA[<div class="note primary flat"><p>在T-PROGS中提供了五种方法方便我们构建马尔科夫链的转移概率矩阵，这五种方法各自适用于不同的情况，并且在操作上有着比较大的区别，现在通过对T-PROGS操作手册的翻译来大致介绍一下每一种方法的情况。测试</p>
</div>
<h1 id="T-PROGS中各种方法的具体描述"><a href="#T-PROGS中各种方法的具体描述" class="headerlink" title="T-PROGS中各种方法的具体描述"></a>T-PROGS中各种方法的具体描述</h1><hr>
<h2 id="转移率方法"><a href="#转移率方法" class="headerlink" title="转移率方法"></a>转移率方法</h2><p>所谓转移率就是计算连续转移概率矩阵的方程所提到的转移率矩阵$R_\phi$的输入元素。转移率可以被解释为转移概率在滞后距离为零时的斜率。因此，一个建立转移率矩阵的方法需要估计转移概率数据的斜率：$\frac{\partial t_{jk}(h \rightarrow 0)}{\partial h_\phi}$ ，对于一个四分类的例子来说（debris flow, floodplain, levee, channel）转移率矩阵可以被建立为:</p>
<script type="math/tex; mode=display">
\mathbf{R}_{z}=\left[\begin{array}{cccc}
-0.87 & * & 0.10 & 0.066 \\
* & * & * & * \\
0.030 & * & -1.23 & 0.12 \\
0.039 & * & 0.79 & -0.82
\end{array}\right] \mathrm{m}^{-1}</script><p>其中非背景分类的部分是可以改变的，但是需要遵守一定的概率原则；含有背景分类的部分不能改变，程序会自动调整以满足前述概率原则。值得注意的是，对角线元素是负数，非对角线元素是非负的（这是和自转移以及协转移相关的，自己转移到自己的概率随着滞后距离的增加必定是减小的，而两个不同分类之间的转移随着滞后距离的增加自然是增加的，而转移率实际上就是转移概率的斜率，自然会满足上面的条件）。</p>
<hr>
<h2 id="使用某一特定滞后距离转移概率数据的离散滞后距离方法"><a href="#使用某一特定滞后距离转移概率数据的离散滞后距离方法" class="headerlink" title="使用某一特定滞后距离转移概率数据的离散滞后距离方法"></a>使用某一特定滞后距离转移概率数据的离散滞后距离方法</h2><p>MCMOD使用特征分析的方法来从特殊滞后距离的转移概率数据中建立转移率矩阵，其中$\Delta h_\phi$将在两者(两种岩性)相关的距离内选取，例如下面这个垂向的转移概率矩阵：</p>
<script type="math/tex; mode=display">
\mathbf{T}\left(\Delta h_{z}=0.6 \mathrm{~m}\right)=\left[\begin{array}{llll}
0.6182 & 0.2892 & 0.0529 & 0.0397 \\
0.0325 & 0.8061 & 0.0787 & 0.0826 \\
0.0192 & 0.3817 & 0.5258 & 0.0727 \\
0.0168 & 0.0995 & 0.2359 & 0.6478
\end{array}\right]</script><p>通过这个特定距离的转移概率（离散）计算出转移率，再通过转移率计算出连续的转移概率。</p>
<hr>
<h2 id="内嵌马尔科夫链分析的转移概率方法"><a href="#内嵌马尔科夫链分析的转移概率方法" class="headerlink" title="内嵌马尔科夫链分析的转移概率方法"></a>内嵌马尔科夫链分析的转移概率方法</h2><p>内嵌马尔可夫链分析是估计分离的地质单元事件发生在临近的另一个地质单元特定方向上的条件概率（通俗一点说就是某一个方向上，A分类出现在B分类之后的条件概率）。举个例子，对于上述的四分类系统中，内嵌转移概率$\pi_{jk,\phi}$在垂直方向$(z)$上被定义为：</p>
<script type="math/tex; mode=display">
\pi_{43,\phi} = Pr\{levee \ occurs \ above \ | \ channel\  occurs\ below \}</script><p>因此内嵌转移概率矩阵$\boldsymbol{\Pi}_{z}$可以被构建为：</p>
<script type="math/tex; mode=display">
\boldsymbol{\Pi}_{z}=\left[\begin{array}{cccc}
- & 0.803 & 0.124 & 0.073 \\
0.176 & - & 0.390 & 0.434 \\
0.026 & 0.846 & - & 0.128 \\
0.045 & 0.058 & 0.896 & -
\end{array}\right]</script><p>注意，对角线上的自转移被视为无法观测到的，因此，对角线上的输入元素是空着的。从解释的观点来说，(4)式中$\pi_{43,z} &gt;&gt; \pi_{41,z}$以及$\pi_{43,z} &gt;&gt; \pi_{42,z}$意味着levee相对来说趋向于出现在channel的上面。</p>
<p>如果有岩层更进一步的平均长度$\overline{L}_{j,z}$的信息，那么内嵌转移概率（通过频率来估计的）可以通过下式转化为转移率矩阵：</p>
<script type="math/tex; mode=display">
r_{jk,z} = \frac{\pi_{jk,z}}{\overline{L}_{j,z}}\\
r_{jj,z} = - \frac{1}{\overline{L}_{j,z}}</script><p>因此，开发转移率矩阵的方法步骤是：</p>
<ol>
<li>根据并置趋势的地质解释或者数据建立内嵌转移概率矩阵；</li>
<li>建立平均长度；</li>
<li>根据(5)式将内嵌转移概率转化为转移率。</li>
</ol>
<p>注意非对角线元素需要满足:</p>
<script type="math/tex; mode=display">
\sum^K_{k = 1}\pi_{jk,z} = 1</script><p>如果设定了背景类别，矩阵中包含了背景类别的行列元素就不需要精确规定（可以将它们设置为零），这样根据内嵌转移概率以及平均长度改进后的转移率矩阵$R_z$为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
\bar{L}_{1, z}=1.15 & * & 0.12 & 0.075 \\
* & * & * & * \\
0.025 & * & \bar{L}_{3, z}=0.82 & 0.10 \\
0.04 & * & 0.96 & \bar{L}_{4, z}=1.24
\end{array}\right]</script><p>其中第2各分类被设置为背景类别，这就是为什么含有该类别的元素被设定成了任意值，由此建立的马尔科夫链如下图所示：</p>
<p><img src="https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210518114127.png" alt="很遗憾，图片丢失了(┬┬﹏┬┬)"></p>
<p>可以看到，由内嵌转移概率方法对测量转移概率的拟合相对初试模型（最大熵因子法）来说稍稍更好一点。</p>
<hr>
<h2 id="内嵌马尔科夫链分析的转移频率方法"><a href="#内嵌马尔科夫链分析的转移频率方法" class="headerlink" title="内嵌马尔科夫链分析的转移频率方法"></a>内嵌马尔科夫链分析的转移频率方法</h2><p>所谓内嵌转移频率（垂直方向上）被定义为：</p>
<script type="math/tex; mode=display">
f_{43,z} = Pr\{ levee\ occurs\ above\ {\bf and} \ channel\ occurs\ below\}</script><p>于是内嵌转移频率矩阵$F_z$可以被表示为：</p>
<script type="math/tex; mode=display">
\mathbf{F}_{z}=\left[\begin{array}{llll}
(0.0841) & 0.0677 & 0.0101 & 0.0063 \\
0.0672 & (0.3468) & 0.1264 & 0.1713 \\
0.0085 & 0.2971 & (0.3395) & 0.0340 \\
0.0085 & 0.0000 & 0.2031 & (0.2115)
\end{array}\right]</script><p>其中对角线元素（插入的部分）是对应$j$类别嵌入事件的边缘频率$f_{j,z}$的行列之和：</p>
<script type="math/tex; mode=display">
f_{j,z} = \sum^K_{k \not= j}f_{jk,z} = \sum^K_{j \not= k}f_{kj,z}</script><p>再加上平均长度$\overline{L}_{j,z}$的信息，转移频率可以转化为转移率通过：</p>
<script type="math/tex; mode=display">
r_{jk,z} = \frac{f_{jk,z}}{f_{j,z} \overline{L}_{j,z}} \quad \forall k \neq j</script><p>类似内嵌转移概率，MCMOD同样可以由转移频率构建出转移率矩阵的非对角线部分的元素：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
\bar{L}_{1, z}=1.15 & * & 0.0101 & 0.0063 \\
* & \bar{L}_{1, z}=2.27 . & * & * \\
0.0085 & * & \bar{L}_{3, z}=0.82 & 0.0340 \\
0.0085 & * & 0.2031 & \bar{L}_{4, z}=1.24
\end{array}\right]</script><p>尽管非对角线元素并不需要额外的设定，但是这个方法需要背景类别的平均长度，因为边缘频率依赖于各个类别的比例以及平均长度。</p>
<hr>
<h2 id="“独立性”或者“最大熵因子（无序）”转移频率方法"><a href="#“独立性”或者“最大熵因子（无序）”转移频率方法" class="headerlink" title="“独立性”或者“最大熵因子（无序）”转移频率方法"></a>“独立性”或者“最大熵因子（无序）”转移频率方法</h2><p>地质系统的并置趋势反映了地层序列的有序或者无序的程度，地层之间转移频率$f_{jk,\phi}$（某一种地层紧挨着其他地层的概率）的熵因子$S_{\phi}$可以量化某一特殊方向$\phi$上的并置趋势的无序性，其中熵因子定义（参考“熵分析方法”）为：</p>
<script type="math/tex; mode=display">
S_{\phi} = - \sum_j \sum_k f_{jk,\phi} \ln{f_{jk,\phi}}</script><p>考虑一个问题，“最大程度无序的系统来说，地层应该是什么样的呢？”。从我们所参考的状态来说，其中一个答案可能是能够判断出观察到的地层序列显示非随机的并置趋势或者说是一定程度上的有序。</p>
<p>在应用内嵌马尔科夫链分析时，地质学家将兴趣放在量化他们对用地质相连续性的解释上，尤其是在垂直方向上。四种类别岩性连续性的“随机”或者独立的转移频率为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{llll}
f_{1} f_{1} & f_{1} f_{2} & f_{1} f_{3} & f_{1} f_{4} \\
f_{2} f_{1} & f_{2} f_{2} & f_{2} f_{3} & f_{1} f_{4} \\
f_{3} f_{1} & f_{3} f_{2} & f_{3} f_{3} & f_{3} f_{4} \\
f_{4} f_{1} & f_{4} f_{2} & f_{4} f_{3} & f_{4} f_{4}
\end{array}\right]</script><p>其中$f_i$代表连续出现$i$类别的“边缘”频率，但在实际操作中这个问题并不简单。通常来说，自转移的情况是无法观察到的（尤其是对于钻孔数据来说），所以不仅仅是对角线上的转移频率，就连边缘频率也是没有办法直接估计的。而非对角线上的转移_计数_是可以被精确估计的，因为协转移（不同类别之间的转移）是可以观察到的。</p>
<p>假设自转移观察不到，一个更加实际的问题就被暴露出来了。于是，取而代之的是，非对角转移频率$\eta_{jk}$的观测值，被定义为转移计数除以所有非对角转移计数的总和：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{llll}
- & \eta_{12} & \eta_{13} & \eta_{14} \\
\eta_{21} & - & \eta_{23} & \eta_{24} \\
\eta_{31} & \eta_{32} & - & \eta_{34} \\
\eta_{41} & \eta_{42} & \eta_{43} & -
\end{array}\right]</script><p>其中，自转移无法观察到，所以留为空白。</p>
<p>独立转移频率的目标是找到满足以下条件的$f_i$：</p>
<script type="math/tex; mode=display">
\frac{1}{T} \sum^K_{j \neq i} f_i f_j = \sum_{j \neq i}^K \eta_{ij} \quad \forall i = 1,...,K\\
T = \sum^K_{i = 1}\sum^K_{i \neq j} f_i f_j</script><p>上式的非线性系统可以通过IPF（iterative proportion fitting)方法解决。生成的独立模型将显示嵌入事件$\eta_i$的相同边缘频率：</p>
<script type="math/tex; mode=display">
\eta_{i}=\sum_{j \neq i}^{K} \eta_{i j} \quad \forall i=1, \ldots, K</script><p>以上，与$f_i$对应的非对角线转移频率将会是独立的。通过将$\eta_i$与比例$p_i$除以平均长度$\bar{L}_i$成比例，可以将连续滞后马尔可夫链模型与该独立性模型联系起来：</p>
<script type="math/tex; mode=display">
\frac{p_{i}}{L_{i}} \propto \eta_{i} \quad \forall i=1, \ldots, K</script><p>因此，给定比例和平均长度的设定，就可以得到一个包含独立转移频率的连续滞后马尔科夫链。</p>
<p>因此一个特殊的问题出现了，“对于给定的比例和平均长度，什么是使得熵最大的转移频率矩阵呢？”巧合的是统计独立性的概念正好与最大熵的结果是一致的。在先前的例子中，比例和平均长度对应的独立或者最大熵转移频率矩阵$F_z^{(S\ max)}$为</p>
<script type="math/tex; mode=display">
\mathbf{F}_{z}^{(S \max )}=\left[\begin{array}{cccc}
(0.0841) & 0.0377 & 0.0311 & 0.0152 \\
0.0377 & (0.3671) & 0.2196 & 0.1075 \\
0.0311 & 0.2196 & (0.3396) & 0.0888 \\
0.0152 & 0.1075 & 0.0888 & (0.2115)
\end{array}\right]</script><p>其中对角线元素代表某一行或者某一列的边缘频率的总和。这个矩阵可以用来作为解释在相同比例和平均长度的情况下与最大无序程度的地层连续性相关的并置趋势的基础。例如，如果观测到的转移频率$f_{43,z}$比$f_{z}^{(S\ max)}$更大，一个可能的推断是此处_levee_出现在_channel_的上方是具有统计趋势的.</p>
<p>综上所述，开发转移率矩阵有以下的步骤：</p>
<ol>
<li>建立各类别的比例和平均长度；</li>
<li>计算最大熵因子转移频率矩阵$F_{z}^{(S\ max)}$以及相应的转移率；</li>
<li>解释相对于最大熵因子转移率的非对角转移率。</li>
</ol>
<p>举个例子里说，根据（11），最大熵因子转化率$r_{jk,z}^{(S\ max)}$可以通过下式计算：</p>
<script type="math/tex; mode=display">
r_{j k, z}^{(S \max )}=\frac{f_{j k, z}^{(S \max )}}{\bar{L}_{j, z} \sum_{k \neq j} f_{j k, z}^{(S \max )}}</script><p>最大熵转移率对应的垂向转移率矩阵表示为：</p>
<script type="math/tex; mode=display">
\mathbf{R}_{z}^{(S \max )}=\left[\begin{array}{llll}
\frac{-1}{\bar{L}_{1, z}=1.15 \mathrm{~m}} & 1.80 r_{12, z}^{(S \max )} & 0.32 r_{13, z}^{(S \max )} & 0.41 r_{14, z}^{(S \max )} \\
1.78 r_{21, z}^{(S \text { max })} & \frac{-1}{\bar{L}_{2, z}=2.27 \mathrm{~m}} & 0.58 r_{23, z}^{(S \max )} & 1.59 r_{24, z}^{(S \max )} \\
0.27 r_{31, z}^{(S \max )} & 1.35 r_{32, z}^{(S \max )} & \frac{-1}{\bar{L}_{3, z}=0.82 \mathrm{~m}} & 0.45 r_{34, z}^{(S \max )} \\
0.56 r_{41, z}^{(S \max )} & 0.00 r_{42, z}^{(S \max )} & 2.29 r_{43, z}^{(S \max )} & \frac{-1}{\bar{L}_{4, z}=1.24 \mathrm{~m}}
\end{array}\right]</script><p>这样计算出来的非对角线上的元素通过系数乘以$r_{jk,z}^{(S\ max)}$得到，如果比1小则表示两个类别具有并置趋势（在某个方向上某一分类通常紧挨着另一分类出现）小于1时则不具有并置趋势。</p>
<p>最大熵的概念在解释已存在的马尔科夫链模型的并置趋势时是非常有用的。举个例子，你可以通过比例和平均长度建立一个已存在的模型，比如说（11），然后生成一个马尔科夫链，它有着最大程度的无序的并置趋势。再与转移概率方法进行比较，从而解释地层是否展现出了一定程度的有序并置趋势。在这过程中必须要给定全部类别的平均长度，包括背景类别。</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>地下水数值模拟</category>
      </categories>
      <tags>
        <tag>GMS</tag>
        <tag>地统计</tag>
        <tag>转移概率</tag>
      </tags>
  </entry>
  <entry>
    <title>地下水数值模拟软件获取以及相关教程</title>
    <url>/2021/02/06/gmssoftware/</url>
    <content><![CDATA[<!-- ![GMS](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/16213678437069085683738921793155.jpg) -->
<p>由于毕业论文做T-PROGS与MODFLOW的结合来模拟地下水水流运动的研究，需要学习地下水模拟相关方面的的软件。在这个过程中也走不少的弯路，经过一番折腾，终于在网上找到了一些非常好的入门资料。为了方便之后的有需要的人<del>(估计只有我这样的菜鸡才会需要了┭┮﹏┭┮)</del> ，我把我能找的所有资料罗列出来，以便查阅！</p>
<span id="more"></span>
<h1 id="GMS"><a href="#GMS" class="headerlink" title="GMS"></a>GMS</h1><p>关于GMS（Groundwater Modeling System）其实就是一些常见的地下水数值模拟软件的集合体，包括下面会出现的MODFLOW以及一些<del>我没有用到的</del>其他软件包。该软件由Aquaveo, LLC.发行，国内好像是北水国际公司代理的<div class="heimu"> 啊，这个我不清楚！我乱说的</div>。可以从<a href="https://www.aquaveo.com/software/gms-groundwater-modeling-system-introduction">Aquaveo</a>的官网上下载到的最新版本（目前是10.5.6），除了免费的Community版本以外好像都还挺贵的。</p>
<!-- ![GMS](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20210110170550.png) -->
<p>为此，几番周折之后我找到了含有破解版的10.4.5版本，将其放到了我的onedrive网盘之中<del>可以通过API权限的方式直接通过网页访问</del>。</p>
<div class="note success flat"><p><a href="https://tabristrees-my.sharepoint.com/:u:/g/personal/severus_tabristrees_onmicrosoft_com/ERSYHkUKfutGs-zfsKIuwe8BOPLpq_eXkqZd89zviOizkg?e=0CNJCH">点击下载10.4.5版本</a><br>该版本教程网址为：<a href="https://www.aquaveo.com/software/gms-learning-tutorialswww.aquaveo.com">https://www.aquaveo.com/software/gms-learning-tutorialswww.aquaveo.com</a> 基本上包括了所有的基础软件操作和可以实现的功能教程，也可以在这里找到所有对应的项目资源数据文件。</p>
</div>
<p>有了这些东西之后可以相对快速的入门GMS，不用到处寻找软件教程以及相关书籍。but，这些tutorials都是全英文文档，对于不习惯看英文材料的同学可能不是很友好╮(╯▽╰)╭ 。</p>
<h1 id="MODFLOW"><a href="#MODFLOW" class="headerlink" title="MODFLOW"></a>MODFLOW</h1><p>这一次毕业论文其实主要是使用GMS中的T-PROGS和MODFLOW模块，事实上MODFLOW和T-PROGS都是开源的。T-PROGS由于年代久远似乎已经失传了，关于这部分内容是我毕业论文的主体，之后会单独出一篇学习笔记来详细阐述。</p>
<p>对于MODFLOW来说，商业软件GMS以及Visual MODFLOW等都是可以使用的，但是实际生产问题是千差万别的，没有所谓“通用的软件”可以解决实际上遇到的所有问题，对于科学研究的创新来说更是如此！我们需要学会在原有的代码的基础上添加自己对地下水运移这个过程的深入理解，一定的编程和数学物理能力必不可少，此外我们也不必要自己完全重新写写个软件出来。这可能也是USGS（美国地质调查局 United States Geological Survey）将MODFLOW开源并持续维护更新的原因所在吧。</p>
<p>而MODFLOW目前已经更新到<a href="https://www.usgs.gov/software/modflow-6-usgs-modular-hydrologic-model">MODFLOW 6</a><br>了，该项目也可以在GitHub（<a href="https://github.com/MODFLOW-USGS/modflow6">MODFLOW-USGS/modflow6</a>）上找到，甚至包括了一些大佬自己修复的一些bug和添加功能。</p>
<p>由于是开源软件，提供的都是Fortran语言的源代码，而USGS也相当<del>“贴心”</del>地提供了一系列关于如何使用的教程，我全部打包放在了我的云盘里一并提供在此：</p>
<div class="note success flat"><p>文件被我脑抽删除了，链接无了o(╥﹏╥)o，还是去官网自己下载吧</p>
</div>
<!-- # 总结一下嘛

感觉写了一千多字<span class="heimu">可能还没有😂</span>的废话......下次一定整点有用的！
![一张图而已，没什么好看的](http://image.tabirstrees.top/images/2021/02/06/E77C06B943FAD6398EAA3097BE3B80C1.jpg) -->
]]></content>
      <categories>
        <category>资源</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>GMS</tag>
        <tag>数值模拟</tag>
        <tag>地下水</tag>
      </tags>
  </entry>
  <entry>
    <title>T-PROGS</title>
    <url>/2021/01/10/T-PROGS/</url>
    <content><![CDATA[<h1 id="关于T-PROGS的简单介绍"><a href="#关于T-PROGS的简单介绍" class="headerlink" title="关于T-PROGS的简单介绍"></a>关于T-PROGS的简单介绍</h1><p>T-PROGS是一个可以模拟地质岩性在三维空间中的随机分布的成熟软件，它原本是基于Fortran语言的开源软件包，现在的地下水模拟软件GMS软件系统中已经包含了该模块，可以直接在GMS中直接使用。本文的目的在于记录该软件模块的使用学习和过程记录。</p>
<h1 id="为什么要使用T-PROGS"><a href="#为什么要使用T-PROGS" class="headerlink" title="为什么要使用T-PROGS"></a>为什么要使用T-PROGS</h1><p>在地下水数值模拟的过程中，由于地下水系统属于巨复杂系统，将其复杂的运移过程简单的用一个微分方程的计算结果代替必然会产生大量的不确定性；另外模拟所需要的参数在获取过程中同样会带来各种各样的不确定性。目前的地下水数值模拟逐渐将目光集中到地下水模拟的不确定性分析上，在各种非确定分析方法中使用广泛的随机模拟方法最为常见。</p>
<h2 id="随机模拟方法"><a href="#随机模拟方法" class="headerlink" title="随机模拟方法"></a>随机模拟方法</h2><p>地下水随机模拟主要有矩方程法和Monte Carlo法。矩方程法通过求解随机微分方程直接求取模拟结果的各阶统计矩；Monte-Carlo方法则是通过随机场生成器实现大量的确定模型，对这些实现的模拟结果进行统计分析得到模拟的统计特征。</p>
<p>在Monte-Carlo方法过程中涉及到随机参数场的生成。对<strong>渗透性</strong>这一参数而言，为了分析其在模拟过程中的不确定性大小，对其进行参数随机模拟，于是需要生成大量的渗透系数随机场。一般来说，渗透系数的自然分布满足<strong>对数正态分布</strong>的关系，在已知水文地质参数信息的帮助下通过各种条件模拟方法便可以模拟出未知点处的渗透系数概率分布情况，并基于此概率生成大量的确定参数场进行地下水数值模拟。</p>
<h2 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h2><p>此处涉及到水文地质概念模型建模过程的问题：1. 直接建模，在建立水文地质概念模型时直接输入所需要的各种边界条件，源汇项以及水文地质参数；2. 间接建模，在水文地质参数的建立过程中，并不是直接划分参数分区并给定相应的参数，而是先通过三维地质建模建立研究区的三维地质模型，再根据地质介质与水文地质参数之间的相互联系间接地建立水文地质参数场。间接建模的好处是考虑了自然情况下的物理因素（一般来说，误差范围内的水文地质参数就是由地质结构以及地层介质来决定的），减少了由于人为的参数分区而带来不确定性。</p>
<p>在此基础上，我们可以说实际上T-PROGS是一种基于马尔科夫链的“转移概率地统计（_Transition Probability Geostatistical_）”模型，用于生成地层岩性的三维随机分布。他主要处理的是类似钻孔信息的<strong>分类</strong>地质参数（指示地统计方法）。通过间接建模的方法利用T-PROGS便可以直接由钻孔数据得到渗透系数等水文地质参数的随机分布场，相对于其他方法更加占据优势，在国内外也得到了大量的应用。<del>举例就不要举例了，又不是写论文……</del></p>
<hr>
<h1 id="理论与方法"><a href="#理论与方法" class="headerlink" title="理论与方法"></a>理论与方法</h1><h2 id="地统计方法简单介绍"><a href="#地统计方法简单介绍" class="headerlink" title="地统计方法简单介绍"></a>地统计方法简单介绍</h2><p>地质统计学的核心以及基础是”变差(变异)函数”:</p>
<blockquote>
<p>空间中一点$x$与其相邻一点$x+h$的某一相关变量$Z(x)$方差的差值,称为$Z(x)$在$x$方向上的变异函数,记为$\gamma(x,h)$:  </p>
<script type="math/tex; mode=display">
\gamma(x, h)=\frac{1}{2} \operatorname{Var}[Z(x)-Z(x+h)]</script></blockquote>
<p>上式是在以为情况下成立的,高维情况都是以一维情况为基础,在二阶平稳场(简单来说就是$\gamma(x,h)$只与$h$有关,任何一点相同距离内的变差函数的均值都是一样的)中有:</p>
<blockquote>
<script type="math/tex; mode=display">
\gamma(h)=\frac{1}{2} E\left[(Z(x)-Z(x+h))^{2}\right]-\frac{1}{2}(E[Z(x)-Z(x+h)])^{2}</script></blockquote>
<p>如此一来,变异函数就被简化为一个单变量函数,并且在$x$方向上任取两点$x_i,x_i+h$对应的变异函数都是以$h$为自变量的随即变量的一个统计样本,其所有取值构成了一次统计。</p>
<p>对于<strong>克里金方法(Kriging Method)</strong>来说,空间中一点处某一参数$z$的估计值为:</p>
<script type="math/tex; mode=display">
\hat z_o = \sum_{i=1}^n\lambda_iz_i</script><p>其中$\hat{z_o}$是点处的估计值，即$z_o=z(x_o,y_o)$,$λ_i$是权重系数。克里金方法是用空间上所有已知点的数据加权求和来估计未知点的值。此处的权重是能够满足点 $(x_o,y_o)$处的估计值$\hat{z_o}$与真实值$z_o$的差最小的一套最优系数，即</p>
<script type="math/tex; mode=display">
\min_{\lambda_i} Var(\hat{z_o}-z_o)</script><p>同时满足无偏估计的条件:</p>
<script type="math/tex; mode=display">
E(\hat{z_o}-z_o)=0</script><p>求解简化（拉格朗日乘数法）之后可以得到下面的一组控制方程:</p>
<script type="math/tex; mode=display">
\left\{
    \begin{aligned}
        \sum_{i=1}^n\lambda_i\gamma((x_i,y_i),(x_j,y_j))+\mu &=\overline\gamma((x_o,y_o),V) \\
        \sum_{i=1}^n\lambda_i &= 1
    \end{aligned}
\right.</script><p>在上式中唯一未知的便是我们先前所提到的变差函数（或称变异函数,半方差函数；此处的$\overline\gamma(x_o,V)$表示以$(x_o,y_o)$为中心的一个空间范围$V$内所有的变差函数的均值）。事实上，根据地理学第一定律：距离越近空间相关性越强，我们可以简单地做出假设：</p>
<blockquote>
<p>两点的变差函数与其距离之间存在某种函数关系，这种函数关系可以是线性、二次函数、指数、对数关系。</p>
</blockquote>
<p>通过对数据集进行分析，从而寻找到一个最优的拟合曲线拟合距离$d$与变差函数$\gamma$的关系，得到函数关系式$\gamma = \gamma(d)$那么对于任意两点$(x_i,y_i)$，$(x_j,y_j)$，先计算他们之间的距离$d_{ij}$然后根据得到的函数关系就可以得到这两点的变差函数，进一步的解决空间中一点的参数估计问题。</p>
<hr>
<h2 id="马尔科夫链与转移概率地统计"><a href="#马尔科夫链与转移概率地统计" class="headerlink" title="马尔科夫链与转移概率地统计"></a>马尔科夫链与转移概率地统计</h2><p>转移概率是马尔科夫链的一个重要概念，马尔科夫过程假设事物后一时刻的状态至于前一时刻的状态相关。换句话说：今天的事情由昨天完全决定，明天的事情由今天完全决定，并且与此前的每一天都没有直接关系。在此基础上所谓转移概率就是从一种状态转变为另一种状态的概率，在地统计学中有如下的表达：</p>
<script type="math/tex; mode=display">
t_{jk}(h) = Pr(k\ occurs\ at\ (x+h)\ |\ j\ occurs\ at\ x)</script><p>它表示已知$x$处的岩性为$j$，$(x+h)$处岩性为$k$的概率。</p>
<p>利用指示地统计中指示变量的形式（$I_j(x)$）我们可以将变差函数转为下面的形式（协变差函数）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \gamma_{jk}(h) &= \frac{1}{2}E{[I_j(x)-I_j(x+h)][I_k(x)-I_k(x+h)]} \\
    I_j(x) &=\left\{
        \begin{aligned}
            1\ &,if\ occurs\ at\ x\\
            0\ &,otherwise
        \end{aligned}
    \right.
\end{aligned}</script><p>同时，将转移概率用指示变量表示：</p>
<script type="math/tex; mode=display">
t_{jk}(h) = \frac{E[(I_j(x)I_k(x+h))]}{E[I_j(x)]}</script><blockquote>
<p>PS:这里使用均值是一个统计过程，实际过程过我们不可能知道概率的实际大小，所以利用统计得到的两个事件各自在多个统计点发生的平均数之比来代替概率之比。事实上，在指示地统计中均值和概率是等价的。</p>
</blockquote>
<p>紧接着,我们可以将转移概率和所谓协变差函数结合起来,找出它们的关系式:</p>
<p>作如下的假设:</p>
<script type="math/tex; mode=display">
\begin{aligned}
    P_j(x) &= E[E[I_j(x)]]\\
    P_{jk}(h) &= E[E[I_j(x)I_k(x+h)]]
\end{aligned}</script><p>特别的,我们有:$P_{jk}(0) = P_j(x)P_k(x)$，如此一来，协变差函数以及转移概率就变成了如下的形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \gamma_{jk}(h) &= P_{jk}(0)-\frac{1}{2}(P_{jk}(h)+P_{jk}(-h))\\
    t_{jk}(h) &= \frac{P_{jk}(h)}{P_j(x)}\\
    \Rightarrow\ \ \ \gamma_{jk}(h) &= P_j(x){t_{jk}(0)-\frac{1}{2}[t_{jk}(h)+t_{jk}(-h)]}
\end{aligned}</script><p>最后，结合克里金方法与转移概率，用转移概率矩阵表达上述普通克里金方程：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
t_{i j}\left(x_{1}-x_{1}\right) & \cdots & t_{i j}\left(x_{N}-x_{1}\right) & 1 \\
\vdots & \ddots & \vdots & \vdots \\
t_{i j}\left(x_{1}-x_{N}\right) & \cdots & t_{i j}\left(x_{N}-x_{N}\right) & 1 \\
1 & \cdots & 1 & 0
\end{array}\right]\left[\begin{array}{c}
\lambda_{j, 1} \\
\vdots \\
\lambda_{j, n} \\
\mu
\end{array}\right]=\left[\begin{array}{c}
t_{i j}\left(x-x_{1}\right) \\
\vdots \\
t_{i j}\left(x-x_{N}\right) \\
1
\end{array}\right]</script><p>这样，通过转移概率利用克里金进行空间插值就得到了实现。</p>
<hr>
<div class="note primary flat"><p>参考文献:<br>克里金(Kriging)插值的原理与公式推导:<a href="https://xg1990.com/blog/archives/222">https://xg1990.com/blog/archives/222</a></p>
<p>董英, 基于随机水文地质结构的华北平原地下水流模拟研究, 2006, 中国地质大学（北京）. </p>
</div>
]]></content>
      <categories>
        <category>科研</category>
        <category>地下水数值模拟</category>
      </categories>
      <tags>
        <tag>GMS</tag>
        <tag>地下水溶质运移模型</tag>
        <tag>地统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex 论文排版相关学习</title>
    <url>/2020/08/28/texstudy/</url>
    <content><![CDATA[<h1 id="1-一点点关于Latex的介绍"><a href="#1-一点点关于Latex的介绍" class="headerlink" title="1. 一点点关于Latex的介绍"></a>1. 一点点关于Latex的介绍</h1><!-- ![20200828160435](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828160435.png) -->
<p>Latex是一款排版软件，诸如教材、报纸、书信等纸质印刷相关的排版都是可以做的。一般人使用Latex最多的地方是论文的写作，特别是涉及到大量公式的数学物理方面的科技论文，这方面目前有很多网上流行的模板，我们只需要在了解简单的Latex基础操作的基础上带入模板就好，所以还是非常方便的。</p>
<blockquote>
<p>有很多 Geeks 或者 LaTeX’s Fanatical Fans 过分地强调了 LaTeX 的一些并非重点的特性，以至于很多初学者会觉得 LaTeX 很神秘很复杂，从而引发了初学者的畏难情绪甚至是负面情绪。尽管这些 Fans 说得并没有错，我是说在事实上，但是他们的表达方式和内心态度却间接阻碍了 LaTeX 的发展，我想这也是和他们的初衷相悖的。————Liam Huang<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
</blockquote>
<h1 id="2-Latex写作的进行"><a href="#2-Latex写作的进行" class="headerlink" title="2. Latex写作的进行"></a>2. Latex写作的进行</h1><h2 id="2-1-准备知识"><a href="#2-1-准备知识" class="headerlink" title="2.1 准备知识"></a>2.1 准备知识</h2><p>Latex中以<code>%</code>作为注释开头，也就是不会输出<code>%</code>后直到行末的所有内容，同时不会影响最终的排版效果，仅供人们在阅读源代码是的注释。至于数学意义上的“%”字符，需要在<code>%</code>之前加上<code>\</code>进行转义（escape）。即：<code>\%</code>。除此之外还有很多特殊字符的使用需要各位注意:<br><!-- >![20200828115548](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200828115548.png) --></p>
<p>当我们需要对我们的内容做出明确控制时，我们需要调用控制序列来解决问题，类似于其他编程语言中的函数。比如我们需要在第一行指明文档类型，需要使用:<code>\documentclass[]&#123;article&#125;</code>，这就是一个控制序列（命令、标记），以<code>\</code>开头，以第一个<strong>空格或者非字母的字符</strong>结束的一串文字。<code>&#123;&#125;</code>中是这个控制序列的必要参数(此处为‘article’，其作用是调用名为“article”的文档类），部分控制序列还会有方括号<code>[]</code>，表示可选参数。</p>
<blockquote>
<p>所谓的文档类，是TeX系统预设或者用户自己给定的一些格式的集合，不同的文档类对应了不同的输出效果。</p>
</blockquote>
<p>TeX中的控制序列包括了两种，一种是一个控制序列单独使用，例如<code>\documentclass[]&#123;&#125;</code>等；另一种是需要两个配套的控制序列成对出现，通常是<code>\begin</code>和<code>\end</code>，这两个控制序列以及其中间的内容被称为_环境_。他们之后的第一个必要参数总是一致的，被称为环境名。<br>只有在<code>document</code><strong>环境</strong>中的内容才能够被输出到文档中去或是作为控制序列对文档产生影响。也就是说，在<code>\end&#123;document&#125;</code>之后插入的内容都是无效的。</p>
<p>在从<code>\documentclass&#123;article&#125;</code>到<code>\begin&#123;document&#125;</code>之间的部分被称为“导言区(preamble)”，你可以将导言区理解为使用某些特殊的控制序列对整篇文章的格式进行设置的区域，比如我们可以在导言区引用一些额外的宏包以及设置页面大小、页眉页脚、章节标题样式等等<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p>
<p>另外，类似于markdown文件，TeX中换行是需要两次换行才能起效（需要一个空行），否则会被处理成一个简单的空格，且命令后面的空格会被忽略，需要使用<code>\</code>进行转义。为了将命令（控制序列）的范围进行限制，需要使用<code>&#123;&#125;</code>将命令内容包括起来<sup><a href="#fn_3" id="reffn_3">3</a></sup>，如：<code>\frac&#123;a&#125;&#123;b&#125;</code>表示：</p>
<script type="math/tex; mode=display">\frac{a}{b}</script><h2 id="2-2-导言区控制序列"><a href="#2-2-导言区控制序列" class="headerlink" title="2.2 导言区控制序列"></a>2.2 导言区控制序列</h2><ul>
<li><code>\documentclass[]&#123;&#125;</code>规定了使用的文档模板，是文件必须的命令，可供选择的必要参数有：article、book、report、beamer等TeX自带模板或使用者自己准备的一系列模板；可选参数主要定义打印输出时的编码、纸张等条件。如：<code>\documentclass[UTF8,a4paper]&#123;article&#125;</code></li>
<li><code>\usepackage&#123;&#125;</code>可以用来引用宏包，常用的有：<code>graphicx</code>——插图；<code>amsmath</code>——一些方便的公式、符号命令等”</li>
<li>除此之外还涉及到标题、作者以及日期等等分别用以下的控制序列进行控制：<code>\title&#123;&#125;</code>、<code>\author&#123;&#125;</code>、<code>\date&#123;&#125;</code>，这些内容在导言区设置好后可以利用<code>\maketitle</code>控制序列在环境区域内按照特定格式输出</li>
</ul>
<p>以下是演示：<br><figure class="highlight plaintext"><figcaption><span>&#123;cmd</span></figcaption><table><tr><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\title&#123;你好，world!&#125;</span><br><span class="line">\author&#123;Liam&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">你好，world!</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><br><img src="https://image.tabirstrees.top/images/2025/02/22/20250222192258900.png" alt="20200828144122"></p>
<h2 id="2-3-章节和段落"><a href="#2-3-章节和段落" class="headerlink" title="2.3 章节和段落"></a>2.3 章节和段落</h2><p>在文档类 “article/ctexart” 中，定义了五个控制序列来调整行文组织结构。他们分别是</p>
<ul>
<li><code>section&#123;&#125;</code></li>
<li><code>subsection&#123;&#125;</code></li>
<li><code>subsubsection&#123;&#125;</code></li>
<li><code>paragraph&#123;&#125;</code></li>
<li><code>subparagraph&#123;&#125;</code></li>
</ul>
<p>在”report/ctexrep”文档类中，还有<code>\chapter&#123;·&#125;</code>；”book/ctexbook”文档类中，还定义了<code>\part&#123;·&#125;</code>。取决于各种文档类（模板）中所定义的章节控制序列。</p>
<p>以下是演示：<br><figure class="highlight plaintext"><figcaption><span>&#123;cmd</span></figcaption><table><tr><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\title&#123;你好，world!&#125;</span><br><span class="line">\author&#123;Liam&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">\section&#123;你好中国&#125;</span><br><span class="line">中国在East Asia.</span><br><span class="line">\subsection&#123;Hello Beijing&#125;</span><br><span class="line">北京是capital of China.</span><br><span class="line">\subsubsection&#123;Hello Dongcheng District&#125;</span><br><span class="line">\paragraph&#123;Tian&#x27;anmen Square&#125;</span><br><span class="line">is in the center of Beijing</span><br><span class="line">\subparagraph&#123;Chairman Mao&#125;</span><br><span class="line">is in the center of 天安门广场。</span><br><span class="line">\subsection&#123;Hello 山东&#125;</span><br><span class="line">\paragraph&#123;山东大学&#125; is one of the best university in 山东。</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><br><img src="https://image.tabirstrees.top/images/2025/02/22/20250222192445010.png" alt="20200828145319"></p>
<h2 id="2-4-插入数学公式、图片或表格"><a href="#2-4-插入数学公式、图片或表格" class="headerlink" title="2.4 插入数学公式、图片或表格"></a>2.4 插入数学公式、图片或表格</h2><h3 id="2-4-1-数学公式插入"><a href="#2-4-1-数学公式插入" class="headerlink" title="2.4.1 数学公式插入"></a>2.4.1 数学公式插入</h3><p>LaTex相对于Word最优秀的地方莫过于他对于数学公式的渲染非常出色，不用我们刻意去调整数学公式的排版，只需要我们输入类似于编程语言的伪代码，系统便可以自己将伪代码转化为我们需要的数学表达。同时大部分的数值计算软件或者编程软件都自带了可以将计算结果转化为TeX语言的函数，甚至可以在Latex系统中嵌入Mathematica进行科学计算，不过这都是进阶内容了。目前姑且还用不到。以上这些足以说明Tex在论文排版中的优越地位！</p>
<p>数学公式或者图片的插入需要在导言区引用之前提到过的宏包，即：<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">\uespackage</span><span class="template-variable">&#123;amsmath&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>文本中数学公式的引用主要有两种方式：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。</p>
<ul>
<li>行内公式：<ul>
<li><script type="math/tex; mode=display">...</script></li>
<li><code>\(...\)</code></li>
<li><code>\begin&#123;math&#125; ... \end&#123;math&#125;</code></li>
</ul>
</li>
<li>行间公式：<ul>
<li><code>\[ ... \]</code>     （无编号）</li>
<li>$$$ … $$$     （无编号，会改变行文的默认行间距，不推荐）</li>
<li><code>\begin&#123;displaymath&#125; ... \end&#123;displaymath&#125;</code>     （无编号）</li>
<li><code>\begin&#123;equation*&#125; ... \end&#123;equation*&#125;</code>     （无编号）</li>
<li><code>\begin&#123;equation&#125;...\end&#123;equation&#125;</code>     （有编号）</li>
</ul>
</li>
</ul>
<p>至于各种数学符号的表达以及特殊字符的控制序列由于太多，不好整理，可以参看<a href="https://blog.csdn.net/GarfieldEr007/article/details/51646604">此处</a>或者<a href="https://blog.csdn.net/lanxuezaipiao/article/details/44341645">这里</a>。</p>
<h3 id="2-4-2-图片插入"><a href="#2-4-2-图片插入" class="headerlink" title="2.4.2 图片插入"></a>2.4.2 图片插入</h3><p>插入图片的方式比较多，这里推荐上述graphicx宏包中的<code>\includegraphics</code>命令进行操作：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">\documentclass</span><span class="template-variable">&#123;article&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">\usepackage</span><span class="template-variable">&#123;graphicx&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">\begin</span><span class="template-variable">&#123;document&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">\includegraphics</span><span class="template-variable">&#123;a.jpg&#125;</span><span class="xml"> % 名为“a.jpg”的文件与TeX源文件同目录</span></span><br><span class="line"><span class="xml">\end</span><span class="template-variable">&#123;document&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果图片超过了输出文件的纸张大小，或者效果不太好的时候可以用 <code>\includegraphics</code> 控制序列的可选参数来控制。比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">\includegraphics<span class="selector-attr">[width = .8\textwidth]</span>&#123;<span class="selector-tag">a</span><span class="selector-class">.jpg</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf">此处</a>可以获取到关于上述宏包的文档。</p>
<h3 id="2-4-3-表格插入"><a href="#2-4-3-表格插入" class="headerlink" title="2.4.3 表格插入"></a>2.4.3 表格插入</h3><p>tabular 环境提供了最简单的表格功能。它用 \hline 命令表示横线，在列格式中用 | 表示竖线；用 &amp; 来分列，用 \\ 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 l、c、r 来表示<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</p>
<p>以下是演示：<br><figure class="highlight plaintext"><figcaption><span>&#123;cmd</span></figcaption><table><tr><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\title&#123;你好，world!&#125;</span><br><span class="line">\author&#123;Liam&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tabular&#125;&#123;|l|c|r|&#125;</span><br><span class="line"> \hline</span><br><span class="line">操作系统&amp; 发行版&amp; 编辑器\\</span><br><span class="line"> \hline</span><br><span class="line">Windows &amp; MikTeX &amp; TexMakerX \\</span><br><span class="line"> \hline</span><br><span class="line">Unix/Linux &amp; teTeX &amp; Kile \\</span><br><span class="line"> \hline</span><br><span class="line">Mac OS &amp; MacTeX &amp; TeXShop \\</span><br><span class="line"> \hline</span><br><span class="line">通用&amp; TeX Live &amp; TeXworks \\</span><br><span class="line"> \hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><br><img src="https://image.tabirstrees.top/images/2025/02/22/20250222192829115.png" alt="20200828153609"></p>
<p>有时候我们会遇到表格或者图片的位置不好确定，这个时候我们可以把它们设置为“浮动体”，具体可以参见<a href="https://liam.page/2014/09/08/latex-introduction/#%E6%B5%AE%E5%8A%A8%E4%BD%93">此处</a></p>
<h1 id="3-版面调整"><a href="#3-版面调整" class="headerlink" title="3. 版面调整"></a>3. 版面调整</h1><p>版面设置一般采用各种宏包进行设置，使用较多的包有：<code>geometry</code>（页边距）、<code>fancyhdr</code>（页眉页脚）、<code>indentfirst</code>（首行缩进）以及<code>setspace</code>（行间距）。一些自带的控制序列也可以用来进行版面设置，比如段间距的设置可以用<code>\parskip</code>调整。</p>
<p>诸如此类的版面调整的命令由于各位大佬做的宏包太多，加上每个人使用系统或者习惯上的区别，整理起来有很大的困难，最好的办法是边用边学，并且逐渐形成自己的习惯。正所谓熟能生巧，在不断运用的过程中就能够找到最适合自己的哪一种办法，这里提供一些可以达到目的的简单方法。另外提供一下相关方面的博客以供参考。</p>
<ul>
<li><a href="https://liam.page/2014/09/08/latex-introduction/#%E7%89%88%E9%9D%A2%E8%AE%BE%E7%BD%AE">一份其实很短的Latex文档——Liam Huang </a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56405574">LaTeX入门(七)——页面设置——勥巭炛</a></li>
<li><a href="https://www.jianshu.com/p/da10bc1c497a">17LaTeX学习系列之—-LaTeX的版面设计——张一根</a></li>
</ul>
<h1 id="4-参考文献（文档）"><a href="#4-参考文献（文档）" class="headerlink" title="4. 参考文献（文档）"></a>4. 参考文献（文档）</h1><blockquote id="fn_1">
<sup>1</sup>. <a href="https://liam.page/2014/09/08/latex-introduction/">https://liam.page/2014/09/08/latex-introduction/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="http://liuchengxu.org/blog-cn/posts/quick-latex/">http://liuchengxu.org/blog-cn/posts/quick-latex/</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <a href="http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf">http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. <a href="https://www.jianshu.com/p/da10bc1c497a">https://www.jianshu.com/p/da10bc1c497a</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjQueDxs73rAhVOqZ4KHSD_BMgQFjACegQIBRAB&amp;url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F56405574&amp;usg=AOvVaw1j3bECgHAB5XTcdABhOEDL">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjQueDxs73rAhVOqZ4KHSD_BMgQFjACegQIBRAB&amp;url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F56405574&amp;usg=AOvVaw1j3bECgHAB5XTcdABhOEDL</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<div class="note success flat"><ol>
<li><a href="https://liam.page/2014/09/08/latex-introduction/">https://liam.page/2014/09/08/latex-introduction/</a></li>
<li><a href="http://liuchengxu.org/blog-cn/posts/quick-latex/">http://liuchengxu.org/blog-cn/posts/quick-latex/</a></li>
<li><a href="http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf">http://www.math.pku.edu.cn/teachers/lidf/docs/textrick/tricks.pdf</a></li>
<li><a href="https://www.jianshu.com/p/da10bc1c497a">https://www.jianshu.com/p/da10bc1c497a</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56405574">https://zhuanlan.zhihu.com/p/56405574</a></li>
</ol>
</div>
<h1 id="5-补张图"><a href="#5-补张图" class="headerlink" title="5. 补张图"></a>5. 补张图</h1><p>哈哈哈哈哈O(∩_∩)O😎😎😎</p>
<p><img src="https://image.tabirstrees.top/images/2025/02/22/20250222193102530.png" alt="1598496066545"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>论文排版</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+fluid主题添加二级导航</title>
    <url>/2020/05/14/hexo-fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%BA%8C%E7%BA%A7%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<!-- ![6418A1E7501871AF561B89A22AB13D3F](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/6418A1E7501871AF561B89A22AB13D3F.png) -->
<hr>
<div class="note info flat"><p>使用hexo博客的fluid主题已经有一段时间了，因为打算写的内容很杂，所从很早开始就想要做一个二级导航出来，这段时间一直在折腾这个东西！前几天给网站加上了豆瓣的📕书评和🎦电影栏目，发现这样要是以后再加点什么东西导航栏就放不下了。所以痛定思痛决定开始弄二级导航（<del>鬼知道我为了做这个东西连即将要到来的考试和难到爆炸的课程设计都不管了</del>）</p>
</div>
<h1 id="开始搞事情😄O-∩-∩-O"><a href="#开始搞事情😄O-∩-∩-O" class="headerlink" title="开始搞事情😄O(∩_∩)O"></a>开始搞事情😄O(∩_∩)O</h1><p>emmmmm，首先<del>其实差不多只有这一步啦</del>我们要做的就是更改文章生成的模板，fluid主题的话就打开主题目录下的<code>layout</code>文件夹中的<code>nav.ejs</code>文件，修改为如下的样式（其中注释的位置就是修改的主要位置，也是导航栏内容所在，你也可以按照自己的想法修改这个地方的内容）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">&quot;navbar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">href</span>=<span class="string">&quot;&lt;%- url_for() %&gt;&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&lt;%- theme.navbar.blog_title || config.title %&gt;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;navbar-toggler-btn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggler&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;collapse&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">data-target</span>=<span class="string">&quot;#navbarSupportedContent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">aria-controls</span>=<span class="string">&quot;navbarSupportedContent&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Toggle navigation&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;animated-icon&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Collapsible content --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;collapse navbar-collapse&quot;</span> <span class="attr">id</span>=<span class="string">&quot;navbarSupportedContent&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navbar-nav ml-auto text-center&quot;</span>&gt;</span></span><br><span class="line">        &lt;% for(const each of theme.navbar.menu) &#123; %&gt;</span><br><span class="line">          &lt;% if (!each.link) continue %&gt;</span><br><span class="line">          &lt;% var text = each.name || __(each.key + &#x27;.title&#x27;) %&gt;</span><br><span class="line">          &lt;% if (text.indexOf(&#x27;.title&#x27;) !== -1) &#123;</span><br><span class="line">            text = each.key</span><br><span class="line">          &#125; %&gt;</span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= url_for(each.link) %&gt;&quot;</span>&gt;</span></span><br><span class="line">              &lt;%- each.icon ? &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#x27; + each.icon + &#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27; : &#x27;&#x27; %&gt;</span><br><span class="line">              &lt;%- text %&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上的部分是一级导航的部分--&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--这里判断有没有二级菜单，有的话遍历出二级菜单（就是竖着的那部分）--&gt;</span></span><br><span class="line">              &lt;% if (each.submenu) &#123; %&gt;</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;sub-menu&quot;</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--//遍历出二级菜单（就是竖着的那部分）--&gt;</span></span><br><span class="line">                  &lt;% for (const submenu of each.submenu)&#123; %&gt;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--//a标签里当然是输出二级菜单的路径咯--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%- url_for(submenu.link) %&gt;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--//i标签里输出二级菜单的icon的class咯--&gt;</span></span><br><span class="line">                        &lt;%- each.icon ? &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#x27; + submenu.icon + &#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27; : &#x27;&#x27; %&gt;</span><br><span class="line">                        <span class="comment">&lt;!--//这里输出二级菜单名咯--&gt;</span></span><br><span class="line">                        &lt;%= submenu.key %&gt;</span><br><span class="line">                      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                  &lt;% &#125; %&gt;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">              &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">        &lt;% if(theme.search.enable) &#123; %&gt;</span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search-btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#modalSearch&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;<span class="name">i</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;iconfont icon-search&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="修改css配置，让它好看点"><a href="#修改css配置，让它好看点" class="headerlink" title="修改css配置，让它好看点"></a>修改css配置，让它好看点</h1><p>如果不修改css配置其实也是可以的，只不过很丑就对了。</p>
<p>所以我们打开主题目录下<code>source/css/mian.styl</code>，本来应该在子项对应的部分添加，但是考虑到（<del>好吧，╮(╯-╰)╭，其实是我懒</del>）慢慢找实在是太麻烦了，所以我们直接在main文件里添加（这部分你可以先<code>hexo s</code>打开浏览器进行调试到你喜欢的样式，然后再复制相应的样式表到文件中）如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sub-menu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">8px</span> <span class="number">16px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">box-shadow</span>: -<span class="number">6px</span> <span class="number">6px</span> <span class="number">8px</span> black;</span><br><span class="line">&#125;</span><br><span class="line">// 以上是控制二级菜单呼出的形式</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sub-menu</span> <span class="selector-class">.li</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-item</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.sub-menu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line">// 控制鼠标停留在一级菜单上时呼出二级菜单</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-class">.nav-item</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们的基本的配置就算是完成了，接下来就是二级菜单的写法！</p>
<h1 id="配置文件中二级菜单的写法"><a href="#配置文件中二级菜单的写法" class="headerlink" title="配置文件中二级菜单的写法"></a>配置文件中二级菜单的写法</h1><p>打开主题配置文件<code>fluid_config.yml</code>，在菜单部分以“_分类_”菜单为例我们做如下的改动<br>submenu指定二级菜单，和一级菜单类似，<strong>最后用[]括起来！！！</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="attr">blog_title:</span>  <span class="comment"># 导航栏左侧的标题，为空则按 hexo config.title 显示</span></span><br><span class="line">  <span class="attr">menu:</span>  <span class="comment"># 可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称；submenu指定二级菜单，和一级菜单类似，最后用[]括起来！！！</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">&#x27;home&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;iconfont icon-home-fill&#x27;</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">&#x27;archive&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/archives/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;iconfont icon-archive-fill&#x27;</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">&#x27;category&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;#&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;iconfont icon-category-fill&#x27;</span>, <span class="attr">submenu:</span> [</span><br><span class="line">      &#123; <span class="attr">key:</span> <span class="string">&#x27;全部&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/categories/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;icofont-abc&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">key:</span> <span class="string">&#x27;生活&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/categories/生活/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;icofont-love&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">key:</span> <span class="string">&#x27;🖊笔记&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/categories/笔记/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;icofont-notebook&#x27;</span> &#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">&#x27;tag&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/tags/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;iconfont icon-tags-fill&#x27;</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">&#x27;about&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;/about/&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;iconfont icon-user-fill&#x27;</span> &#125;</span><br><span class="line">    <span class="comment">#- &#123; key: &#x27;links&#x27;, link: &#x27;/links/&#x27;, icon: &#x27;iconfont icon-link-fill&#x27; &#125; # 友链页，把前面#去掉即可展示</span></span><br></pre></td></tr></table></figure>
<p>这样我们就完成了一个主题的二级导航自定义，当然这样其实还是不太好看，可以自己用css进行调整。此外，针对不同的主题配置<code>config.yml</code>的不同写法情况，其实都是大同小异的，<a href="https://www.hojun.cn/2019/01/08/ck8irvkwx009qdwtu8ejla2mg/">可以点我去往某个大佬的空间看看，以作参考！！！&lt;(￣︶￣)↗[GO!]</a>。</p>
<!-- 以我的网站为例最终实现就是这样的效果：
![20200514170113](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200514170113.png)
![20200514170146](https://hexo-1301133429.cos.ap-chengdu.myqcloud.com/20200514170146.png) -->
<p>哈哈哈哈，我觉得还是可以的！！！😁😁😁<br><div class="note success flat"><p>参考：</p>
<p>yaml基本语法及实现Hexo二级导航栏功能<a href="https://www.hojun.cn/2019/01/08/ck8irvkwx009qdwtu8ejla2mg/">https://www.hojun.cn/2019/01/08/ck8irvkwx009qdwtu8ejla2mg/</a></p>
<p>为博客网站增加一个二级目录菜单<a href="https://sunhwee.com/posts/65d7181d.html">https://sunhwee.com/posts/65d7181d.html</a></p>
<p>如何通过html和css完成下拉菜单的制作？<a href="https://www.zhihu.com/question/36356940">https://www.zhihu.com/question/36356940</a></p>
<p>and so on ……</p>
</div></p>
]]></content>
      <categories>
        <category>资源</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>web技术</tag>
      </tags>
  </entry>
  <entry>
    <title>放逐者</title>
    <url>/2020/04/14/%E6%94%BE%E9%80%90%E8%80%85/</url>
    <content><![CDATA[<div class="note primary flat"><p>无垠的宇宙仿佛一块巨大的黑色天鹅绒，闪烁的群星变作天鹅绒上美丽的宝石，熠熠生辉的黑暗间一道明亮的轨迹插入！一艘“放逐者”号的小型探索式宇宙飞船在宇宙中已经航行了十年零四个月！</p>
</div>
<p>“你觉得真的有神存在吗？”</p>
<p> “这话是什么意思？”</p>
<p> “我最近老是觉得有种被人监视的感觉，可是又找不出来到底是谁在监视！我有点害怕！”</p>
<p> “你怕是最近忙晕了吧，脑子出问题了？”</p>
<p> “我没和你开玩笑！我真的有这种感觉，当我一个人独处的时候就尤为强烈！一开始我也没当回事，可是直到最近发生了那件事，我就确定了我的感觉是真的！”</p>
<p> “什么事？最近到底发生了什么？你可不要乱来我们这是在太空中，就我们两人，出了事可不会有人来救我们的！”</p>
<p> “我知道！我没干什么，只是……，你知道的！就我那间实验室，我在我们开始这趟旅程的时候在一个培养基里培育了当时的一种新型细菌，就是为我们生产食物的那种！”</p>
<p> “我知道，有什么问题吗？”</p>
<p> “就在几天前，我在培养基的外围发现了一些经过变异的细菌，你不觉得奇怪吗？按照道理来说，它们离开了培养基中间的营养物质就基本无法存活的啊！可现在的情况看上去是他们在争先恐后的往外面爬！”</p>
<p> “嗯？你为什么说‘争先恐后’？”</p>
<p> “因为一发现这件事后我就清除了外围的细菌，可是第二天我再去看的时候又出现了这种情况，如果说前面一次是偶然，那这一次又算什么？接下来的几天里，我每天都重复地清理，但每天都会有新的细菌在培养基外出现，而且数量还越来越多！再这样下去，我的培养基就快要空了！”</p>
<p> “呃，是有些奇怪！不过这也说不了什么吧！折和你感觉被人监视有什么关系吗？”</p>
<p> “问题在于在此之前我的这种感觉都还是极其轻微的，但从那天起，我几乎每天都会梦到同一件事情！”</p>
<p> “啥玩意儿！梦到同一件什么事情？”</p>
<p> “我总是梦到自己似乎在一个实验室里。作为观察者观察一个我也说不上来是什么的东西，嗯，等等！气泡！对，那东西就像是气泡！不，应该是类似于气泡的膜！”</p>
<p> “这有什么奇怪的，你想多了吧！”</p>
<p> “不，重点在于气泡里面的东西！”</p>
<p> “哈哈哈，里面有什么不得了的东西吗？连你都会害怕？”</p>
<p> “你在梦里看见你自己是什么感受？”</p>
<p> “你什么意思？”</p>
<p> “我看到的！气泡里面是宇宙，虽然看上去很小，但是你却可以感觉到那种没有边界，无法逃离的无垠感！还有很多好看的闪闪发光的星星，就像是天鹅绒上面的宝石！我们的飞船就这样在天鹅绒上“滑行着”，我还看见了你我的脸！每当此时我都会惊醒！”</p>
<p> “哈哈哈，你逗我吗？这哪里奇怪了？你是不是这几天太累了，这么多年的航行确实很枯燥啊！你可不要在这个时候出岔子，我看你这几天精神状态很不稳定！要不接下来的几天就由我来做全部的工作吧，你先休息几天？”</p>
<p> “你什么意思？你觉得我在开玩笑？我精神好得很！你难道没注意到吗？那些细菌！那些到外围的细菌！不就是我们吗？我们向宇宙外围飞了这么久！你没有想过我们为什么要这个方向一直飞？我们到底再找个什么东西？还是说我们只是吃饱了撑的到处转转而已！？”</p>
<p> “你说什么呢？我们不是为了探索宇宙来的吗？你不是要研究宇宙的形成的吗？这不就是我们的目的吗？你不知道我们在干什么？那这些年我们传回地球的数据是什么？你现在说这些话才是“吃饱了撑的吧”！”</p>
<p> “很好，我来告诉你那些数据有什么意义！我们的世界，不，应该说是我们的宇宙是由更高维度的生命创造出来研究他们自身演化历程的！他们为了弄清楚自身的存在，构建了‘宇宙’这个模型来观察生命的诞生与进化，就像是我们研究细菌那样，它们准备很多个培养基，也就是宇宙！但仅仅只有少数的宇宙诞生了生命，更少的宇宙中生命诞生了文明！我们是被自然选择出来的幸运儿，然而这仍然改变不来我们存在价值就是被观察，被记录的事实！我们将会是他们最宝贵的研究材料，当你的研究材料想要逃离你给他们的用来观察的器皿时你会怎么做？如果是我，就像我之前做的那样，我的第一反应是清除！决不能让他们破坏了实验材料的稳定，要知道这可是亿万分之一概率才会出现的奇迹，说什么我都不会让机会丢失的！另外，你忘了一件事，我们最重要的使命不是了解宇宙的形成，而是弄清楚宇宙到底是什么样的！我们的航线一开始就是设定好的，从离开地球开始我们就一直朝着一个方向在前进！反正我们对于那些‘掌权者’根本不重要，当时选中我们来做这次航行就是为了不让我们参与地球的事务，亏我们还激动万分的为自己将成为第一批作超过太阳系的星际航行的人而骄傲！他们一开始就是决定好的不让我们回去，而且航线对于宇宙这种每个方向看起来根本就差不多的东西根本没什么意义！所以，我们只是被利用来寻求可能存在的宇宙的边界的！但是你去看看这些年的数据，你没有发现我们所在的这个宇宙越来越像是一个‘膜’了吗？你还记得很多年前的‘膜理论’吗？你再想想所谓的‘分形宇宙’的看法！我绝对不会相信你没有经历过被监视的感受！我们作为实验对象却正在试图逃出这个‘实验器皿’！你觉得我们前面将会遇到什么？嗯？我们就快要被抹除掉了！”</p>
<p>… …沉默！</p>
<p> “你疯了！”</p>
<p> “呵呵！也许吧！我知道你觉得我说的有理，你无法反驳我！你只是不愿意接受人类悲惨的现实，我们在我们所认为的世界里相互争夺，相互欺骗，相互之间勾心斗角，明争暗斗！到头来只是别人的研究材料，只是想想可能性就觉得可悲可笑！呵呵呵~！”</p>
<p> “你够了，即使你是对的！我们作为人类只是别人的实验材料，但是当我们诞生出智慧，催生出思想的那一刻起，我们就有了存在的价值，有了灵性！从我们文明诞生伊始我们就是和你所说的更高等的生命是平等的！他们有的东西我们同样是拥有的，我们有作为实验品的可能他们也绝不会排除在外！这个世界上，除了你所说的阴暗面也还有着很多美好的东西！为什么你没有看见这些东西？你没有看见爱，看见追求，看见苦难中那些难能可贵，熠熠生辉的品质？我可以这样给你说：无论地球上的那些人是不是想要将我永久的放逐，我都为自己所正在做的事情感到骄傲，因为我是在为整个人类文明存在做出贡献！我知道长期以来无聊的旅程有多么地折磨一个人的意志！我建议你还是休息吧！现在真正危险的是你，你自己心里也清楚的，在这种长期的孤独状态下是很容易疯掉的！我还不想失去你这个我现在唯一可以说话人！所以你最好是赶快给我想清楚！如果有一天你真的疯了，我会毫不犹豫的杀了你，你知道我会的！”</p>
<p> “… …你就是这样的人，我知道，你会的！我现在累了，想睡一会了。我会考虑你说的话，再见。”</p>
<p> 他起身。快速的，低着头，回房去了！看不见他脸上的表情，但是你仍可以感觉到他在发抖！</p>
<p> “唉~！”</p>
<p> 剩下来的一个人叹气，面无表情！他知道，至少某些人为的既定事实是大家都心知肚明的，只是他不愿意提起！现在，他就这样坐在那里！</p>
<p> 不一会，他也起身，记录下探测仪上的数据并传回给遥远的地球，他知道地球有和飞船仪器同步的记录设备作为备份，但还是每天会亲自己记录一遍再传回到地球的数据中心，这是他唯一感觉到与那颗遥远星球还存在着联系的时刻，十多年来，地球与这艘飞船的通讯仅仅只有这冰冷的数据，也只有在这时候他的内心才是最平静的。</p>
<p> 但是最近的数据似乎越来越奇怪了，所有的数据都在显示飞船附近暗物质密度正在随着航行深入急剧增加着，这意味着飞船承受的引力也会随之加大。飞船似乎正在穿越一个临界带。</p>
<p> 数据传回地球后，他回到了自己的房间，沉沉睡去，睡着前他在想不知道他的梦里会不会也出现自己！</p>
<p>“放逐者”仍然在天鹅绒上缓缓前行着。天鹅绒的黑色似乎愈发的深厚了，上面流光的宝石也变得越来越少，到最后也许只会剩下那永无止尽的黑色吧！此刻的地球，数据中心的工作人员发现一直正常连接并同步状态的“放逐者”在发出数据的那一刻，就那一瞬间，完完全全的失去了信号！人们再也无法了解到这个伟大的“放逐者”身上到底发生了什么，只知道它失联之前的所有数据都是正常的并且现阶段来说相当具有研究意义的！几天之后，数据中心将其被黑洞吞噬的消息外放，从此它连同它上面的人真正意义上的被放逐。也许多年以后，新的“放逐者”会找到“他们”的残骸！<br><div class="note success flat"><p>——end——</p>
</div></p>
]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>小说</tag>
        <tag>自己写的</tag>
      </tags>
  </entry>
</search>
